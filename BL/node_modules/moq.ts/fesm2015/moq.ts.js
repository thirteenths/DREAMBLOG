/**
 * @hidden
 */
class TrackedExpressionsFormatter {
    constructor(interactionFormatter) {
        this.interactionFormatter = interactionFormatter;
    }
    format(trackedExpressions) {
        let result = "";
        for (const expression of trackedExpressions) {
            result += `${this.interactionFormatter.format(expression)}\n`;
        }
        return result.substr(0, result.length - 1);
    }
}

/**
 * This function dumps into console.log all interactions with the mocked object
 */
function dump(mock, writer = console) {
    const formatter = mock.resolve(TrackedExpressionsFormatter);
    const expressions = mock.tracker.get().map(record => record.expression);
    const output = formatter.format(expressions);
    const delimiter = "-------------------------------";
    writer.log(`Dump of ${mock.name === undefined ? "noname mock" : mock.name}`);
    writer.log(delimiter);
    writer.log(`\n${output}`);
    writer.log(delimiter);
}

/**
 * Sets the rules where bounds of a range are included or excluded from the range.
 * See {@link Times.Between}
 */
var Range;
(function (Range) {
    Range[Range["Exclusive"] = 0] = "Exclusive";
    Range[Range["Inclusive"] = 1] = "Inclusive";
})(Range || (Range = {}));
/**
 * This class expresses the expectation about amount of invocations.
 *
 * @example
 * ```typescript
 *
 * const times = new Times(expected => expected === 1, `Should be called once`);
 * const actual = times.test(2);
 *
 * expect(actual).toBe(false);
 * expect(times.message).toBe(`Should be called once`);
 * ```
 *
 * ```typescript
 *
 * const mockName = 'mock name';
 *const mock = new Mock<ITestObject>(mockName);
 *const object = mock.object();
 *
 *object.property;
 *
 *const action = () => mock.verify(instance => instance.property, Times.AtLeast(2));
 *
 *expect(action).toThrow();
 * ```
 */
class Times {
    /**
     *
     * @param evaluator It takes actual value and decides if it is expected or not.
     * Returns true or false accordingly.
     * @param message A message that describes the expectation.
     */
    constructor(evaluator, message) {
        this.evaluator = evaluator;
        this.message = message;
    }
    /**
     * It expects that the actual would be equal or bigger then the expected value.
     *
     * @param callCount The expected value.
     */
    static AtLeast(callCount) {
        return new Times(expected => expected >= callCount, `Should be called at least ${callCount} time(s)`);
    }
    /**
     * It expects that the actual would be equal or bigger then 1.
     */
    static AtLeastOnce() {
        return Times._atLeastOnce;
    }
    /**
     * It expects that the actual would be equal or smaller then the expected value.
     *
     * @param callCount The expected value.
     */
    static AtMost(callCount) {
        return new Times(expected => expected <= callCount, `Should be called at most ${callCount} time(s)`);
    }
    /**
     * It expects that the actual would be equal or less then 1.
     */
    static AtMostOnce() {
        return Times._atMostOnce;
    }
    /**
     * It expects that the actual would be in the expected range of values.
     *
     * @param callCountFrom The lowest bound of the range.
     * @param callCountTo The highest bound of the range.
     * @param range  Sets the rules where bounds of a range are included or excluded from the range.
     */
    static Between(callCountFrom, callCountTo, range) {
        if (range === Range.Exclusive) {
            return new Times(expected => expected > callCountFrom && expected < callCountTo, `Should be called exclusively between ${callCountFrom} and ${callCountTo}`);
        }
        return new Times(expected => expected >= callCountFrom && expected <= callCountTo, `Should be called inclusively between ${callCountFrom} and ${callCountTo}`);
    }
    /**
     * It expects that the actual is equal to the expected value.
     *
     * @param callCount The expected value.
     */
    static Exactly(callCount) {
        return new Times(expected => expected === callCount, `Should be called exactly ${callCount} time(s)`);
    }
    /**
     * It expects that the actual is equal 0.
     */
    static Never() {
        return Times._never;
    }
    /**
     * It expects that the actual is equal 1.
     */
    static Once() {
        return Times._once;
    }
    /**
     * Evaluates the expectation against the actual value.
     *
     * @param callCount The actual value.
     */
    test(callCount) {
        return this.evaluator(callCount);
    }
}
Times._once = new Times(expected => expected === 1, "Should be called once");
Times._never = new Times(expected => expected === 0, "Should be called never");
Times._atMostOnce = new Times(expected => expected <= 1, "Should be called at most once");
Times._atLeastOnce = new Times(expected => expected >= 1, "Should be called at least once");

/* eslint-disable */
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
function stringify(token) {
    if (typeof token === "string") {
        return token;
    }
    if (Array.isArray(token)) {
        return `[${token.map(stringify).join(", ")}]`;
    }
    if (token == null) {
        return `${token}`;
    }
    if (token.overriddenName) {
        return `${token.overriddenName}`;
    }
    if (token.name) {
        return `${token.name}`;
    }
    const res = token.toString();
    if (res == null) {
        return `${res}`;
    }
    const newLineIndex = res.indexOf("\n");
    return newLineIndex === -1 ? res : res.substring(0, newLineIndex);
}

/* eslint-disable */
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
function getClosureSafeProperty(objWithPropertyToExtract) {
    for (const key in objWithPropertyToExtract) {
        if (objWithPropertyToExtract[key] === getClosureSafeProperty) {
            return key;
        }
    }
    throw Error("Could not find renamed property on target object.");
}

/* eslint-disable */
const __forward_ref__ = getClosureSafeProperty({ __forward_ref__: getClosureSafeProperty });
/**
 * Allows to refer to references which are not yet defined.
 *
 * For instance, `forwardRef` is used when the `token` which we need to refer to for the purposes of
 * DI is declared, but not yet defined. It is also used when the `token` which we use when creating
 * a query is not yet defined.
 *
 * @usageNotes
 * ### Example
 * {@example core/di/ts/forward_ref/forward_ref_spec.ts region='forward_ref'}
 * @publicApi
 */
function forwardRef(forwardRefFn) {
    forwardRefFn.__forward_ref__ = forwardRef;
    forwardRefFn.toString = function () {
        return stringify(this());
    };
    return forwardRefFn;
}
/**
 * Lazily retrieves the reference value from a forwardRef.
 *
 * Acts as the identity function when given a non-forward-ref value.
 *
 * @usageNotes
 * ### Example
 *
 * {@example core/di/ts/forward_ref/forward_ref_spec.ts region='resolve_forward_ref'}
 *
 * @see `forwardRef`
 * @publicApi
 */
function resolveForwardRef(type) {
    return isForwardRef(type) ? type() : type;
}
/** Checks whether a function is wrapped by a `forwardRef`. */
function isForwardRef(fn) {
    return typeof fn === "function" && fn.hasOwnProperty(__forward_ref__) &&
        fn.__forward_ref__ === forwardRef;
}

/* eslint-disable */
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
class InjectionToken {
    constructor(desc) {
        this.desc = desc;
    }
    toString() {
        return `InjectionToken ${this.desc}`;
    }
}

/* eslint-disable */
/**
 * An InjectionToken that gets the current `Injector` for `createInjector()`-style injectors.
 *
 * Requesting this token instead of `Injector` allows `StaticInjector` to be tree-shaken from a
 * project.
 *
 * @publicApi
 */
const INJECTOR = new InjectionToken("INJECTOR");
const _THROW_IF_NOT_FOUND = {};
const THROW_IF_NOT_FOUND = _THROW_IF_NOT_FOUND;
const NG_TEMP_TOKEN_PATH = "ngTempTokenPath";
const NG_TOKEN_PATH = "ngTokenPath";
const NEW_LINE = /\n/gm;
const NO_NEW_LINE = "ɵ";
const SOURCE = "__source";
const ɵ0$1 = getClosureSafeProperty;
const USE_VALUE = getClosureSafeProperty({ provide: String, useValue: ɵ0$1 });
class NullInjector {
    get(token, notFoundValue = THROW_IF_NOT_FOUND) {
        if (notFoundValue === THROW_IF_NOT_FOUND) {
            const error = new Error(`NullInjectorError: No provider for ${stringify(token)}!`);
            error.name = "NullInjectorError";
            throw error;
        }
        return notFoundValue;
    }
}
function catchInjectorError(e, token, injectorErrorName, source) {
    const tokenPath = e[NG_TEMP_TOKEN_PATH];
    if (token[SOURCE]) {
        tokenPath.unshift(token[SOURCE]);
    }
    e.message = formatError(`\n${e.message}`, tokenPath, injectorErrorName, source);
    e[NG_TOKEN_PATH] = tokenPath;
    e[NG_TEMP_TOKEN_PATH] = null;
    throw e;
}
function formatError(text, obj, injectorErrorName, source = null) {
    text = text && text.charAt(0) === "\n" && text.charAt(1) === NO_NEW_LINE ? text.substr(2) : text;
    let context = stringify(obj);
    if (Array.isArray(obj)) {
        context = obj.map(stringify).join(" -> ");
    }
    else if (typeof obj === "object") {
        const parts = [];
        for (const key in obj) {
            if (obj.hasOwnProperty(key)) {
                const value = obj[key];
                parts.push(`${key}:${typeof value === "string" ? JSON.stringify(value) : stringify(value)}`);
            }
        }
        context = `{${parts.join(", ")}}`;
    }
    return `${injectorErrorName}${source ? `(${source})` : ""}[${context}]: ${text.replace(NEW_LINE, "\n  ")}`;
}

/* eslint-disable */
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * Injection flags for DI.
 *
 * @publicApi
 */
var InjectFlags;
(function (InjectFlags) {
    // TODO(alxhub): make this 'const' when ngc no longer writes exports of it into ngfactory files.
    /** Check self and check parent injector if needed */
    InjectFlags[InjectFlags["Default"] = 0] = "Default";
    /**
     * Specifies that an injector should retrieve a dependency from any injector until reaching the
     * host element of the current component. (Only used with Element Injector)
     */
    InjectFlags[InjectFlags["Host"] = 1] = "Host";
    /** Don't ascend to ancestors of the node requesting injection. */
    InjectFlags[InjectFlags["Self"] = 2] = "Self";
    /** Skip the node that is requesting injection. */
    InjectFlags[InjectFlags["SkipSelf"] = 4] = "SkipSelf";
    /** Inject `defaultValue` instead if token not found. */
    InjectFlags[InjectFlags["Optional"] = 8] = "Optional";
})(InjectFlags || (InjectFlags = {}));

/* eslint-disable */
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * Type of the Optional metadata.
 */
class Optional {
}
/**
 * Type of the Self metadata.
 */
class Self {
}
/**
 * Type of the SkipSelf metadata.
 */
class SkipSelf {
}
/**
 * Type of the Host metadata.
 */
class Host {
}

/* eslint-disable */
const INJECTOR_IMPL = (providers, parent, name) => new StaticInjector(providers, parent, name);
/**
 * Concrete injectors implement this interface. Injectors are configured
 * with [providers](guide/glossary#provider) that associate
 * dependencies of various types with [injection tokens](guide/glossary#di-token).
 *
 * @see ["DI Providers"](guide/dependency-injection-providers).
 * @see `StaticProvider`
 *
 * @usageNotes
 *
 *  The following example creates a service injector instance.
 *
 * {@example core/di/ts/provider_spec.ts region='ConstructorProvider'}
 *
 * ### Usage example
 *
 * {@example core/di/ts/injector_spec.ts region='Injector'}
 *
 * `Injector` returns itself when given `Injector` as a token:
 *
 * {@example core/di/ts/injector_spec.ts region='injectInjector'}
 *
 * @publicApi
 */
class Injector {
    static create(options, parent) {
        if (Array.isArray(options)) {
            return INJECTOR_IMPL(options, parent, "");
        }
        else {
            return INJECTOR_IMPL(options.providers, options.parent, options.name || "");
        }
    }
}
Injector.THROW_IF_NOT_FOUND = THROW_IF_NOT_FOUND;
Injector.NULL = new NullInjector();
/**
 * @internal
 * @nocollapse
 */
Injector.__NG_ELEMENT_ID__ = -1;
const IDENT = function (value) {
    return value;
};
const ɵ0 = IDENT;
const EMPTY = [];
const CIRCULAR = IDENT;
const MULTI_PROVIDER_FN = function () {
    return Array.prototype.slice.call(arguments);
};
const ɵ1 = MULTI_PROVIDER_FN;
class StaticInjector {
    constructor(providers, parent = new NullInjector(), source = null) {
        this.parent = parent;
        this.source = source;
        const records = this._records = new Map();
        records.set(Injector, { token: Injector, fn: IDENT, deps: EMPTY, value: this, useNew: false });
        records.set(INJECTOR, { token: INJECTOR, fn: IDENT, deps: EMPTY, value: this, useNew: false });
        this.scope = recursivelyProcessProviders(records, providers);
    }
    get(token, notFoundValue, flags = InjectFlags.Default) {
        const records = this._records;
        const record = records.get(token);
        if (record === undefined) {
            records.set(token, null);
        }
        try {
            return tryResolveToken(token, record, records, this.parent, notFoundValue, flags);
        }
        catch (e) {
            return catchInjectorError(e, token, "StaticInjectorError", this.source);
        }
    }
    toString() {
        const tokens = [];
        const records = this._records;
        records.forEach((v, token) => tokens.push(stringify(token)));
        return `StaticInjector[${tokens.join(", ")}]`;
    }
}
function resolveProvider(provider) {
    const deps = computeDeps(provider);
    let fn = IDENT;
    let value = EMPTY;
    let useNew = false;
    const provide = resolveForwardRef(provider.provide);
    if (USE_VALUE in provider) {
        // We need to use USE_VALUE in provider since provider.useValue could be defined as undefined.
        value = provider.useValue;
    }
    else if (provider.useFactory) {
        fn = provider.useFactory;
    }
    else if (provider.useExisting) {
        // Just use IDENT
    }
    else if (provider.useClass) {
        useNew = true;
        fn = resolveForwardRef(provider.useClass);
    }
    else if (typeof provide === "function") {
        useNew = true;
        fn = provide;
    }
    else {
        throw staticError("StaticProvider does not have [useValue|useFactory|useExisting|useClass] or [provide] is not newable", provider);
    }
    return { deps, fn, useNew, value };
}
function multiProviderMixError(token) {
    return staticError("Cannot mix multi providers and regular providers", token);
}
function recursivelyProcessProviders(records, provider) {
    let scope = null;
    if (provider) {
        provider = resolveForwardRef(provider);
        if (Array.isArray(provider)) {
            // if we have an array recurse into the array
            for (let i = 0; i < provider.length; i++) {
                scope = recursivelyProcessProviders(records, provider[i]) || scope;
            }
        }
        else if (typeof provider === "function") {
            // Functions were supported in ReflectiveInjector, but are not here. For safety give useful
            // error messages
            throw staticError("Function/Class not supported", provider);
        }
        else if (provider && typeof provider === "object" && provider.provide) {
            // At this point we have what looks like a provider: {provide: ?, ....}
            let token = resolveForwardRef(provider.provide);
            const resolvedProvider = resolveProvider(provider);
            if (provider.multi === true) {
                // This is a multi provider.
                let multiProvider = records.get(token);
                if (multiProvider) {
                    if (multiProvider.fn !== MULTI_PROVIDER_FN) {
                        throw multiProviderMixError(token);
                    }
                }
                else {
                    // Create a placeholder factory which will look up the constituents of the multi provider.
                    records.set(token, multiProvider = {
                        token: provider.provide,
                        deps: [],
                        useNew: false,
                        fn: MULTI_PROVIDER_FN,
                        value: EMPTY
                    });
                }
                // Treat the provider as the token.
                token = provider;
                multiProvider.deps.push({ token, options: 6 /* Default */ });
            }
            const record = records.get(token);
            if (record && record.fn === MULTI_PROVIDER_FN) {
                throw multiProviderMixError(token);
            }
            records.set(token, resolvedProvider);
        }
        else {
            throw staticError("Unexpected provider", provider);
        }
    }
    return scope;
}
function tryResolveToken(token, record, records, parent, notFoundValue, flags) {
    try {
        return resolveToken(token, record, records, parent, notFoundValue, flags);
    }
    catch (e) {
        // ensure that 'e' is of type Error.
        if (!(e instanceof Error)) {
            e = new Error(e);
        }
        const path = e[NG_TEMP_TOKEN_PATH] = e[NG_TEMP_TOKEN_PATH] || [];
        path.unshift(token);
        if (record && record.value === CIRCULAR) {
            // Reset the Circular flag.
            record.value = EMPTY;
        }
        throw e;
    }
}
function resolveToken(token, record, records, parent, notFoundValue, flags) {
    let value;
    // eslint-disable-next-line no-bitwise
    if (record && !(flags & InjectFlags.SkipSelf)) {
        // If we don't have a record, this implies that we don't own the provider hence don't know how
        // to resolve it.
        value = record.value;
        if (value === CIRCULAR) {
            throw Error(`${NO_NEW_LINE}Circular dependency`);
        }
        else if (value === EMPTY) {
            record.value = CIRCULAR;
            const { useNew, fn, deps: depRecords } = record;
            let deps = EMPTY;
            if (depRecords.length) {
                deps = [];
                for (let i = 0; i < depRecords.length; i++) {
                    const depRecord = depRecords[i];
                    const options = depRecord.options;
                    // eslint-disable-next-line no-bitwise
                    const childRecord = options & 2 /* CheckSelf */ ? records.get(depRecord.token) : undefined;
                    deps.push(tryResolveToken(
                    // Current Token to resolve
                    depRecord.token, 
                    // A record which describes how to resolve the token.
                    // If undefined, this means we don't have such a record
                    childRecord, 
                    // Other records we know about.
                    records, 
                    // If we don't know how to resolve dependency and we should not check parent for it,
                    // than pass in Null injector.
                    // eslint-disable-next-line no-bitwise
                    !childRecord && !(options & 4 /* CheckParent */) ? Injector.NULL : parent, 
                    // eslint-disable-next-line no-bitwise
                    options & 1 /* Optional */ ? null : Injector.THROW_IF_NOT_FOUND, InjectFlags.Default));
                }
            }
            record.value = value = useNew ? new fn(...deps) : fn.apply(undefined, deps);
        }
        // eslint-disable-next-line no-bitwise
    }
    else if (!(flags & InjectFlags.Self)) {
        value = parent.get(token, notFoundValue, InjectFlags.Default);
        // eslint-disable-next-line no-bitwise
    }
    else if (!(flags & InjectFlags.Optional)) {
        value = Injector.NULL.get(token, notFoundValue);
    }
    else {
        value = Injector.NULL.get(token, typeof notFoundValue !== "undefined" ? notFoundValue : null);
    }
    return value;
}
function computeDeps(provider) {
    let deps = EMPTY;
    const providerDeps = provider.deps;
    if (providerDeps && providerDeps.length) {
        deps = [];
        for (let i = 0; i < providerDeps.length; i++) {
            let options = 6 /* Default */;
            let token = resolveForwardRef(providerDeps[i]);
            if (Array.isArray(token)) {
                for (let j = 0, annotations = token; j < annotations.length; j++) {
                    const annotation = annotations[j];
                    if (annotation instanceof Optional || annotation === Optional) {
                        // eslint-disable-next-line no-bitwise
                        options = options | 1 /* Optional */;
                    }
                    else if (annotation instanceof SkipSelf || annotation === SkipSelf) {
                        // eslint-disable-next-line no-bitwise
                        options = options & ~2 /* CheckSelf */;
                    }
                    else if (annotation instanceof Self || annotation === Self) {
                        // eslint-disable-next-line no-bitwise
                        options = options & ~4 /* CheckParent */;
                    }
                    else {
                        token = resolveForwardRef(annotation);
                    }
                }
            }
            deps.push({ token, options });
        }
    }
    else if (provider.useExisting) {
        const token = resolveForwardRef(provider.useExisting);
        deps = [{ token, options: 6 /* Default */ }];
    }
    else if (!providerDeps && !(USE_VALUE in provider)) {
        // useValue & useExisting are the only ones which are exempt from deps all others need it.
        throw staticError("'deps' required", provider);
    }
    return deps;
}
function staticError(text, obj) {
    return new Error(formatError(text, obj, "StaticInjectorError"));
}

/**
 * Creates an angular based injector
 */
function injectorFactory(options, ...providers) {
    const { injectorConfig } = options;
    if (injectorConfig) {
        const resolved = injectorConfig.get(options, providers);
        return Injector.create({
            providers: resolved
        });
    }
    throw new Error("injectorConfig is not defined");
}

/**
 * @Hidden
 */
const MOCK = new InjectionToken("IMock");

/**
 * @hidden
 */
class SequenceId {
    constructor() {
        this.value = 0;
    }
    next() {
        return this.value++;
    }
}

/**
 * This class records all interactions with a mocked object.
 */
class Tracker {
    constructor(sequenceId) {
        this.sequenceId = sequenceId;
        this.log = [];
    }
    /**
     * @hidden
     */
    add(action) {
        const record = { id: this.sequenceId.next(), expression: action };
        this.log.push(record);
    }
    /**
     * Returns recorded interactions.
     */
    get() {
        return [...this.log];
    }
    interactions() {
        return this.get().map(record => record.expression);
    }
}

/**
 * @hidden
 */
var trackerProviders = [
    { provide: SequenceId, useClass: SequenceId, deps: [] },
    { provide: Tracker, useClass: Tracker, deps: [SequenceId] }
];

/**
 * Injection token for an expression reflector
 */
const EXPRESSION_REFLECTOR = new InjectionToken("Expression reflector");
/**
 * @hidden
 */
const EXPRESSIONS = new InjectionToken("reflected expressions");
/**
 * @hidden
 */
const GET_RETURN_VALUE = new InjectionToken("return value factory for the get trap");
/**
 * @hidden
 */
const APPLY_RETURN_VALUE = new InjectionToken("return value factory for the apply trap");
/**
 * @hidden
 */
const CONSTRUCT_RETURN_VALUE = new InjectionToken("return value factory for the construct trap");

class Expression {
    constructor(name, args) {
        this.name = name;
        this.args = args;
    }
}
/**
 * This class represents an invocation of an instance method.
 * It provides access to the name of it and the parameters.
 */
class MethodExpression extends Expression {
    constructor(name, args) {
        super(name, args);
    }
}
/**
 * This class represents an invocation of a function.
 * It provides access to the parameters.
 */
class FunctionExpression extends Expression {
    constructor(args) {
        super(undefined, args);
    }
}
/**
 * This class represents a property accessing.
 * It provides access to the name of property.
 */
class GetPropertyExpression extends Expression {
    constructor(name) {
        super(name, undefined);
    }
}
/**
 * This class represents a property write interaction.
 * It provides access to the name of property and the value.
 */
class SetPropertyExpression extends Expression {
    constructor(name, value) {
        super(name, [value]);
        this.value = value;
    }
}
/**
 * This class represents applying of [in operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/in).
 * It provides access to the name of property.
 */
class InOperatorExpression extends Expression {
    constructor(name) {
        super(name, undefined);
    }
}
/**
 * This class represents applying of [new operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new).
 * It provides access to the arguments of the constructor.
 */
class NewOperatorExpression extends Expression {
    constructor(args) {
        super(undefined, args);
    }
}

class GetReflectorTrap {
    constructor(returnValueFactory, expressions) {
        this.returnValueFactory = returnValueFactory;
        this.expressions = expressions;
        return this.factory();
    }
    factory() {
        return (target, name) => {
            this.expressions.push(new GetPropertyExpression(name));
            return this.returnValueFactory.create();
        };
    }
}

class SetReflectorTrap {
    constructor(expressions) {
        this.expressions = expressions;
        return this.factory();
    }
    factory() {
        return (target, name, value) => {
            this.expressions.push(new SetPropertyExpression(name, value));
            return true;
        };
    }
}

class ApplyReflectorTrap {
    constructor(returnValueFactory, expressions) {
        this.returnValueFactory = returnValueFactory;
        this.expressions = expressions;
        return this.factory();
    }
    factory() {
        return (target, thisArg, args) => {
            const last = this.expressions.pop();
            if (last instanceof GetPropertyExpression) {
                this.expressions.push(new MethodExpression(last.name, args));
            }
            else {
                if (last !== undefined) {
                    this.expressions.push(last);
                }
                this.expressions.push(new FunctionExpression(args));
            }
            return this.returnValueFactory.create();
        };
    }
}

class HasReflectorTrap {
    constructor(expressions) {
        this.expressions = expressions;
        return this.factory();
    }
    factory() {
        return (target, name) => {
            this.expressions.push(new InOperatorExpression(name));
            return true;
        };
    }
}

class ConstructReflectorTrap {
    constructor(returnValueFactory, expressions) {
        this.returnValueFactory = returnValueFactory;
        this.expressions = expressions;
        return this.factory();
    }
    factory() {
        return (target, args) => {
            this.expressions.push(new NewOperatorExpression(args));
            return this.returnValueFactory.create();
        };
    }
}

class ReflectingProxyFactory {
    constructor(injector) {
        this.injector = injector;
    }
    create() {
        const get = this.injector.get(GetReflectorTrap);
        const set = this.injector.get(SetReflectorTrap);
        const apply = this.injector.get(ApplyReflectorTrap);
        const has = this.injector.get(HasReflectorTrap);
        const construct = this.injector.get(ConstructReflectorTrap);
        const options = { get, set, apply, has, construct };
        const reflector = function () {
            return undefined;
        };
        return new Proxy(reflector, options);
    }
}

class ReflectingProxyInjectorFactory {
    create(options = { providers: [] }) {
        const providers = [
            { provide: EXPRESSIONS, useValue: [], deps: [] },
            { provide: ReflectingProxyFactory, useClass: ReflectingProxyFactory, deps: [Injector] },
            { provide: GetReflectorTrap, useClass: GetReflectorTrap, deps: [GET_RETURN_VALUE, EXPRESSIONS] },
            { provide: GET_RETURN_VALUE, useExisting: ReflectingProxyFactory, deps: [] },
            { provide: SetReflectorTrap, useClass: SetReflectorTrap, deps: [EXPRESSIONS] },
            { provide: ApplyReflectorTrap, useClass: ApplyReflectorTrap, deps: [APPLY_RETURN_VALUE, EXPRESSIONS] },
            { provide: APPLY_RETURN_VALUE, useExisting: ReflectingProxyFactory, deps: [] },
            { provide: HasReflectorTrap, useClass: HasReflectorTrap, deps: [EXPRESSIONS] },
            {
                provide: ConstructReflectorTrap,
                useClass: ConstructReflectorTrap,
                deps: [CONSTRUCT_RETURN_VALUE, EXPRESSIONS]
            },
            { provide: CONSTRUCT_RETURN_VALUE, useExisting: ReflectingProxyFactory, deps: [] },
            ...options.providers
        ];
        return Injector.create({ providers });
    }
}

/**
 * This class allows to express wide range of cases in an expression.
 * You can use it with setups or verifies methods.
 *
 * @example
 * ```typescript
 *
 *  const value = 'value';
 *  const object = new Mock<Function>()
 *  .setup(instance => instance(1))
 *  .returns(value)
 *  .setup(instance => instance(It.Is(param => param > 0 && param < 2))
 *  .returns(value)
 *  .setup(instance => instance(It.IsAny())
 *  .returns(value)
 *  .object();
 *
 *  const actual = object(1);
 *
 *  expect(actual).toBe(value);
 * ```
 *
 * This class could be used not only for args matching, but also for function names, property names and so on.
 *
 * @example
 * ```typescript
 *
 * const object = new Mock<ITestObject>()
 * // the expression dynamically checks the property name that is being read
 * .setup(instance => It.Is((expression: GetPropertyExpression) => expression.name === 'property'))
 * .returns(value)
 * .object();
 *
 * const object = new Mock<ITestObject>()
 * //denis any write operation on the property
 * .setup(instance => { instance.property = It.IsAny()})
 * // true - allow, false - deny
 * .returns(false)
 * .object();
 *
 * const object = new Mock<ITestObject>()
 * .setup(instance => It.Is((expression: NamedMethodExpression) => expression.name === 'methodName' && expression.args[0] === 1))
 * .returns(value)
 * .object();
 *
 * // how to use with verify
 * mock.verify(instance => instance.method(It.Is(a => a === 2)));
 * ```
 */
class It {
    constructor(predicate) {
        this.predicate = predicate;
    }
    /**
     * This factory method returns an expression that matches custom cases.
     *
     * @example
     * ```typescript
     *
     *  const value = 'value';
     *  const object = new Mock<Function>()
     *  .setup(instance => instance(It.Is(param => param > 0 && param < 2))
     *  .returns(value)
     *  .object();
     *
     *  const actual = object(only_values_between_0_and_2_will_trigger_the_setup);
     *
     *  expect(actual).toBe(value);
     * ```
     */
    static Is(predicate) {
        return new It(predicate);
    }
    /**
     * This factory method returns a wildcat expression that matches any value.
     *
     * @example
     * ```typescript
     *
     *  const value = 'value';
     *  const object = new Mock<Function>()
     *  .setup(instance => instance(It.IsAny())
     *  .returns(value)
     *  .object();
     *
     *  const actual = object(any_value_will_trigger_the_setup);
     *
     *  expect(actual).toBe(value);
     * ```
     */
    static IsAny() {
        return new It(It.isAnyPredicate);
    }
    /**
     * Exams if the instance matches the predicate.
     */
    test(instance) {
        try {
            const result = this.predicate(instance);
            return result === true || result === undefined;
        }
        catch (e) {
            return false;
        }
    }
}
It.isAnyPredicate = () => true;

var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
/**
 * This class reflects an expression to an expression tree representation.
 * async/await is not supported.
 *
 * For more examples check
 * [unit tests for this class]
 * (https://github.com/dvabuzyarov/moq.ts/blob/master/projects/moq/src/lib/reflector/full.expression-reflector.spec.ts)
 */
class SyncExpressionReflector {
    constructor(injectorFactory) {
        this.injectorFactory = injectorFactory;
    }
    /**
     * Reflects the provided code as an expression tree.
     */
    reflect(expression) {
        if (expression instanceof It) {
            return [expression];
        }
        const injector = this.injectorFactory.create();
        const proxyFactory = injector.get(ReflectingProxyFactory);
        const proxy = proxyFactory.create();
        const predicate = expression(proxy);
        const expressions = injector.get(EXPRESSIONS);
        return predicate instanceof It && expressions.length === 0
            ? [predicate] : expressions;
    }
    reflectAsync(expression) {
        return __awaiter(this, void 0, void 0, function* () {
            if (expression instanceof It) {
                return [expression];
            }
            const injector = this.injectorFactory.create();
            const proxyFactory = injector.get(ReflectingProxyFactory);
            const proxy = proxyFactory.create();
            const predicate = yield expression(proxy);
            const expressions = injector.get(EXPRESSIONS);
            return predicate instanceof It && expressions.length === 0
                ? [predicate] : expressions;
        });
    }
}

/**
 * This class reflects an expression to an expression tree representation.
 * async/await expressions are reflected in shellow mode.
 *
 * For more examples check
 * [unit tests for this class]
 * (https://github.com/dvabuzyarov/moq.ts/blob/master/projects/moq/src/lib/reflector/full.expression-reflector.spec.ts)
 */
class CompositeExpressionReflector {
    constructor(asyncExpressionDetector, syncExpressionReflector, asyncExpressionReflector) {
        this.asyncExpressionDetector = asyncExpressionDetector;
        this.syncExpressionReflector = syncExpressionReflector;
        this.asyncExpressionReflector = asyncExpressionReflector;
    }
    /**
     * Reflects the provided code as an expression tree.
     */
    reflect(expression) {
        return this.asyncExpressionDetector.isAsync(expression)
            ? this.asyncExpressionReflector.reflect(expression)
            : this.syncExpressionReflector.reflect(expression);
    }
}

class AsyncExpressionDetector {
    isAsync(expression) {
        if (expression instanceof It) {
            return false;
        }
        const get = () => proxy;
        const set = () => true;
        const apply = () => proxy;
        const has = () => false;
        const construct = () => proxy;
        const options = { get, set, apply, has, construct };
        const reflector = function () {
            return undefined;
        };
        const proxy = new Proxy(reflector, options);
        const predicate = expression(proxy);
        return predicate instanceof It ? false : predicate instanceof Promise;
    }
}

/**
 * This class reflects an async expression to an expression tree representation.
 * For more examples check
 * [unit tests for this class]
 * (https://github.com/dvabuzyarov/moq.ts/blob/master/projects/moq/src/lib/reflector/async.expression-reflector.spec.ts)
 */
class AsyncExpressionReflector {
    constructor(injectorFactory) {
        this.injectorFactory = injectorFactory;
    }
    /**
     * Reflects the provided async code as an expression tree.
     */
    reflect(expression) {
        const injector = this.injectorFactory.create();
        const proxyFactory = injector.get(ReflectingProxyFactory);
        const proxy = proxyFactory.create();
        expression(proxy);
        return injector.get(EXPRESSIONS);
    }
}

class MethodReflectorTrap {
    constructor(expressions) {
        this.expressions = expressions;
        return this.factory();
    }
    factory() {
        return (target, thisArg, args) => {
            const last = this.expressions.pop();
            if (last instanceof GetPropertyExpression) {
                this.expressions.push(new MethodExpression(last.name, args));
            }
            else {
                if (last !== undefined) {
                    this.expressions.push(last);
                }
            }
            return undefined;
        };
    }
}

class MethodOnlyReflectingProxyFactory {
    constructor(injector) {
        this.injector = injector;
    }
    create() {
        const apply = this.injector.get(MethodReflectorTrap);
        const options = { apply };
        const reflector = function () {
            return undefined;
        };
        return new Proxy(reflector, options);
    }
}

class AsyncReflectingProxyInjectorFactory {
    constructor(reflectingProxyInjectorFactory) {
        this.reflectingProxyInjectorFactory = reflectingProxyInjectorFactory;
    }
    create(options = { providers: [] }) {
        const providers = [
            { provide: GET_RETURN_VALUE, useExisting: MethodOnlyReflectingProxyFactory, deps: [] },
            { provide: MethodOnlyReflectingProxyFactory, useClass: MethodOnlyReflectingProxyFactory, deps: [Injector] },
            { provide: APPLY_RETURN_VALUE, useValue: { create: () => ({}) }, deps: [] },
            { provide: CONSTRUCT_RETURN_VALUE, useValue: { create: () => ({}) }, deps: [] },
            { provide: MethodReflectorTrap, useClass: MethodReflectorTrap, deps: [EXPRESSIONS] },
            ...options.providers,
        ];
        return this.reflectingProxyInjectorFactory.create({ providers });
    }
}

/**
 * @hidden
 */
var reflectorProviders = [
    { provide: EXPRESSION_REFLECTOR, useExisting: CompositeExpressionReflector, deps: [] },
    {
        provide: CompositeExpressionReflector,
        useClass: CompositeExpressionReflector,
        deps: [AsyncExpressionDetector, SyncExpressionReflector, AsyncExpressionReflector]
    },
    { provide: AsyncExpressionDetector, useClass: AsyncExpressionDetector, deps: [] },
    { provide: ReflectingProxyInjectorFactory, useClass: ReflectingProxyInjectorFactory, deps: [] },
    { provide: SyncExpressionReflector, useClass: SyncExpressionReflector, deps: [ReflectingProxyInjectorFactory] },
    {
        provide: AsyncReflectingProxyInjectorFactory,
        useClass: AsyncReflectingProxyInjectorFactory,
        deps: [ReflectingProxyInjectorFactory]
    },
    {
        provide: AsyncExpressionReflector,
        useClass: AsyncExpressionReflector,
        deps: [AsyncReflectingProxyInjectorFactory]
    },
];

/**
 * @hidden
 */
class Presets {
    constructor() {
        this.presets = [];
    }
    add(preset) {
        this.presets.unshift(preset);
    }
    get() {
        return [...this.presets];
    }
}

/**
 * The configured setup will be applied to invocations exactly n-times. After that it will be ignored.
 */
class PlayableExactly {
    constructor(count) {
        this.count = count;
        this.invoked = 0;
        this.update = (reason) => {
            if (reason === 0 /* OwnSetupWouldBePlayed */) {
                this.invoked++;
            }
        };
        this.isPlayable = () => this.invoked < this.count;
    }
}

/**
 * The configured setup will be never applied to invocations.
 */
class PlayableNever {
    constructor() {
        this.update = () => undefined;
        this.isPlayable = () => false;
    }
}

/**
 * The configured setup will be applied only to the first invocation.
 */
class PlayableOnce {
    constructor() {
        this.played = false;
        this.update = (reason) => {
            if (reason === 0 /* OwnSetupWouldBePlayed */) {
                this.played = true;
            }
        };
        this.isPlayable = () => this.played === false;
    }
}

/**
 * The configured setup will be always applied to invocations.
 */
class PlayableAlways {
    constructor() {
        this.isPlayable = () => true;
        this.update = () => undefined;
    }
}

/**
 * The configured setup will be applied or not accordingly to the value in the sequence.
 *
 * @example
 * ```typescript
 *
 * const value = 'value';
 * const object = new Mock<Function>()
 * .setup(instance => instance(1))
 * .play(PlayTimes.Sequence([false, true]))
 * .returns(value)
 * .object();
 *
 * expect(object(1).toBe(undefined);
 * expect(object(1).toBe(value);
 * expect(object(1).toBe(undefined);
 * ```
 */
class PlayableSequence {
    constructor(sequence) {
        this.sequence = sequence;
        this.index = 0;
        this.update = () => {
            this.index++;
        };
        this.isPlayable = () => {
            if (this.index >= this.sequence.length)
                return false;
            return this.sequence[this.index];
        };
    }
}

/**
 * This class sets rules when a configured setup should be applied to the target invocation or not.
 *
 * @example
 * ```typescript
 *
 * const value = 'value';
 * const object = new Mock<Function>()
 * .setup(instance => instance(1))
 * .play(PlayTimes.Once())
 * .returns(value)
 * .object();
 *
 * expect(object(1).toBe(value);
 * expect(object(1).toBe(undefined);
 * ```
 */
class PlayTimes {
    /**
     * The configured setup will be applied to invocations exactly n-times. After that it will be ignored.
     */
    static Exactly(count) {
        return new PlayableExactly(count);
    }
    /**
     * The configured setup will be always applied to invocations.
     */
    static Always() {
        return PlayTimes.always;
    }
    /**
     * The configured setup will be never applied to invocations.
     */
    static Never() {
        return PlayTimes.never;
    }
    /**
     * The configured setup will be applied only to the first invocation.
     */
    static Once() {
        return new PlayableOnce();
    }
    /**
     * The configured setup will be applied or not accordingly to the value in the sequence.
     *
     * @example
     * ```typescript
     *
     * const value = 'value';
     * const object = new Mock<Function>()
     * .setup(instance => instance(1))
     * .play(PlayTimes.Sequence([false, true]))
     * .returns(value)
     * .object();
     *
     * expect(object(1).toBe(undefined);
     * expect(object(1).toBe(value);
     * expect(object(1).toBe(undefined);
     * ```
     */
    static Sequence(sequence) {
        return new PlayableSequence(sequence);
    }
}
PlayTimes.always = new PlayableAlways();
PlayTimes.never = new PlayableNever();

/**
 * The default implementation of {@link IPresetBuilder} interface.
 * Is it not intended to be used outside of the moq library.
 *
 * @hidden
 */
class PresetBuilder {
    constructor(returnsPresetFactory, throwsPresetFactory, mimicsPresetFactory, callbackPresetFactory, returnsAsyncPresetFactory, throwsAsyncPresetFactory, target, playable = PlayTimes.Always()) {
        this.returnsPresetFactory = returnsPresetFactory;
        this.throwsPresetFactory = throwsPresetFactory;
        this.mimicsPresetFactory = mimicsPresetFactory;
        this.callbackPresetFactory = callbackPresetFactory;
        this.returnsAsyncPresetFactory = returnsAsyncPresetFactory;
        this.throwsAsyncPresetFactory = throwsAsyncPresetFactory;
        this.target = target;
        this.playable = playable;
    }
    returnsAsync(value) {
        return this.returnsAsyncPresetFactory(this.target, this.playable, value);
    }
    throwsAsync(exception) {
        return this.throwsAsyncPresetFactory(this.target, this.playable, exception);
    }
    mimics(origin) {
        return this.mimicsPresetFactory(this.target, this.playable, origin);
    }
    returns(value) {
        return this.returnsPresetFactory(this.target, this.playable, value);
    }
    throws(exception) {
        return this.throwsPresetFactory(this.target, this.playable, exception);
    }
    callback(callback) {
        return this.callbackPresetFactory(this.target, this.playable, callback);
    }
    play(playable) {
        this.playable = playable;
        return this;
    }
}

/**
 * @hidden
 */
class PresetBuilderFactory {
    constructor(returnsPresetFactory, throwsPresetFactory, mimicsPresetFactory, callbackPresetFactory, returnsAsyncPresetFactory, throwsAsyncPresetFactory) {
        this.returnsPresetFactory = returnsPresetFactory;
        this.throwsPresetFactory = throwsPresetFactory;
        this.mimicsPresetFactory = mimicsPresetFactory;
        this.callbackPresetFactory = callbackPresetFactory;
        this.returnsAsyncPresetFactory = returnsAsyncPresetFactory;
        this.throwsAsyncPresetFactory = throwsAsyncPresetFactory;
        return this.factory();
    }
    factory() {
        return (target) => new PresetBuilder(this.returnsPresetFactory, this.throwsPresetFactory, this.mimicsPresetFactory, this.callbackPresetFactory, this.returnsAsyncPresetFactory, this.throwsAsyncPresetFactory, target);
    }
}

/**
 * @Hidden
 */
class SetupFactory {
    constructor(presetBuilderFactory, autoMockProvider, expressionGuard) {
        this.presetBuilderFactory = presetBuilderFactory;
        this.autoMockProvider = autoMockProvider;
        this.expressionGuard = expressionGuard;
    }
    create([shallow, ...rest]) {
        this.expressionGuard.verify([shallow, ...rest]);
        const preset = this.presetBuilderFactory(shallow);
        if (rest.length === 0) {
            return preset;
        }
        const mock = this.autoMockProvider.getOrCreate(shallow);
        preset.returns(mock.object());
        const setup = mock.resolve(SetupFactory);
        return setup.create(rest);
    }
}

/**
 * @hidden
 */
class RootMockProvider {
    constructor(mock, root) {
        this.mock = mock;
        this.root = root;
        return this.factory();
    }
    factory() {
        var _a;
        return (_a = this.root) !== null && _a !== void 0 ? _a : this.mock;
    }
}

/**
 * @hidden
 */
class AutoMockProvider {
    constructor(map, comparer, autoMockFactory) {
        this.map = map;
        this.comparer = comparer;
        this.autoMockFactory = autoMockFactory;
    }
    getOrCreate(expression) {
        for (const [key, value] of this.map) {
            if (this.comparer.equals(expression, key) === true) {
                return value;
            }
        }
        const mock = this.autoMockFactory.create(expression);
        this.map.set(expression, mock);
        return mock;
    }
}

class CallbacksPreset {
    constructor(playable, target, callback) {
        this.playable = playable;
        this.target = target;
        this.callback = callback;
    }
}

/**
 * @Hidden
 */
class CallbackPresetFactory {
    constructor(rootMock, presets) {
        this.rootMock = rootMock;
        this.presets = presets;
        return this.factory();
    }
    factory() {
        return (target, playable, callback) => {
            const preset = new CallbacksPreset(playable, target, callback);
            this.presets.add(preset);
            return this.rootMock;
        };
    }
}

class MimicsPreset {
    constructor(playable, target, origin) {
        this.playable = playable;
        this.target = target;
        this.origin = origin;
    }
}

/**
 * @Hidden
 */
class MimicsPresetFactory {
    constructor(rootMock, presets) {
        this.rootMock = rootMock;
        this.presets = presets;
        return this.factory();
    }
    factory() {
        return (target, playable, origin) => {
            const preset = new MimicsPreset(playable, target, origin);
            this.presets.add(preset);
            return this.rootMock;
        };
    }
}

class ReturnsPreset {
    constructor(playable, target, value) {
        this.playable = playable;
        this.target = target;
        this.value = value;
    }
}

/**
 * @Hidden
 */
class ReturnsAsyncPresetFactory {
    constructor(rootMock, presets, resolvedPromise) {
        this.rootMock = rootMock;
        this.presets = presets;
        this.resolvedPromise = resolvedPromise;
        return this.factory();
    }
    factory() {
        return (target, playable, value) => {
            const preset = new ReturnsPreset(playable, target, this.resolvedPromise(value));
            this.presets.add(preset);
            return this.rootMock;
        };
    }
}

/**
 * @Hidden
 */
class ReturnsPresetFactory {
    constructor(rootMock, presets) {
        this.rootMock = rootMock;
        this.presets = presets;
        return this.factory();
    }
    factory() {
        return (target, playable, value) => {
            const preset = new ReturnsPreset(playable, target, value);
            this.presets.add(preset);
            return this.rootMock;
        };
    }
}

/**
 * @Hidden
 */
class ThrowsAsyncPresetFactory {
    constructor(rootMock, presets, rejectedPromise) {
        this.rootMock = rootMock;
        this.presets = presets;
        this.rejectedPromise = rejectedPromise;
        return this.factory();
    }
    factory() {
        return (target, playable, exception) => {
            const preset = new ReturnsPreset(playable, target, this.rejectedPromise(exception));
            this.presets.add(preset);
            return this.rootMock;
        };
    }
}

class ThrowsPreset {
    constructor(playable, target, exception) {
        this.playable = playable;
        this.target = target;
        this.exception = exception;
    }
}

/**
 * @Hidden
 */
class ThrowsPresetFactory {
    constructor(rootMock, presets) {
        this.rootMock = rootMock;
        this.presets = presets;
        return this.factory();
    }
    factory() {
        return (target, playable, exception) => {
            const preset = new ThrowsPreset(playable, target, exception);
            this.presets.add(preset);
            return this.rootMock;
        };
    }
}

/**
 * This service is an adapter for a resolved promise.
 */
class ResolvedPromiseFactory {
    constructor() {
        return this.factory();
    }
    factory() {
        return (value) => {
            const promise = Promise.resolve(value);
            promise.then = promise.then.bind(promise);
            promise.catch = promise.catch.bind(promise);
            promise.finally = promise.finally.bind(promise);
            return promise;
        };
    }
}

/**
 * This service is an adapter for a rejected promise.
 */
class RejectedPromiseFactory {
    constructor() {
        return this.factory();
    }
    factory() {
        return (value) => {
            const promise = Promise.reject(value);
            promise.then = promise.then.bind(promise);
            promise.catch = promise.catch.bind(promise);
            promise.finally = promise.finally.bind(promise);
            return promise;
        };
    }
}

class ComplexExpressionGuard {
    constructor(complexExpressionValidator, expressionGuardExceptionFactory) {
        this.complexExpressionValidator = complexExpressionValidator;
        this.expressionGuardExceptionFactory = expressionGuardExceptionFactory;
    }
    verify(expressions) {
        const { valid, errors } = this.complexExpressionValidator.validate(expressions);
        if (valid === false) {
            throw this.expressionGuardExceptionFactory.create(errors);
        }
    }
}

/**
 * @hidden
 */
var presetsProviders = [
    {
        provide: SetupFactory,
        useClass: SetupFactory,
        deps: [PresetBuilderFactory, AutoMockProvider, ComplexExpressionGuard]
    },
    { provide: Presets, useClass: Presets, deps: [] },
    { provide: ResolvedPromiseFactory, useClass: ResolvedPromiseFactory, deps: [] },
    { provide: RejectedPromiseFactory, useClass: RejectedPromiseFactory, deps: [] },
    { provide: ReturnsPresetFactory, useClass: ReturnsPresetFactory, deps: [RootMockProvider, Presets] },
    { provide: ThrowsPresetFactory, useClass: ThrowsPresetFactory, deps: [RootMockProvider, Presets] },
    { provide: CallbackPresetFactory, useClass: CallbackPresetFactory, deps: [RootMockProvider, Presets] },
    { provide: MimicsPresetFactory, useClass: MimicsPresetFactory, deps: [RootMockProvider, Presets] },
    {
        provide: ReturnsAsyncPresetFactory,
        useClass: ReturnsAsyncPresetFactory,
        deps: [RootMockProvider, Presets, ResolvedPromiseFactory]
    },
    {
        provide: ThrowsAsyncPresetFactory,
        useClass: ThrowsAsyncPresetFactory,
        deps: [RootMockProvider, Presets, RejectedPromiseFactory]
    },
    {
        provide: PresetBuilderFactory, useClass: PresetBuilderFactory, deps: [
            ReturnsPresetFactory,
            ThrowsPresetFactory,
            MimicsPresetFactory,
            CallbackPresetFactory,
            ReturnsAsyncPresetFactory,
            ThrowsAsyncPresetFactory
        ]
    },
];

/**
 * @hidden
 */
class Verifier {
    constructor(callCounter, verificationTester, autoMockProvider) {
        this.callCounter = callCounter;
        this.verificationTester = verificationTester;
        this.autoMockProvider = autoMockProvider;
    }
    test([shallow, ...rest], times) {
        const callCount = this.callCounter.count(shallow);
        if (rest.length === 0) {
            this.verificationTester.test(shallow, callCount, times);
        }
        else {
            this.verificationTester.test(shallow, callCount, Times.AtLeastOnce());
            const autoMock = this.autoMockProvider.getOrCreate(shallow);
            const verifier = autoMock.resolve(Verifier);
            verifier.test(rest, times);
        }
    }
}

/**
 * @hidden
 */
class CallCounter {
    constructor(comparer, tracker) {
        this.comparer = comparer;
        this.tracker = tracker;
    }
    count(expected) {
        let count = 0;
        for (const expression of this.tracker.interactions()) {
            if (this.comparer.equals(expression, expected) === true) {
                count += 1;
            }
        }
        return count;
    }
}

/**
 * @hidden
 */
class VerifyFormatter {
    constructor(expressionsFormatter, trackedExpressionsFormatter, tracker) {
        this.expressionsFormatter = expressionsFormatter;
        this.trackedExpressionsFormatter = trackedExpressionsFormatter;
        this.tracker = tracker;
    }
    format(expected, timesMessage, haveBeenCalledTimes) {
        const interactions = this.tracker.interactions();
        const expectedExpressionMessage = this.expressionsFormatter.format(expected, timesMessage, haveBeenCalledTimes);
        const trackedExpressionsMessage = this.trackedExpressionsFormatter.format(interactions);
        const delimiter = "-------------------------------------";
        return `${expectedExpressionMessage}\n${delimiter}\nTracked calls:\n${trackedExpressionsMessage}\n${delimiter}\n`;
    }
}

class VerifyError extends Error {
    constructor(message) {
        super(message);
    }
}

/**
 * @hidden
 */
class VerificationTester {
    constructor(verifyFormatter) {
        this.verifyFormatter = verifyFormatter;
    }
    test(expression, callCount, times) {
        const passed = times.test(callCount);
        if (passed === false) {
            const message = this.verifyFormatter.format(expression, times.message, callCount);
            throw new VerifyError(message);
        }
    }
}

/**
 * @hidden
 */
class ExpressionEqualityComparer {
    constructor(getPropertyExpressionMatcher, setPropertyExpressionMatcher, methodExpressionMatcher, namedMethodExpressionMatcher, inOperatorExpressionMatcher, newOperatorExpressionMatcher, itEqualityComparer) {
        this.getPropertyExpressionMatcher = getPropertyExpressionMatcher;
        this.setPropertyExpressionMatcher = setPropertyExpressionMatcher;
        this.methodExpressionMatcher = methodExpressionMatcher;
        this.namedMethodExpressionMatcher = namedMethodExpressionMatcher;
        this.inOperatorExpressionMatcher = inOperatorExpressionMatcher;
        this.newOperatorExpressionMatcher = newOperatorExpressionMatcher;
        this.itEqualityComparer = itEqualityComparer;
    }
    equals(left, right) {
        if (left === right)
            return true;
        if (left instanceof It || right instanceof It) {
            return this.itEqualityComparer.equals(left, right);
        }
        if (left instanceof GetPropertyExpression && right instanceof GetPropertyExpression) {
            return this.getPropertyExpressionMatcher.equals(left, right);
        }
        if (left instanceof SetPropertyExpression && right instanceof SetPropertyExpression) {
            return this.setPropertyExpressionMatcher.equals(left, right);
        }
        if (left instanceof InOperatorExpression && right instanceof InOperatorExpression) {
            return this.inOperatorExpressionMatcher.equals(left, right);
        }
        if (left instanceof FunctionExpression && right instanceof FunctionExpression) {
            return this.methodExpressionMatcher.equals(left, right);
        }
        if (left instanceof MethodExpression && right instanceof MethodExpression) {
            return this.namedMethodExpressionMatcher.equals(left, right);
        }
        if (left instanceof NewOperatorExpression && right instanceof NewOperatorExpression) {
            return this.newOperatorExpressionMatcher.equals(left, right);
        }
        return false;
    }
}

/**
 * @hidden
 */
var verificationProviders = [
    { provide: Verifier, useClass: Verifier, deps: [CallCounter, VerificationTester, AutoMockProvider] },
    { provide: CallCounter, useClass: CallCounter, deps: [ExpressionEqualityComparer, Tracker] },
    { provide: VerificationTester, useClass: VerificationTester, deps: [VerifyFormatter] },
];

/**
 * @hidden
 */
class ApplyTrap {
    constructor(tracker, interactionPlayer) {
        this.tracker = tracker;
        this.interactionPlayer = interactionPlayer;
    }
    intercept(target, thisArg, argArray) {
        const expression = new FunctionExpression(argArray);
        this.tracker.add(expression);
        return this.interactionPlayer.play(expression);
    }
}

/**
 * @hidden
 */
class InteractionPlayer {
    constructor(playablePresetProvider, presetPlayablesUpdater, presetPlayer) {
        this.playablePresetProvider = playablePresetProvider;
        this.presetPlayablesUpdater = presetPlayablesUpdater;
        this.presetPlayer = presetPlayer;
    }
    play(interaction) {
        const preset = this.playablePresetProvider.get(interaction);
        this.presetPlayablesUpdater.update(interaction, preset);
        if (preset === undefined)
            return undefined;
        return this.presetPlayer.play(preset, interaction);
    }
}

/**
 * A mock object exposes a symbol property to access to its Moq API.
 * This property is read only and trackable.
 * Since this property makes sense only in context of the moq library
 * and is not specific for mocked types it is not possible to define an interaction behaviour with Setup API.
 *
 * @example
 * ```typescript
 *
 *  const mock = new Mock<() => void>()
 *  .object();
 *
 *  mock[MoqAPI]
 *  .setup(instance => instance())
 *  .returns(12);
 *
 *  const actual = mock();
 *
 *  expect(actual).toBe(12);
 * ```
 */
const MoqAPI = Symbol("MoqAPI");

/**
 * @hidden
 */
class GetTrap {
    constructor(mock, tracker, propertiesValueStorage, interactionPlayer, hasPropertyExplorer, hasMethodExplorer, spyFunctionProvider) {
        this.mock = mock;
        this.tracker = tracker;
        this.propertiesValueStorage = propertiesValueStorage;
        this.interactionPlayer = interactionPlayer;
        this.hasPropertyExplorer = hasPropertyExplorer;
        this.hasMethodExplorer = hasMethodExplorer;
        this.spyFunctionProvider = spyFunctionProvider;
    }
    intercept(property) {
        const interaction = new GetPropertyExpression(property);
        this.tracker.add(interaction);
        if (property === MoqAPI) {
            return this.mock;
        }
        if (this.propertiesValueStorage.has(property)) {
            return this.propertiesValueStorage.get(property);
        }
        if (this.hasPropertyExplorer.has(property)) {
            return this.interactionPlayer.play(interaction);
        }
        if (this.hasMethodExplorer.has(property)) {
            return this.spyFunctionProvider.get(property);
        }
        return this.interactionPlayer.play(interaction);
    }
}

class PropertiesValueStorage {
    constructor() {
        this.storage = new Map();
    }
    has(property) {
        return this.storage.has(property);
    }
    get(property) {
        return this.storage.get(property);
    }
    set(property, value) {
        this.storage.set(property, value);
    }
}

/**
 * @hidden
 */
class HasPropertyExplorer {
    constructor(presets, membersExplorer, explorer) {
        this.presets = presets;
        this.membersExplorer = membersExplorer;
        this.explorer = explorer;
    }
    has(name) {
        if (this.membersExplorer.hasProperty(name)) {
            return true;
        }
        return this.presets
            .get()
            .find(preset => this.explorer.has(name, preset)) !== undefined;
    }
}

/**
 * @hidden
 */
class HasMethodExplorer {
    constructor(presets, membersExplorer, explorer) {
        this.presets = presets;
        this.membersExplorer = membersExplorer;
        this.explorer = explorer;
    }
    has(name) {
        if (this.membersExplorer.hasMethod(name)) {
            return true;
        }
        return this.presets
            .get()
            .find(preset => this.explorer.has(name, preset)) !== undefined;
    }
}

/**
 * @hidden
 */
class SpyFunctionProvider {
    constructor(tracker, interactionPlayer) {
        this.tracker = tracker;
        this.interactionPlayer = interactionPlayer;
        this.map = new Map();
    }
    get(property) {
        if (this.map.has(property) === false) {
            this.map.set(property, (...args) => {
                const interaction = new MethodExpression(property, args);
                this.tracker.add(interaction);
                return this.interactionPlayer.play(interaction);
            });
        }
        return this.map.get(property);
    }
}

/**
 * @hidden
 */
class GetPrototypeOfTrap {
    constructor(prototypeStorage) {
        this.prototypeStorage = prototypeStorage;
    }
    intercept() {
        return this.prototypeStorage.get();
    }
}

/**
 * @hidden
 */
class PrototypeStorage {
    constructor(mockTarget) {
        var _a;
        this.prototype = null;
        this.prototype = (_a = mockTarget === null || mockTarget === void 0 ? void 0 : mockTarget.prototype) !== null && _a !== void 0 ? _a : mockTarget;
    }
    get() {
        return this.prototype;
    }
    set(prototype) {
        this.prototype = prototype;
    }
}

/**
 * @hidden
 */
class HasTrap {
    constructor(tracker, propertiesValueStorage, interactionPlayer, inOperatorInteractionExplorer, hasPropertyExplorer, hasMethodExplorer, presetPlayablesUpdater) {
        this.tracker = tracker;
        this.propertiesValueStorage = propertiesValueStorage;
        this.interactionPlayer = interactionPlayer;
        this.inOperatorInteractionExplorer = inOperatorInteractionExplorer;
        this.hasPropertyExplorer = hasPropertyExplorer;
        this.hasMethodExplorer = hasMethodExplorer;
        this.presetPlayablesUpdater = presetPlayablesUpdater;
    }
    intercept(property) {
        const interaction = new InOperatorExpression(property);
        this.tracker.add(interaction);
        if (this.propertiesValueStorage.has(property)) {
            return true;
        }
        if (this.inOperatorInteractionExplorer.has(property)) {
            return this.interactionPlayer.play(interaction);
        }
        this.presetPlayablesUpdater.update(interaction, undefined);
        if (this.hasPropertyExplorer.has(property)) {
            return true;
        }
        if (this.hasMethodExplorer.has(property)) {
            return true;
        }
        return false;
    }
}

/**
 * @hidden
 */
class InOperatorInteractionExplorer {
    constructor(presets, explorer) {
        this.presets = presets;
        this.explorer = explorer;
    }
    has(name) {
        return this.presets
            .get()
            .find(preset => this.explorer.has(name, preset)) !== undefined;
    }
}

/**
 * @hidden
 */
class PresetPlayablesUpdater {
    constructor(presets, matcher) {
        this.presets = presets;
        this.matcher = matcher;
    }
    update(interaction, playable) {
        for (const preset of this.presets.get()) {
            const { target, playable: { update } } = preset;
            if (this.matcher.equals(interaction, target)) {
                const reason = preset === playable ?
                    0 /* OwnSetupWouldBePlayed */ :
                    1 /* OtherSetupWouldBePlayed */;
                update(reason);
            }
        }
    }
}

/**
 * @hidden
 */
class SetTrap {
    constructor(tracker, propertiesValueStorage, interactionPlayer, propertyIsReadOnlyTester) {
        this.tracker = tracker;
        this.propertiesValueStorage = propertiesValueStorage;
        this.interactionPlayer = interactionPlayer;
        this.propertyIsReadOnlyTester = propertyIsReadOnlyTester;
    }
    intercept(target, property, value) {
        const expression = new SetPropertyExpression(property, value);
        this.tracker.add(expression);
        if (property === MoqAPI) {
            return false;
        }
        if (this.propertyIsReadOnlyTester.isReadOnly(property) === true) {
            return false;
        }
        const accepted = this.interactionPlayer.play(expression);
        if (accepted === true || accepted === undefined) {
            this.propertiesValueStorage.set(property, value);
        }
        return accepted === undefined ? true : accepted;
    }
}

/**
 * @hidden
 */
class SetPrototypeOfTrap {
    constructor(prototypeStorage) {
        this.prototypeStorage = prototypeStorage;
    }
    intercept(prototype) {
        if (prototype !== undefined) {
            this.prototypeStorage.set(prototype);
            return true;
        }
        return false;
    }
}

/**
 * @hidden
 */
class ProxyFactory {
    constructor(options, getTrap, setTrap, hasTrap, applyTrap, getPrototypeOfTrap, setPrototypeOfTrap, constructTrap) {
        this.options = options;
        this.getTrap = getTrap;
        this.setTrap = setTrap;
        this.hasTrap = hasTrap;
        this.applyTrap = applyTrap;
        this.getPrototypeOfTrap = getPrototypeOfTrap;
        this.setPrototypeOfTrap = setPrototypeOfTrap;
        this.constructTrap = constructTrap;
    }
    object() {
        if (this._proxy === undefined) {
            this._proxy = this.createObject();
        }
        return this._proxy;
    }
    createObject() {
        const options = {
            get: (target, name) => this.getTrap.intercept(name),
            set: (target, name, value) => this.setTrap.intercept(target, name, value),
            has: (target, name) => this.hasTrap.intercept(name),
            apply: (target, thisArg, args) => this.applyTrap.intercept(target, thisArg, args),
            getPrototypeOf: () => this.getPrototypeOfTrap.intercept(),
            setPrototypeOf: (target, prototype) => this.setPrototypeOfTrap.intercept(prototype),
            construct: (target, args) => this.constructTrap.intercept(args)
        };
        if (this.options.name) {
            options["mockName"] = this.options.name;
        }
        return new Proxy(this.options.target, options);
    }
}

/**
 * @hidden
 */
const MOCK_OPTIONS = new InjectionToken("mock options");

/**
 * @hidden
 */
class PropertyIsReadOnlyTester {
    constructor(storage, propertyDescriptorProvider, has) {
        this.storage = storage;
        this.propertyDescriptorProvider = propertyDescriptorProvider;
        this.has = has;
    }
    isReadOnly(name) {
        const prototype = this.storage.get();
        if (prototype && this.has(prototype, name)) {
            const descriptor = this.propertyDescriptorProvider.get(prototype, name);
            return descriptor.get instanceof Function && descriptor.set === undefined || descriptor.writable === false;
        }
        return false;
    }
}

/**
 * @hidden
 */
class ConstructTrap {
    constructor(tracker, interactionPlayer) {
        this.tracker = tracker;
        this.interactionPlayer = interactionPlayer;
    }
    intercept(args) {
        const interaction = new NewOperatorExpression(args);
        this.tracker.add(interaction);
        return this.interactionPlayer.play(interaction);
    }
}

/**
 * @hidden
 */
var interceptorsProviders = [
    {
        provide: ProxyFactory, useClass: ProxyFactory, deps: [
            MOCK_OPTIONS,
            GetTrap,
            SetTrap,
            HasTrap,
            ApplyTrap,
            GetPrototypeOfTrap,
            SetPrototypeOfTrap,
            ConstructTrap
        ]
    },
    { provide: ApplyTrap, useClass: ApplyTrap, deps: [Tracker, InteractionPlayer] },
    {
        provide: GetTrap, useClass: GetTrap, deps: [
            MOCK,
            Tracker,
            PropertiesValueStorage,
            InteractionPlayer,
            HasPropertyExplorer,
            HasMethodExplorer,
            SpyFunctionProvider
        ]
    },
    { provide: GetPrototypeOfTrap, useClass: GetPrototypeOfTrap, deps: [PrototypeStorage] },
    {
        provide: HasTrap, useClass: HasTrap, deps: [
            Tracker,
            PropertiesValueStorage,
            InteractionPlayer,
            InOperatorInteractionExplorer,
            HasPropertyExplorer,
            HasMethodExplorer,
            PresetPlayablesUpdater
        ]
    },
    { provide: PropertiesValueStorage, useClass: PropertiesValueStorage, deps: [] },
    { provide: PrototypeStorage, useFactory: ({ target }) => new PrototypeStorage(target), deps: [MOCK_OPTIONS] },
    {
        provide: SetTrap,
        useClass: SetTrap,
        deps: [Tracker, PropertiesValueStorage, InteractionPlayer, PropertyIsReadOnlyTester]
    },
    { provide: SetPrototypeOfTrap, useClass: SetPrototypeOfTrap, deps: [PrototypeStorage] },
    { provide: SpyFunctionProvider, useClass: SpyFunctionProvider, deps: [Tracker, InteractionPlayer] },
    { provide: ConstructTrap, useClass: ConstructTrap, deps: [Tracker, InteractionPlayer] },
];

/**
 * @hidden
 */
var playablesProviders = [
    { provide: PresetPlayablesUpdater, useClass: PresetPlayablesUpdater, deps: [Presets, ExpressionEqualityComparer] }
];

/**
 * @hidden
 */
class PresetPlayer {
    constructor(callbackPresetPlayer, mimicsPresetPlayer) {
        this.callbackPresetPlayer = callbackPresetPlayer;
        this.mimicsPresetPlayer = mimicsPresetPlayer;
    }
    play(preset, interaction) {
        if (preset instanceof ReturnsPreset) {
            return preset.value;
        }
        if (preset instanceof CallbacksPreset) {
            return this.callbackPresetPlayer.play(preset.callback, interaction);
        }
        if (preset instanceof MimicsPreset) {
            return this.mimicsPresetPlayer.play(preset.origin, interaction);
        }
        if (preset instanceof ThrowsPreset) {
            throw preset.exception;
        }
    }
}

/**
 * @hidden
 */
class CallbackPresetPlayer {
    play(callback, interaction) {
        return callback.apply(undefined, [interaction]);
    }
}

/**
 * @hidden
 */
class MimicsPresetPlayer {
    constructor(apply) {
        this.apply = apply;
    }
    play(origin, interaction) {
        if (interaction instanceof GetPropertyExpression) {
            return origin[interaction.name];
        }
        if (interaction instanceof SetPropertyExpression) {
            origin[interaction.name] = interaction.value;
            return true;
        }
        if (interaction instanceof MethodExpression) {
            const method = origin[interaction.name];
            return this.apply(method, origin, interaction.args);
        }
        if (interaction instanceof FunctionExpression) {
            return this.apply(origin, undefined, interaction.args);
        }
        if (interaction instanceof InOperatorExpression) {
            return interaction.name in origin;
        }
        if (interaction instanceof NewOperatorExpression) {
            return new origin(...interaction.args);
        }
    }
}

/**
 * @hidden
 */
class PlayablePresetProvider {
    constructor(presets, matcher) {
        this.presets = presets;
        this.matcher = matcher;
    }
    get(interaction) {
        for (const preset of this.presets.get()) {
            const { target, playable: { isPlayable } } = preset;
            if (this.matcher.equals(interaction, target) && isPlayable() === true) {
                return preset;
            }
        }
    }
}

/**
 * @hidden
 */
const REFLECT_APPLY = new InjectionToken("Reflect Apply");

/**
 * @hidden
 */
var interactionPlayersProviders = [
    { provide: REFLECT_APPLY, useValue: Reflect.apply, deps: [] },
    { provide: PresetPlayer, useClass: PresetPlayer, deps: [CallbackPresetPlayer, MimicsPresetPlayer] },
    { provide: PlayablePresetProvider, useClass: PlayablePresetProvider, deps: [Presets, ExpressionEqualityComparer] },
    { provide: MimicsPresetPlayer, useClass: MimicsPresetPlayer, deps: [REFLECT_APPLY] },
    {
        provide: InteractionPlayer,
        useClass: InteractionPlayer,
        deps: [PlayablePresetProvider, PresetPlayablesUpdater, PresetPlayer]
    },
    { provide: CallbackPresetPlayer, useClass: CallbackPresetPlayer, deps: [] },
];

/**
 * @hidden
 */
class ExpressionsFormatter {
    constructor(interactionFormatter, options) {
        this.interactionFormatter = interactionFormatter;
        this.options = options;
    }
    format(expression, timesMessage, haveBeenCalledTimes) {
        const expressionDescription = this.interactionFormatter.format(expression);
        const mockName = this.options.name;
        const mockDescription = mockName !== undefined ? ` of ${mockName}` : "";
        return `${expressionDescription}${mockDescription} ${timesMessage.toLowerCase()}, but was called ${haveBeenCalledTimes} time(s)`;
    }
}

/**
 * @hidden
 */
class InteractionFormatter {
    constructor(getPropertyFormatter, setPropertyFormatter, methodFormatter, namedMethodFormatter, constantFormatter, inOperatorFormatter, newOperatorFormatter) {
        this.getPropertyFormatter = getPropertyFormatter;
        this.setPropertyFormatter = setPropertyFormatter;
        this.methodFormatter = methodFormatter;
        this.namedMethodFormatter = namedMethodFormatter;
        this.constantFormatter = constantFormatter;
        this.inOperatorFormatter = inOperatorFormatter;
        this.newOperatorFormatter = newOperatorFormatter;
    }
    format(interaction) {
        if (interaction instanceof GetPropertyExpression)
            return this.getPropertyFormatter.format(interaction);
        if (interaction instanceof SetPropertyExpression)
            return this.setPropertyFormatter.format(interaction);
        if (interaction instanceof InOperatorExpression)
            return this.inOperatorFormatter.format(interaction);
        if (interaction instanceof FunctionExpression)
            return this.methodFormatter.format(interaction);
        if (interaction instanceof MethodExpression)
            return this.namedMethodFormatter.format(interaction);
        if (interaction instanceof NewOperatorExpression)
            return this.newOperatorFormatter.format(interaction);
        if (interaction instanceof It)
            return this.constantFormatter.format(interaction);
        return undefined;
    }
}

/**
 * @hidden
 */
class SetPropertyFormatter {
    constructor(constantFormatter, propertyKeyFormatter) {
        this.constantFormatter = constantFormatter;
        this.propertyKeyFormatter = propertyKeyFormatter;
    }
    format(expression) {
        const value = this.constantFormatter.format(expression.value);
        const propertyKey = this.propertyKeyFormatter.format(expression.name);
        return `Assignment of ${value} to property \'${propertyKey}\'`;
    }
}

/**
 * @hidden
 */
class ConstantFormatter {
    format(object) {
        if (object instanceof It)
            return `It.Is(${object.predicate})`;
        if (object instanceof String || typeof object === "string")
            return `\'${object}\'`;
        if (object instanceof Array) {
            const description = [];
            for (const value of object) {
                description.push(this.format(value));
            }
            return `[${description}]`;
        }
        return `${object}`;
    }
}

/**
 * @hidden
 */
class PropertyKeyFormatter {
    format(property) {
        return String(property);
    }
}

/**
 * @hidden
 */
class MethodFormatter {
    constructor(constantFormatter, propertyKeyFormatter) {
        this.constantFormatter = constantFormatter;
        this.propertyKeyFormatter = propertyKeyFormatter;
    }
    format(expression) {
        const formatted = [];
        for (const arg of expression.args) {
            formatted.push(this.constantFormatter.format(arg));
        }
        const value = formatted.join(", ");
        const propertyKey = this.propertyKeyFormatter.format(expression.name);
        return `${propertyKey}(${value})`;
    }
}

/**
 * @hidden
 */
class FunctionFormatter {
    constructor(constantFormatter) {
        this.constantFormatter = constantFormatter;
    }
    format(expression) {
        const value = this.constantFormatter.format(expression.args);
        return `(${value})`;
    }
}

/**
 * @hidden
 */
class InOperatorFormatter {
    constructor(propertyKeyFormatter) {
        this.propertyKeyFormatter = propertyKeyFormatter;
    }
    format(expression) {
        const propertyKey = this.propertyKeyFormatter.format(expression.name);
        return `In operator for \'${propertyKey}\'`;
    }
}

/**
 * @hidden
 */
class GetPropertyFormatter {
    constructor(propertyKeyFormatter) {
        this.propertyKeyFormatter = propertyKeyFormatter;
    }
    format(interaction) {
        const propertyKey = this.propertyKeyFormatter.format(interaction.name);
        return `Getter of \'${propertyKey}\'`;
    }
}

/**
 * @hidden
 */
class NewOperatorFormatter {
    constructor(constantFormatter) {
        this.constantFormatter = constantFormatter;
    }
    format(expression) {
        const value = this.constantFormatter.format(expression.args);
        return `new constructor(${value})`;
    }
}

/**
 * @hidden
 */
var formattersProviders = [
    {
        provide: VerifyFormatter,
        useClass: VerifyFormatter,
        deps: [ExpressionsFormatter, TrackedExpressionsFormatter, Tracker]
    },
    { provide: TrackedExpressionsFormatter, useClass: TrackedExpressionsFormatter, deps: [InteractionFormatter] },
    { provide: SetPropertyFormatter, useClass: SetPropertyFormatter, deps: [ConstantFormatter, PropertyKeyFormatter] },
    { provide: PropertyKeyFormatter, useClass: PropertyKeyFormatter, deps: [] },
    { provide: MethodFormatter, useClass: MethodFormatter, deps: [ConstantFormatter, PropertyKeyFormatter] },
    { provide: FunctionFormatter, useClass: FunctionFormatter, deps: [ConstantFormatter] },
    { provide: InOperatorFormatter, useClass: InOperatorFormatter, deps: [PropertyKeyFormatter] },
    { provide: GetPropertyFormatter, useClass: GetPropertyFormatter, deps: [PropertyKeyFormatter] },
    { provide: ExpressionsFormatter, useClass: ExpressionsFormatter, deps: [InteractionFormatter, MOCK_OPTIONS] },
    { provide: ConstantFormatter, useClass: ConstantFormatter, deps: [] },
    { provide: NewOperatorFormatter, useClass: NewOperatorFormatter, deps: [ConstantFormatter] },
    {
        provide: InteractionFormatter,
        useClass: InteractionFormatter,
        deps: [
            GetPropertyFormatter,
            SetPropertyFormatter,
            FunctionFormatter,
            MethodFormatter,
            ConstantFormatter,
            InOperatorFormatter,
            NewOperatorFormatter
        ]
    }
];

/**
 * @hidden
 */
class ExpressionHasMethodExplorer {
    has(name, expression) {
        if (expression instanceof MethodExpression) {
            return expression.name === name;
        }
        return false;
    }
}

/**
 * @hidden
 */
class MembersMethodExplorer {
    constructor(storage, propertyDescriptorProvider, has) {
        this.storage = storage;
        this.propertyDescriptorProvider = propertyDescriptorProvider;
        this.has = has;
    }
    hasMethod(name) {
        const prototype = this.storage.get();
        if (prototype && this.has(prototype, name)) {
            const descriptor = this.propertyDescriptorProvider.get(prototype, name);
            return descriptor.value instanceof Function;
        }
        return false;
    }
}

/**
 * @hidden
 */
class PresetHasMethodExplorer {
    constructor(expressionHasMethodExplorer, objectHasMethodExplorer) {
        this.expressionHasMethodExplorer = expressionHasMethodExplorer;
        this.objectHasMethodExplorer = objectHasMethodExplorer;
    }
    has(name, preset) {
        if (preset instanceof MimicsPreset && this.objectHasMethodExplorer.has(name, preset.origin)) {
            return true;
        }
        return this.expressionHasMethodExplorer.has(name, preset.target);
    }
}

/**
 * @hidden
 */
class ObjectHasMethodExplorer {
    has(name, target) {
        return target[name] instanceof Function;
    }
}

/**
 * @hidden
 */
class ExpressionHasPropertyExplorer {
    has(name, expression) {
        if (expression instanceof It
            || expression instanceof FunctionExpression
            || expression instanceof MethodExpression
            || expression instanceof InOperatorExpression) {
            return false;
        }
        return expression.name === name;
    }
}

/**
 * @hidden
 */
class MembersPropertyExplorer {
    constructor(storage, propertyDescriptorProvider, has) {
        this.storage = storage;
        this.propertyDescriptorProvider = propertyDescriptorProvider;
        this.has = has;
    }
    hasProperty(name) {
        const prototype = this.storage.get();
        if (prototype && this.has(prototype, name)) {
            const descriptor = this.propertyDescriptorProvider.get(prototype, name);
            return descriptor.get !== undefined || (descriptor.value instanceof Function) === false;
        }
        return false;
    }
}

/**
 * @hidden
 */
class PresetHasPropertyExplorer {
    constructor(expressionHasPropertyExplorer, objectHasPropertyExplorer) {
        this.expressionHasPropertyExplorer = expressionHasPropertyExplorer;
        this.objectHasPropertyExplorer = objectHasPropertyExplorer;
    }
    has(name, preset) {
        if (preset instanceof MimicsPreset && this.objectHasPropertyExplorer.has(name, preset.origin)) {
            return true;
        }
        return this.expressionHasPropertyExplorer.has(name, preset.target);
    }
}

/**
 * @hidden
 */
class ObjectHasPropertyExplorer {
    has(name, target) {
        return Reflect.has(target, name) && (target[name] instanceof Function) === false;
    }
}

/**
 * @hidden
 */
class PresetHasInOperatorExplorer {
    has(name, preset) {
        const { playable: { isPlayable } } = preset;
        if (isPlayable() === false) {
            return false;
        }
        if (preset.target instanceof InOperatorExpression) {
            return preset.target.name === name;
        }
        if (preset.target instanceof It) {
            return preset.target.test(new InOperatorExpression(name));
        }
        return false;
    }
}

/**
 * @hidden
 */
class PropertyDescriptorProvider {
    get(target, name) {
        let prototype = target;
        while (prototype !== null) {
            const descriptor = Reflect.getOwnPropertyDescriptor(prototype, name);
            if (descriptor !== undefined)
                return descriptor;
            prototype = Reflect.getPrototypeOf(prototype);
        }
    }
}

/**
 * @hidden
 */
const REFLECT_HAS = new InjectionToken("Reflect has");

/**
 * @hidden
 */
var typeExplorersProviders = [
    { provide: ExpressionHasMethodExplorer, useClass: ExpressionHasMethodExplorer, deps: [] },
    {
        provide: HasMethodExplorer,
        useClass: HasMethodExplorer,
        deps: [Presets, MembersMethodExplorer, PresetHasMethodExplorer]
    },
    { provide: ObjectHasMethodExplorer, useClass: ObjectHasMethodExplorer, deps: [] },
    {
        provide: PresetHasMethodExplorer,
        useClass: PresetHasMethodExplorer,
        deps: [ExpressionHasMethodExplorer, ObjectHasMethodExplorer]
    },
    { provide: ExpressionHasPropertyExplorer, useClass: ExpressionHasPropertyExplorer, deps: [] },
    {
        provide: HasPropertyExplorer,
        useClass: HasPropertyExplorer,
        deps: [Presets, MembersPropertyExplorer, PresetHasPropertyExplorer]
    },
    { provide: ObjectHasPropertyExplorer, useClass: ObjectHasPropertyExplorer, deps: [] },
    {
        provide: PresetHasPropertyExplorer,
        useClass: PresetHasPropertyExplorer,
        deps: [ExpressionHasPropertyExplorer, ObjectHasPropertyExplorer]
    },
    {
        provide: InOperatorInteractionExplorer,
        useClass: InOperatorInteractionExplorer,
        deps: [Presets, PresetHasInOperatorExplorer]
    },
    { provide: PresetHasInOperatorExplorer, useClass: PresetHasInOperatorExplorer, deps: [] },
    {
        provide: MembersMethodExplorer,
        useClass: MembersMethodExplorer,
        deps: [PrototypeStorage, PropertyDescriptorProvider, REFLECT_HAS]
    },
    {
        provide: PropertyIsReadOnlyTester,
        useClass: PropertyIsReadOnlyTester,
        deps: [PrototypeStorage, PropertyDescriptorProvider, REFLECT_HAS]
    },
    {
        provide: MembersPropertyExplorer,
        useClass: MembersPropertyExplorer,
        deps: [PrototypeStorage, PropertyDescriptorProvider, REFLECT_HAS]
    },
    { provide: PropertyDescriptorProvider, useClass: PropertyDescriptorProvider, deps: [] },
    { provide: REFLECT_HAS, useValue: Reflect.has, deps: [] },
];

/**
 * @hidden
 */
class MockOptionsBuilder {
    build(options) {
        const target = (() => undefined);
        return Object.assign({ target }, options);
    }
}

/**
 * @hidden
 */
function mockOptionsProviders(options) {
    return [
        { provide: MockOptionsBuilder, useClass: MockOptionsBuilder, deps: [] },
        { provide: MOCK_OPTIONS, useFactory: builder => builder.build(options), deps: [MockOptionsBuilder] },
    ];
}

/**
 * The internal core of {@link Mock} class.
 */
class MockCore {
    constructor(options, tracker, injector, reflector, interceptor, verifier, prototypeStorage, mock, setupFactory) {
        this.options = options;
        this.tracker = tracker;
        this.injector = injector;
        this.reflector = reflector;
        this.interceptor = interceptor;
        this.verifier = verifier;
        this.prototypeStorage = prototypeStorage;
        this.mock = mock;
        this.setupFactory = setupFactory;
    }
    get name() {
        return this.options.name;
    }
    resolve(token) {
        return this.injector.get(token, null);
    }
    setup(expression) {
        const expressions = this.reflector.reflect(expression);
        return this.setupFactory.create(expressions);
    }
    verify(expression, times) {
        const expressions = this.reflector.reflect(expression);
        this.verifier.test(expressions, times);
        return this.mock;
    }
    object() {
        return this.interceptor.object();
    }
    prototypeof(prototype) {
        this.prototypeStorage.set(prototype);
        return this.mock;
    }
    /**
     * @experimental
     */
    insequence(sequence, expression) {
        sequence.add(this, expression);
        return this.mock;
    }
}

/**
 * @hidden
 */
var mockCoreProviders = [
    {
        provide: MockCore, useClass: MockCore, deps: [
            MOCK_OPTIONS,
            Tracker,
            Injector,
            EXPRESSION_REFLECTOR,
            ProxyFactory,
            Verifier,
            PrototypeStorage,
            MOCK,
            SetupFactory
        ]
    },
];

/**
 * This service is used to create an instance of a Mock for auto mocking feature
 */
class AutoMockFactory {
    constructor(ctor, optionsBuilder) {
        this.ctor = ctor;
        this.optionsBuilder = optionsBuilder;
    }
    create(expression) {
        const options = this.optionsBuilder.create(expression);
        return this.ctor(options);
    }
}

/**
 * @Hidden
 */
const ROOT_MOCK = new InjectionToken("ROOT MOCK");

/**
 * This service provides access to all auto mocked instances
 */
class AutoMockedStorage {
    constructor() {
        return this.factory();
    }
    factory() {
        return new Map();
    }
}

/**
 * This class provides configuration for auto mocking mocks
 */
class AutoMockOptionsBuilder {
    constructor(options, autoMockNameFormatter, autoMockInjectorConfig) {
        this.options = options;
        this.autoMockNameFormatter = autoMockNameFormatter;
        this.autoMockInjectorConfig = autoMockInjectorConfig;
    }
    create(expression) {
        return {
            name: this.autoMockNameFormatter.format(this.options.name, expression),
            target: this.options.target,
            injectorConfig: this.autoMockInjectorConfig
        };
    }
}

/**
 * @hidden
 */
class AutoMockNameFormatter {
    constructor(namePrefixProvider, methodFormatter, propertyKeyFormatter, namedMethodFormatter, constantFormatter) {
        this.namePrefixProvider = namePrefixProvider;
        this.methodFormatter = methodFormatter;
        this.propertyKeyFormatter = propertyKeyFormatter;
        this.namedMethodFormatter = namedMethodFormatter;
        this.constantFormatter = constantFormatter;
    }
    format(name, expression) {
        const prefix = this.namePrefixProvider.get(name);
        if (expression instanceof FunctionExpression) {
            return `${prefix}${this.methodFormatter.format(expression)}`;
        }
        if (expression instanceof GetPropertyExpression) {
            return `${prefix}.${this.propertyKeyFormatter.format(expression.name)}`;
        }
        if (expression instanceof MethodExpression) {
            return `${prefix}.${this.namedMethodFormatter.format(expression)}`;
        }
        if (expression instanceof NewOperatorExpression) {
            return `new ${name}(${this.constantFormatter.format(expression.args)})`;
        }
        return `${name}[${expression}]`;
    }
}

/**
 * Provides configuration for an angular based injector that would be used internally for auto mocking feature
 */
class AutoMockInjectorConfig {
    constructor(options, mock, root) {
        this.options = options;
        this.mock = mock;
        this.root = root;
    }
    get(options, providers) {
        if (this.root) {
            return this.options.injectorConfig.get(options, providers);
        }
        return [
            ...this.options.injectorConfig.get(options, providers),
            { provide: ROOT_MOCK, useValue: this.mock, deps: [] },
        ];
    }
}

/**
 * @hidden
 */
class NamePrefixProvider {
    get(name) {
        return name ? name : "instance";
    }
}

/**
 * @Hidden
 */
const MOCK_CONSTRUCTOR = new InjectionToken("IMock constructor");

class ComplexExpressionValidator {
    constructor(validator) {
        this.validator = validator;
    }
    validate(expressions) {
        const errors = [];
        const clone = [...expressions];
        const last = clone.pop();
        for (const expression of clone) {
            errors.push([expression, this.validator.validate(expression)]);
        }
        errors.push([last, true]);
        const isValid = errors.filter(([, valid]) => valid === false).length === 0;
        return {
            valid: isValid,
            errors: isValid ? [] : errors
        };
    }
}

class ExpressionGuardExceptionFactory {
    constructor(formatter) {
        this.formatter = formatter;
    }
    create(expressions) {
        const message = `${this.formatter.format(expressions)} is not a safe expression for auto mocking. `
            + " It predicate could not be used, the only exception is the last part."
            + " Please see https://github.com/dvabuzyarov/moq.ts#auto-mocking for more details.";
        return new Error(message);
    }
}

class ExpressionValidator {
    constructor(functionExpressionGuard, getPropertyExpressionGuard, setPropertyExpressionGuard, inOperatorExpressionGuard, instanceMethodExpressionGuard, newOperatorExpressionGuard) {
        this.functionExpressionGuard = functionExpressionGuard;
        this.getPropertyExpressionGuard = getPropertyExpressionGuard;
        this.setPropertyExpressionGuard = setPropertyExpressionGuard;
        this.inOperatorExpressionGuard = inOperatorExpressionGuard;
        this.instanceMethodExpressionGuard = instanceMethodExpressionGuard;
        this.newOperatorExpressionGuard = newOperatorExpressionGuard;
    }
    validate(expression) {
        switch (expression.constructor) {
            case FunctionExpression:
                return this.functionExpressionGuard.validate(expression);
            case GetPropertyExpression:
                return this.getPropertyExpressionGuard.validate(expression);
            case SetPropertyExpression:
                return this.setPropertyExpressionGuard.validate(expression);
            case InOperatorExpression:
                return this.inOperatorExpressionGuard.validate(expression);
            case MethodExpression:
                return this.instanceMethodExpressionGuard.validate(expression);
            case NewOperatorExpression:
                return this.newOperatorExpressionGuard.validate(expression);
            case It:
                return false;
            default:
                throw new Error(`Unknown expression type: ${expression.constructor.name}`);
        }
    }
}

class FunctionExpressionValidator {
    validate({ args }) {
        return args.filter(arg => arg instanceof It).length === 0;
    }
}

class GetPropertyExpressionValidator {
    validate({ name }) {
        return (name instanceof It) === false;
    }
}

class SetPropertyExpressionValidator {
    validate({ name, value }) {
        return (name instanceof It || value instanceof It) === false;
    }
}

class InOperatorExpressionValidator {
    validate({ name }) {
        return (name instanceof It) === false;
    }
}

class InstanceMethodExpressionValidator {
    validate({ name, args }) {
        return (name instanceof It || args.filter(arg => arg instanceof It).length > 0) === false;
    }
}

class NewOperatorExpressionValidator {
    validate({ args }) {
        return args.filter(arg => arg instanceof It).length === 0;
    }
}

class ComplexExpressionErrorFormatter {
    constructor(options, namePrefixProvider, expressionFormatter, errorStyler) {
        this.options = options;
        this.namePrefixProvider = namePrefixProvider;
        this.expressionFormatter = expressionFormatter;
        this.errorStyler = errorStyler;
    }
    format(expressions) {
        const instance = this.namePrefixProvider.get(this.options.name);
        let message = instance;
        for (const [expression, valid] of expressions) {
            const value = this.expressionFormatter.format(expression, instance);
            message += valid ? value : this.errorStyler.style(value);
        }
        return message;
    }
}

class ExpressionFormatter {
    constructor(functionFormatter, propertyKeyFormatter, instanceMethodFormatter, constantFormatter) {
        this.functionFormatter = functionFormatter;
        this.propertyKeyFormatter = propertyKeyFormatter;
        this.instanceMethodFormatter = instanceMethodFormatter;
        this.constantFormatter = constantFormatter;
    }
    format(expression, name) {
        if (expression instanceof FunctionExpression) {
            return this.functionFormatter.format(expression);
        }
        if (expression instanceof GetPropertyExpression) {
            return `.${this.propertyKeyFormatter.format(expression.name)}`;
        }
        if (expression instanceof MethodExpression) {
            return `.${this.instanceMethodFormatter.format(expression)}`;
        }
        if (expression instanceof NewOperatorExpression) {
            return `new ${name}(${this.constantFormatter.format(expression.args)})`;
        }
        return `[${expression}]`;
    }
}

class StringErrorStyler {
    style(value) {
        return `\u001B[4m${value}\u001B[24m`;
    }
}

var expressionFormatters = [
    {
        provide: ComplexExpressionErrorFormatter, useClass: ComplexExpressionErrorFormatter, deps: [
            MOCK_OPTIONS,
            NamePrefixProvider,
            ExpressionFormatter,
            StringErrorStyler
        ]
    },
    {
        provide: ExpressionFormatter,
        useClass: ExpressionFormatter,
        deps: [FunctionFormatter, PropertyKeyFormatter, MethodFormatter, ConstantFormatter]
    },
    { provide: StringErrorStyler, useClass: StringErrorStyler, deps: [] },
];

/**
 * @hidden
 */
var expressionGuards = [
    {
        provide: ComplexExpressionGuard,
        useClass: ComplexExpressionGuard,
        deps: [ComplexExpressionValidator, ExpressionGuardExceptionFactory]
    },
    { provide: ComplexExpressionValidator, useClass: ComplexExpressionValidator, deps: [ExpressionValidator] },
    {
        provide: ExpressionGuardExceptionFactory,
        useClass: ExpressionGuardExceptionFactory,
        deps: [ComplexExpressionErrorFormatter]
    },
    {
        provide: ExpressionValidator, useClass: ExpressionValidator, deps: [
            FunctionExpressionValidator,
            GetPropertyExpressionValidator,
            SetPropertyExpressionValidator,
            InOperatorExpressionValidator,
            InstanceMethodExpressionValidator,
            NewOperatorExpressionValidator
        ]
    },
    { provide: FunctionExpressionValidator, useClass: FunctionExpressionValidator, deps: [] },
    { provide: GetPropertyExpressionValidator, useClass: GetPropertyExpressionValidator, deps: [] },
    { provide: SetPropertyExpressionValidator, useClass: SetPropertyExpressionValidator, deps: [] },
    { provide: InOperatorExpressionValidator, useClass: InOperatorExpressionValidator, deps: [] },
    { provide: InstanceMethodExpressionValidator, useClass: InstanceMethodExpressionValidator, deps: [] },
    { provide: NewOperatorExpressionValidator, useClass: NewOperatorExpressionValidator, deps: [] },
    ...expressionFormatters
];

/**
 * @hidden
 */
var autoMockingProviders = [
    { provide: NamePrefixProvider, useClass: NamePrefixProvider, deps: [] },
    { provide: AutoMockedStorage, useClass: AutoMockedStorage, deps: [] },
    {
        provide: AutoMockNameFormatter,
        useClass: AutoMockNameFormatter,
        deps: [NamePrefixProvider, FunctionFormatter, PropertyKeyFormatter, MethodFormatter, ConstantFormatter]
    },
    {
        provide: AutoMockOptionsBuilder,
        useClass: AutoMockOptionsBuilder,
        deps: [MOCK_OPTIONS, AutoMockNameFormatter, AutoMockInjectorConfig]
    },
    {
        provide: AutoMockInjectorConfig,
        useClass: AutoMockInjectorConfig,
        deps: [MOCK_OPTIONS, MOCK, [new Optional(), ROOT_MOCK]]
    },
    { provide: AutoMockFactory, useClass: AutoMockFactory, deps: [MOCK_CONSTRUCTOR, AutoMockOptionsBuilder] },
    { provide: RootMockProvider, useClass: RootMockProvider, deps: [MOCK, [new Optional(), ROOT_MOCK]] },
    {
        provide: AutoMockProvider,
        useClass: AutoMockProvider,
        deps: [AutoMockedStorage, ExpressionEqualityComparer, AutoMockFactory]
    },
    { provide: ComplexExpressionValidator, useClass: ComplexExpressionValidator, deps: [] },
    ...expressionGuards
];

/**
 * @hidden
 */
class ConstantEqualityComparer {
    constructor(itEqualityComparer) {
        this.itEqualityComparer = itEqualityComparer;
    }
    equals(left, right) {
        const actual = this.itEqualityComparer.equals(left, right);
        return actual === undefined ? left === right : actual;
    }
}

/**
 * @hidden
 */
class ArgumentsEqualityComparer {
    constructor(constantMatcher) {
        this.constantMatcher = constantMatcher;
    }
    equals(left, right) {
        if (left === right)
            return true;
        if (left.length !== right.length)
            return false;
        for (let i = 0; i < left.length; i++) {
            const lvalue = left[i];
            const rvalue = right[i];
            if (this.constantMatcher.equals(lvalue, rvalue) === false) {
                return false;
            }
        }
        return true;
    }
}

/**
 * @hidden
 */
class GetPropertyEqualityComparer {
    equals(left, right) {
        return left.name === right.name;
    }
}

/**
 * @hidden
 */
class InOperatorEqualityComparer {
    equals(left, right) {
        return left.name === right.name;
    }
}

/**
 * @hidden
 */
class InstanceMethodEqualityComparer {
    constructor(argumentsMatcher) {
        this.argumentsMatcher = argumentsMatcher;
    }
    equals(left, right) {
        return left.name === right.name && this.argumentsMatcher.equals(left.args, right.args);
    }
}

/**
 * @hidden
 */
class ItEqualityComparer {
    equals(left, right) {
        if (left instanceof It && right instanceof It) {
            return left === right || left.predicate === right.predicate;
        }
        if (left instanceof It) {
            return left.test(right);
        }
        if (right instanceof It) {
            return right.test(left);
        }
        return undefined;
    }
}

/**
 * @hidden
 */
class MethodEqualityComparer {
    constructor(argumentsMatcher) {
        this.argumentsMatcher = argumentsMatcher;
    }
    equals(left, right) {
        return this.argumentsMatcher.equals(left.args, right.args);
    }
}

/**
 * @hidden
 */
class NewOperatorEqualityComparer {
    constructor(argumentsMatcher) {
        this.argumentsMatcher = argumentsMatcher;
    }
    equals(left, right) {
        return this.argumentsMatcher.equals(left.args, right.args);
    }
}

/**
 * @hidden
 */
class SetPropertyEqualityComparer {
    constructor(constantMatcher) {
        this.constantMatcher = constantMatcher;
    }
    equals(left, right) {
        return left.name === right.name && this.constantMatcher.equals(left.value, right.value);
    }
}

/**
 * @hidden
 */
var expressionEqualityComparersProviders = [
    { provide: ConstantEqualityComparer, useClass: ConstantEqualityComparer, deps: [ItEqualityComparer] },
    { provide: ArgumentsEqualityComparer, useClass: ArgumentsEqualityComparer, deps: [ConstantEqualityComparer] },
    { provide: GetPropertyEqualityComparer, useClass: GetPropertyEqualityComparer, deps: [] },
    { provide: InOperatorEqualityComparer, useClass: InOperatorEqualityComparer, deps: [] },
    {
        provide: InstanceMethodEqualityComparer,
        useClass: InstanceMethodEqualityComparer,
        deps: [ArgumentsEqualityComparer]
    },
    { provide: ItEqualityComparer, useClass: ItEqualityComparer, deps: [] },
    { provide: MethodEqualityComparer, useClass: MethodEqualityComparer, deps: [ArgumentsEqualityComparer] },
    { provide: NewOperatorEqualityComparer, useClass: NewOperatorEqualityComparer, deps: [ArgumentsEqualityComparer] },
    { provide: SetPropertyEqualityComparer, useClass: SetPropertyEqualityComparer, deps: [ConstantEqualityComparer] },
    {
        provide: ExpressionEqualityComparer,
        useClass: ExpressionEqualityComparer,
        deps: [
            GetPropertyEqualityComparer,
            SetPropertyEqualityComparer,
            MethodEqualityComparer,
            InstanceMethodEqualityComparer,
            InOperatorEqualityComparer,
            NewOperatorEqualityComparer,
            ItEqualityComparer
        ]
    },
];

/**
 * Provides the default configuration for an angular based injector that would be used internally by {@link Mock} instance.
 */
class DefaultInjectorConfig {
    constructor(providers = []) {
        this.providers = providers;
    }
    get(options, providers) {
        return [
            ...providers,
            ...mockOptionsProviders(options),
            ...trackerProviders,
            ...reflectorProviders,
            ...presetsProviders,
            ...autoMockingProviders,
            ...verificationProviders,
            ...interceptorsProviders,
            ...playablesProviders,
            ...interactionPlayersProviders,
            ...formattersProviders,
            ...expressionEqualityComparersProviders,
            ...typeExplorersProviders,
            ...mockCoreProviders,
            ...this.providers,
        ];
    }
}

/**
 * The default implementation of {@link IMock} interface.
 */
class Mock {
    constructor(options = {}) {
        const preOptions = Object.assign(Object.assign({}, Mock.options), options);
        const providers = [
            { provide: MOCK, useValue: this, deps: [] },
            { provide: MOCK_CONSTRUCTOR, useValue: (opts) => new Mock(opts), deps: [] },
        ];
        const injector = injectorFactory(preOptions, ...providers);
        this.core = injector.get(MockCore);
    }
    /**
     * The default mock options that would applied to all instantiating Mock objects.
     * By default it sets {@link IMockOptions.target} as a function, {@link IMockOptions.injectorConfig} as
     * instance of {@link DefaultInjectorConfig} and {@link IMockOptions.name} as undefined.
     * If an options are passed as constructor parameter {@link Mock.constructor} they will override the default options.
     */
    static get options() {
        if (Mock.Options === undefined) {
            Mock.Options = {
                target: () => undefined,
                injectorConfig: new DefaultInjectorConfig()
            };
        }
        return Mock.Options;
    }
    /**
     * The default mock options that would applied to all instantiating Mock objects.
     * If an options are passed as constructor parameter they will override the default options.
     */
    static set options(options) {
        Mock.Options = options;
    }
    get options() {
        return this.core.options;
    }
    get tracker() {
        return this.core.tracker;
    }
    get name() {
        return this.core.name;
    }
    setup(expression) {
        return this.core.setup(expression);
    }
    verify(expression, times = Times.Once()) {
        return this.core.verify(expression, times);
    }
    object() {
        return this.core.object();
    }
    prototypeof(prototype) {
        return this.core.prototypeof(prototype);
    }
    /**
     * @experimental
     */
    insequence(sequence, expression) {
        return this.core.insequence(sequence, expression);
    }
    resolve(token) {
        return this.core.resolve(token);
    }
}
Mock.Options = undefined;

/**
 * @hidden
 */
class CommonTypeProvider {
    ofType(left, right) {
        return typeof left && typeof right;
    }
}

/**
 * Matches Date objects
 */
class DateMatcher {
    matched(left, right) {
        if (left instanceof Date && right instanceof Date) {
            return left.valueOf() === right.valueOf();
        }
        return undefined;
    }
}

/**
 * @hidden
 */
class EqualConstantMatcher {
    constructor(itEqualityComparer, equalMatcher) {
        this.itEqualityComparer = itEqualityComparer;
        this.equalMatcher = equalMatcher;
    }
    equals(left, right) {
        const actual = this.itEqualityComparer.equals(left, right);
        return actual === undefined ? this.equalMatcher.matched(left, right) : actual;
    }
}

/**
 * @hidden
 */
class EqualMatcher {
    constructor(typesMatcher, commonTypeProvider, primitiveMatcher, objectMatcher, functionMatcher) {
        this.typesMatcher = typesMatcher;
        this.commonTypeProvider = commonTypeProvider;
        this.primitiveMatcher = primitiveMatcher;
        this.objectMatcher = objectMatcher;
        this.functionMatcher = functionMatcher;
    }
    matched(left, right) {
        if (this.typesMatcher.matched(left, right) === false) {
            return false;
        }
        switch (this.commonTypeProvider.ofType(left, right)) {
            case "undefined":
                return this.primitiveMatcher.matched(left, right);
            case "object":
                return this.objectMatcher.matched(left, right);
            case "boolean":
                return this.primitiveMatcher.matched(left, right);
            case "number":
                return this.primitiveMatcher.matched(left, right);
            case "string":
                return this.primitiveMatcher.matched(left, right);
            case "function":
                return this.functionMatcher.matched(left, right);
            case "symbol":
                return this.primitiveMatcher.matched(left, right);
            case "bigint":
                return this.primitiveMatcher.matched(left, right);
        }
    }
}

/**
 * @hidden
 */
class FunctionMatcher {
    matched(left, right) {
        return left === right;
    }
}

/**
 * @hidden
 */
class TypesMatcher {
    matched(left, right) {
        return typeof left === typeof right;
    }
}

/**
 * @hidden
 */
class PrimitiveMatcher {
    matched(left, right) {
        return left === right;
    }
}

/**
 * @hidden
 */
class ObjectMatcher {
    constructor(matchers) {
        this.matchers = matchers;
    }
    matched(left, right) {
        if (left === null && right === null)
            return true;
        if (left === right)
            return true;
        for (const matcher of this.matchers) {
            const matched = matcher.matched(left, right);
            if (matched === undefined) {
                continue;
            }
            return matched;
        }
        return false;
    }
}

/**
 * @hidden
 */
class IterableTester {
    verify(left, right) {
        return typeof left[Symbol.iterator] === "function" && typeof right[Symbol.iterator] === "function";
    }
}

/**
 * Matches objects that support Iterable protocol
 */
class IteratorMatcher {
    constructor(injector, iterableTester) {
        this.injector = injector;
        this.iterableTester = iterableTester;
    }
    /*eslint-disable-next-line @typescript-eslint/ban-types*/
    matched(left, right) {
        if (this.iterableTester.verify(left, right) === true) {
            const leftIterator = [...left[Symbol.iterator]()];
            const rightIterator = [...right[Symbol.iterator]()];
            if (leftIterator.length !== rightIterator.length)
                return false;
            const constantMatcher = this.injector.get(ConstantEqualityComparer);
            for (let i = 0; i < leftIterator.length; i++) {
                const leftValue = leftIterator[i];
                const rightValue = rightIterator[i];
                if (constantMatcher.equals(leftValue, rightValue) === false) {
                    return false;
                }
            }
            return true;
        }
        return undefined;
    }
}

const OBJECT_MATCHERS = new InjectionToken("OBJECT_MATCHERS");

/**
 * Matches objects as POJO
 */
class POJOMatcher {
    constructor(mapMatcher, objectMapProvider) {
        this.mapMatcher = mapMatcher;
        this.objectMapProvider = objectMapProvider;
    }
    /*eslint-disable-next-line @typescript-eslint/ban-types*/
    matched(left, right) {
        const leftProps = this.objectMapProvider.get(left);
        const rightProps = this.objectMapProvider.get(right);
        return this.mapMatcher.matched(leftProps, rightProps);
    }
}

/**
 * @hidden
 */
class ObjectMapProvider {
    /*eslint-disable-next-line @typescript-eslint/ban-types*/
    get(object) {
        const props = this.getProps(object, []);
        const keys = [...new Set(props)];
        const map = new Map();
        for (const key of keys) {
            map.set(key, object[key]);
        }
        return map;
    }
    getProps(object, props) {
        if (object === null)
            return props;
        if (object === Object.prototype)
            return props;
        props = [...props, ...Object.getOwnPropertyNames(object), ...Object.getOwnPropertySymbols(object)];
        return this.getProps(Object.getPrototypeOf(object), props);
    }
}

/**
 * Matches Map objects
 */
class MapMatcher {
    constructor(injector) {
        this.injector = injector;
    }
    matched(left, right) {
        if (left instanceof Map && right instanceof Map) {
            if (left.size !== right.size)
                return false;
            const constantMatcher = this.injector.get(ConstantEqualityComparer);
            for (const [key, value] of left) {
                if (right.has(key) === false)
                    return false;
                if (constantMatcher.equals(value, right.get(key)) === false)
                    return false;
            }
            return true;
        }
        return undefined;
    }
}

/**
 * @hidden
 */
var equalMatchersProviders = [
    { provide: ConstantEqualityComparer, useExisting: EqualConstantMatcher },
    { provide: EqualConstantMatcher, useClass: EqualConstantMatcher, deps: [ItEqualityComparer, EqualMatcher] },
    { provide: CommonTypeProvider, useClass: CommonTypeProvider, deps: [] },
    {
        provide: EqualMatcher,
        useClass: EqualMatcher,
        deps: [
            TypesMatcher,
            CommonTypeProvider,
            PrimitiveMatcher,
            ObjectMatcher,
            FunctionMatcher
        ]
    },
    { provide: FunctionMatcher, useClass: FunctionMatcher, deps: [] },
    { provide: IterableTester, useClass: IterableTester, deps: [] },
    {
        provide: IteratorMatcher,
        useClass: IteratorMatcher,
        deps: [
            Injector,
            IterableTester
        ]
    },
    { provide: ObjectMatcher, useClass: ObjectMatcher, deps: [OBJECT_MATCHERS] },
    { provide: POJOMatcher, useClass: POJOMatcher, deps: [MapMatcher, ObjectMapProvider] },
    { provide: PrimitiveMatcher, useClass: PrimitiveMatcher, deps: [] },
    { provide: ObjectMapProvider, useClass: ObjectMapProvider, deps: [] },
    { provide: TypesMatcher, useClass: TypesMatcher, deps: [] },
    { provide: MapMatcher, useClass: MapMatcher, deps: [Injector] },
];

/**
 * Provides the configuration for Angular based injector that would use equal logic for matching values.
 * By default, all values are matched with
 * [Equality comparisons and sameness](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness)
 * that is limited in matching objects. On the other hand developers are using so called "deep equal comparison" approach,
 * where objects are matched by its properties and values. This configuration changes the way how expressions are matched
 * and introduce deep equal comparison logic as well as an extension point for custom matchers.
 *
 * ```typescript
 *  import { EqualMatchingInjectorConfig, Mock } from "moq.ts";
 *
 *  const mock = new Mock<(args: number[]) => number>()
 *  .setup(instance => instance([2, 1]))
 *  .returns(2);
 *
 *  const object = mock.object();
 *
 *  const actual = object([2, 1]);
 *
 *  // since the default comparisons logic sees [2, 1] and [2, 1] as different objects the provided setup would not work
 *  expect(actual).toBe(undefined);
 *  ```
 *  and compare with
 *  ```typescript
 *  import { EqualMatchingInjectorConfig, Mock } from "moq.ts";
 *
 *  const mock = new Mock<(args: number[]) => number>({injectorConfig: new EqualMatchingInjectorConfig()})
 *  .setup(instance => instance([2, 1]))
 *  .returns(2);
 *
 *  const object = mock.object();
 *
 *  const actual = object([2, 1]);
 *
 *  expect(actual).toBe(2);
 *  ```
 *  Internally the equal comparision logic implemented as a collection of object matchers that implement {@link IObjectMatcher} interface.
 *
 *  Matchers with the most specific logic should come first in the collection and if they are not able to match the objects
 *  then more general matchers would be invoked.
 *
 *  The library comes with the following matchers:
 *  0. Custom matchers
 *  1. DateMatcher - matches [Date](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date) objects
 *  2. MapMatcher - matches [Map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map) objects
 *  3. IteratorMatcher - matches objects that supports
 *  [Iterator protocol](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols)
 *  4. POJOMatcher - as the last resort matches objects as [POJO](https://en.wikipedia.org/wiki/Plain_old_Java_object) objects.
 *
 *  if you need a custom matcher it will come at index 1. Here is an example of a custom matcher that matches Moment and Date objects.
 *  ```typescript
 *  import { EqualMatchingInjectorConfig, IObjectMatcher, Mock, OBJECT_MATCHERS } from "moq.ts";
 *  import { isMoment, utc } from "moment";
 *
 *  class MomentDateMatcher implements IObjectMatcher {
 *     matched<T extends object>(left: T, right: T): boolean | undefined {
 *         if (left instanceof Date && isMoment(right)) {
 *             return left.valueOf() === right.valueOf();
 *         }
 *         return undefined;
 *     }
 * }
 *
 *  const moment = utc(1);
 *  const injectorConfig = new EqualMatchingInjectorConfig([{
 *     provide: OBJECT_MATCHERS,
 *     useClass: MomentDateMatcher,
 *     multi: true,
 *     deps: []
 * }]);
 *
 *  const mock = new Mock<(args: any) => number>({injectorConfig})
 *  .setup(instance => instance(moment))
 *  .returns(2);
 *
 *  const object = mock.object();
 *
 *  const actual = object(new Date(1));
 *
 *  expect(actual).toBe(2);
 *  ```
 *  The matching logic of EqualMatchingInjectorConfig supports {@link It}.
 *  So you can do a partial comparision.
 *  ```typescript
 *  import { EqualMatchingInjectorConfig, It, Mock } from "moq.ts";
 *
 *  const func = () => undefined;
 *
 *  const injectorConfig = new EqualMatchingInjectorConfig();
 *  const mock = new Mock<(args: any) => number>({injectorConfig})
 *  .setup(instance => instance({func: It.IsAny()})) // <-- func property will be matched with It delegate
 *  .returns(2);
 *
 *  const object = mock.object();
 *
 *  const actual = object({func});
 *
 *  expect(actual).toBe(2);
 *  ```
 */
class EqualMatchingInjectorConfig extends DefaultInjectorConfig {
    constructor(matchers = [], providers = []) {
        super(providers);
        this.matchers = matchers;
    }
    get(options, providers) {
        return [
            ...super.get(options, providers),
            ...equalMatchersProviders,
            ...this.matchers,
            { provide: OBJECT_MATCHERS, useClass: DateMatcher, multi: true, deps: [] },
            { provide: OBJECT_MATCHERS, useExisting: MapMatcher, multi: true, deps: [] },
            { provide: OBJECT_MATCHERS, useExisting: IteratorMatcher, multi: true, deps: [] },
            { provide: OBJECT_MATCHERS, useExisting: POJOMatcher, multi: true, deps: [] },
        ];
    }
}

/**
 * @Hidden
 */
class MimicsRejectedAsyncPresetFactory {
    constructor(rootMock, presets, rejectedPromise) {
        this.rootMock = rootMock;
        this.presets = presets;
        this.rejectedPromise = rejectedPromise;
        return this.factory();
    }
    factory() {
        return (target, playable, value) => {
            const preset = new MimicsPreset(playable, target, this.rejectedPromise(value));
            this.presets.add(preset);
            return this.rootMock;
        };
    }
}

/**
 * @Hidden
 */
class MimicsResolvedAsyncPresetFactory {
    constructor(rootMock, presets, resolvedPromise) {
        this.rootMock = rootMock;
        this.presets = presets;
        this.resolvedPromise = resolvedPromise;
        return this.factory();
    }
    factory() {
        return (target, playable, value) => {
            const preset = new MimicsPreset(playable, target, this.resolvedPromise(value));
            this.presets.add(preset);
            return this.rootMock;
        };
    }
}

class MethodReflectingProxyFactory {
    constructor(injector) {
        this.injector = injector;
    }
    create() {
        const apply = this.injector.get(MethodReflectorTrap);
        const options = { apply };
        const reflector = function () {
            return undefined;
        };
        return new Proxy(reflector, options);
    }
}

/* eslint-disable */
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * @description
 *
 * Represents a type that a Component or other object is instances of.
 *
 * An example of a `Type` is `MyCustomComponent` class, which in JavaScript is be represented by
 * the `MyCustomComponent` constructor function.
 *
 * @publicApi
 */
const Type = Function;

/* eslint-disable */

/*
 * Public API Surface of moq.ts
*/

/**
 * Generated bundle index. Do not edit.
 */

export { APPLY_RETURN_VALUE, ApplyReflectorTrap, ApplyTrap, ArgumentsEqualityComparer, AsyncExpressionDetector, AsyncExpressionReflector, AsyncReflectingProxyInjectorFactory, AutoMockFactory, AutoMockInjectorConfig, AutoMockNameFormatter, AutoMockOptionsBuilder, AutoMockProvider, AutoMockedStorage, CONSTRUCT_RETURN_VALUE, CallCounter, CallbackPresetFactory, CallbackPresetPlayer, CallbacksPreset, CommonTypeProvider, ComplexExpressionErrorFormatter, ComplexExpressionGuard, ComplexExpressionValidator, CompositeExpressionReflector, ConstantEqualityComparer, ConstantFormatter, ConstructReflectorTrap, ConstructTrap, DateMatcher, DefaultInjectorConfig, EXPRESSIONS, EXPRESSION_REFLECTOR, EqualConstantMatcher, EqualMatcher, EqualMatchingInjectorConfig, Expression, ExpressionEqualityComparer, ExpressionFormatter, ExpressionGuardExceptionFactory, ExpressionHasMethodExplorer, ExpressionHasPropertyExplorer, ExpressionValidator, ExpressionsFormatter, FunctionExpression, FunctionExpressionValidator, FunctionFormatter, FunctionMatcher, GET_RETURN_VALUE, GetPropertyEqualityComparer, GetPropertyExpression, GetPropertyExpressionValidator, GetPropertyFormatter, GetPrototypeOfTrap, GetReflectorTrap, GetTrap, HasMethodExplorer, HasPropertyExplorer, HasReflectorTrap, HasTrap, Host, INJECTOR, INJECTOR_IMPL, InOperatorEqualityComparer, InOperatorExpression, InOperatorExpressionValidator, InOperatorFormatter, InOperatorInteractionExplorer, InjectFlags, InjectionToken, Injector, InstanceMethodEqualityComparer, InstanceMethodExpressionValidator, InteractionFormatter, InteractionPlayer, It, ItEqualityComparer, IterableTester, IteratorMatcher, MOCK, MOCK_CONSTRUCTOR, MOCK_OPTIONS, MapMatcher, MembersMethodExplorer, MembersPropertyExplorer, MethodEqualityComparer, MethodExpression, MethodFormatter, MethodOnlyReflectingProxyFactory, MethodReflectingProxyFactory, MethodReflectorTrap, MimicsPreset, MimicsPresetFactory, MimicsPresetPlayer, MimicsRejectedAsyncPresetFactory, MimicsResolvedAsyncPresetFactory, Mock, MockCore, MockOptionsBuilder, MoqAPI, NG_TEMP_TOKEN_PATH, NO_NEW_LINE, NamePrefixProvider, NewOperatorEqualityComparer, NewOperatorExpression, NewOperatorExpressionValidator, NewOperatorFormatter, NullInjector, OBJECT_MATCHERS, ObjectHasMethodExplorer, ObjectHasPropertyExplorer, ObjectMapProvider, ObjectMatcher, Optional, POJOMatcher, PlayTimes, PlayableAlways, PlayableExactly, PlayableNever, PlayableOnce, PlayablePresetProvider, PlayableSequence, PresetBuilder, PresetBuilderFactory, PresetHasInOperatorExplorer, PresetHasMethodExplorer, PresetHasPropertyExplorer, PresetPlayablesUpdater, PresetPlayer, Presets, PrimitiveMatcher, PropertiesValueStorage, PropertyDescriptorProvider, PropertyIsReadOnlyTester, PropertyKeyFormatter, PrototypeStorage, ProxyFactory, REFLECT_APPLY, REFLECT_HAS, ROOT_MOCK, Range, ReflectingProxyFactory, ReflectingProxyInjectorFactory, RejectedPromiseFactory, ResolvedPromiseFactory, ReturnsAsyncPresetFactory, ReturnsPreset, ReturnsPresetFactory, RootMockProvider, SOURCE, Self, SequenceId, SetPropertyEqualityComparer, SetPropertyExpression, SetPropertyExpressionValidator, SetPropertyFormatter, SetPrototypeOfTrap, SetReflectorTrap, SetTrap, SetupFactory, SkipSelf, SpyFunctionProvider, StaticInjector, StringErrorStyler, SyncExpressionReflector, THROW_IF_NOT_FOUND, ThrowsAsyncPresetFactory, ThrowsPreset, ThrowsPresetFactory, Times, TrackedExpressionsFormatter, Tracker, Type, TypesMatcher, USE_VALUE, VerificationTester, Verifier, VerifyError, VerifyFormatter, catchInjectorError, dump, formatError, forwardRef, getClosureSafeProperty, injectorFactory, isForwardRef, mockOptionsProviders, resolveForwardRef, stringify, ɵ1 };
//# sourceMappingURL=moq.ts.js.map
