(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define('moq.ts', ['exports'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory((global.moq = global.moq || {}, global.moq.ts = {})));
})(this, (function (exports) { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise */
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b)
                if (Object.prototype.hasOwnProperty.call(b, p))
                    d[p] = b[p]; };
        return extendStatics(d, b);
    };
    function __extends(d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    var __assign = function () {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s)
                    if (Object.prototype.hasOwnProperty.call(s, p))
                        t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };
    function __rest(s, e) {
        var t = {};
        for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
                t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }
    function __decorate(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
            r = Reflect.decorate(decorators, target, key, desc);
        else
            for (var i = decorators.length - 1; i >= 0; i--)
                if (d = decorators[i])
                    r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }
    function __param(paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); };
    }
    function __metadata(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
            return Reflect.metadata(metadataKey, metadataValue);
    }
    function __awaiter$1(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try {
                step(generator.next(value));
            }
            catch (e) {
                reject(e);
            } }
            function rejected(value) { try {
                step(generator["throw"](value));
            }
            catch (e) {
                reject(e);
            } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }
    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function () { if (t[0] & 1)
                throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function () { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f)
                throw new TypeError("Generator is already executing.");
            while (_)
                try {
                    if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                        return t;
                    if (y = 0, t)
                        op = [op[0] & 2, t.value];
                    switch (op[0]) {
                        case 0:
                        case 1:
                            t = op;
                            break;
                        case 4:
                            _.label++;
                            return { value: op[1], done: false };
                        case 5:
                            _.label++;
                            y = op[1];
                            op = [0];
                            continue;
                        case 7:
                            op = _.ops.pop();
                            _.trys.pop();
                            continue;
                        default:
                            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                                _ = 0;
                                continue;
                            }
                            if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) {
                                _.label = op[1];
                                break;
                            }
                            if (op[0] === 6 && _.label < t[1]) {
                                _.label = t[1];
                                t = op;
                                break;
                            }
                            if (t && _.label < t[2]) {
                                _.label = t[2];
                                _.ops.push(op);
                                break;
                            }
                            if (t[2])
                                _.ops.pop();
                            _.trys.pop();
                            continue;
                    }
                    op = body.call(thisArg, _);
                }
                catch (e) {
                    op = [6, e];
                    y = 0;
                }
                finally {
                    f = t = 0;
                }
            if (op[0] & 5)
                throw op[1];
            return { value: op[0] ? op[1] : void 0, done: true };
        }
    }
    var __createBinding = Object.create ? (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function () { return m[k]; } });
    }) : (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        o[k2] = m[k];
    });
    function __exportStar(m, o) {
        for (var p in m)
            if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
                __createBinding(o, m, p);
    }
    function __values(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m)
            return m.call(o);
        if (o && typeof o.length === "number")
            return {
                next: function () {
                    if (o && i >= o.length)
                        o = void 0;
                    return { value: o && o[i++], done: !o };
                }
            };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }
    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
            return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
                ar.push(r.value);
        }
        catch (error) {
            e = { error: error };
        }
        finally {
            try {
                if (r && !r.done && (m = i["return"]))
                    m.call(i);
            }
            finally {
                if (e)
                    throw e.error;
            }
        }
        return ar;
    }
    /** @deprecated */
    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }
    /** @deprecated */
    function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++)
            s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    }
    function __spreadArray(to, from, pack) {
        if (pack || arguments.length === 2)
            for (var i = 0, l = from.length, ar; i < l; i++) {
                if (ar || !(i in from)) {
                    if (!ar)
                        ar = Array.prototype.slice.call(from, 0, i);
                    ar[i] = from[i];
                }
            }
        return to.concat(ar || Array.prototype.slice.call(from));
    }
    function __await(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    }
    function __asyncGenerator(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n])
            i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try {
            step(g[n](v));
        }
        catch (e) {
            settle(q[0][3], e);
        } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length)
            resume(q[0][0], q[0][1]); }
    }
    function __asyncDelegator(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
    }
    function __asyncValues(o) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function (v) { resolve({ value: v, done: d }); }, reject); }
    }
    function __makeTemplateObject(cooked, raw) {
        if (Object.defineProperty) {
            Object.defineProperty(cooked, "raw", { value: raw });
        }
        else {
            cooked.raw = raw;
        }
        return cooked;
    }
    ;
    var __setModuleDefault = Object.create ? (function (o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function (o, v) {
        o["default"] = v;
    };
    function __importStar(mod) {
        if (mod && mod.__esModule)
            return mod;
        var result = {};
        if (mod != null)
            for (var k in mod)
                if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
                    __createBinding(result, mod, k);
        __setModuleDefault(result, mod);
        return result;
    }
    function __importDefault(mod) {
        return (mod && mod.__esModule) ? mod : { default: mod };
    }
    function __classPrivateFieldGet(receiver, state, kind, f) {
        if (kind === "a" && !f)
            throw new TypeError("Private accessor was defined without a getter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
            throw new TypeError("Cannot read private member from an object whose class did not declare it");
        return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    }
    function __classPrivateFieldSet(receiver, state, value, kind, f) {
        if (kind === "m")
            throw new TypeError("Private method is not writable");
        if (kind === "a" && !f)
            throw new TypeError("Private accessor was defined without a setter");
        if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
            throw new TypeError("Cannot write private member to an object whose class did not declare it");
        return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
    }

    /**
     * @hidden
     */
    var TrackedExpressionsFormatter = /** @class */ (function () {
        function TrackedExpressionsFormatter(interactionFormatter) {
            this.interactionFormatter = interactionFormatter;
        }
        TrackedExpressionsFormatter.prototype.format = function (trackedExpressions) {
            var e_1, _a;
            var result = "";
            try {
                for (var trackedExpressions_1 = __values(trackedExpressions), trackedExpressions_1_1 = trackedExpressions_1.next(); !trackedExpressions_1_1.done; trackedExpressions_1_1 = trackedExpressions_1.next()) {
                    var expression = trackedExpressions_1_1.value;
                    result += this.interactionFormatter.format(expression) + "\n";
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (trackedExpressions_1_1 && !trackedExpressions_1_1.done && (_a = trackedExpressions_1.return)) _a.call(trackedExpressions_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return result.substr(0, result.length - 1);
        };
        return TrackedExpressionsFormatter;
    }());

    /**
     * This function dumps into console.log all interactions with the mocked object
     */
    function dump(mock, writer) {
        if (writer === void 0) { writer = console; }
        var formatter = mock.resolve(TrackedExpressionsFormatter);
        var expressions = mock.tracker.get().map(function (record) { return record.expression; });
        var output = formatter.format(expressions);
        var delimiter = "-------------------------------";
        writer.log("Dump of " + (mock.name === undefined ? "noname mock" : mock.name));
        writer.log(delimiter);
        writer.log("\n" + output);
        writer.log(delimiter);
    }

    /**
     * Sets the rules where bounds of a range are included or excluded from the range.
     * See {@link Times.Between}
     */
    exports.Range = void 0;
    (function (Range) {
        Range[Range["Exclusive"] = 0] = "Exclusive";
        Range[Range["Inclusive"] = 1] = "Inclusive";
    })(exports.Range || (exports.Range = {}));
    /**
     * This class expresses the expectation about amount of invocations.
     *
     * @example
     * ```typescript
     *
     * const times = new Times(expected => expected === 1, `Should be called once`);
     * const actual = times.test(2);
     *
     * expect(actual).toBe(false);
     * expect(times.message).toBe(`Should be called once`);
     * ```
     *
     * ```typescript
     *
     * const mockName = 'mock name';
     *const mock = new Mock<ITestObject>(mockName);
     *const object = mock.object();
     *
     *object.property;
     *
     *const action = () => mock.verify(instance => instance.property, Times.AtLeast(2));
     *
     *expect(action).toThrow();
     * ```
     */
    var Times = /** @class */ (function () {
        /**
         *
         * @param evaluator It takes actual value and decides if it is expected or not.
         * Returns true or false accordingly.
         * @param message A message that describes the expectation.
         */
        function Times(evaluator, message) {
            this.evaluator = evaluator;
            this.message = message;
        }
        /**
         * It expects that the actual would be equal or bigger then the expected value.
         *
         * @param callCount The expected value.
         */
        Times.AtLeast = function (callCount) {
            return new Times(function (expected) { return expected >= callCount; }, "Should be called at least " + callCount + " time(s)");
        };
        /**
         * It expects that the actual would be equal or bigger then 1.
         */
        Times.AtLeastOnce = function () {
            return Times._atLeastOnce;
        };
        /**
         * It expects that the actual would be equal or smaller then the expected value.
         *
         * @param callCount The expected value.
         */
        Times.AtMost = function (callCount) {
            return new Times(function (expected) { return expected <= callCount; }, "Should be called at most " + callCount + " time(s)");
        };
        /**
         * It expects that the actual would be equal or less then 1.
         */
        Times.AtMostOnce = function () {
            return Times._atMostOnce;
        };
        /**
         * It expects that the actual would be in the expected range of values.
         *
         * @param callCountFrom The lowest bound of the range.
         * @param callCountTo The highest bound of the range.
         * @param range  Sets the rules where bounds of a range are included or excluded from the range.
         */
        Times.Between = function (callCountFrom, callCountTo, range) {
            if (range === exports.Range.Exclusive) {
                return new Times(function (expected) { return expected > callCountFrom && expected < callCountTo; }, "Should be called exclusively between " + callCountFrom + " and " + callCountTo);
            }
            return new Times(function (expected) { return expected >= callCountFrom && expected <= callCountTo; }, "Should be called inclusively between " + callCountFrom + " and " + callCountTo);
        };
        /**
         * It expects that the actual is equal to the expected value.
         *
         * @param callCount The expected value.
         */
        Times.Exactly = function (callCount) {
            return new Times(function (expected) { return expected === callCount; }, "Should be called exactly " + callCount + " time(s)");
        };
        /**
         * It expects that the actual is equal 0.
         */
        Times.Never = function () {
            return Times._never;
        };
        /**
         * It expects that the actual is equal 1.
         */
        Times.Once = function () {
            return Times._once;
        };
        /**
         * Evaluates the expectation against the actual value.
         *
         * @param callCount The actual value.
         */
        Times.prototype.test = function (callCount) {
            return this.evaluator(callCount);
        };
        return Times;
    }());
    Times._once = new Times(function (expected) { return expected === 1; }, "Should be called once");
    Times._never = new Times(function (expected) { return expected === 0; }, "Should be called never");
    Times._atMostOnce = new Times(function (expected) { return expected <= 1; }, "Should be called at most once");
    Times._atLeastOnce = new Times(function (expected) { return expected >= 1; }, "Should be called at least once");

    /* eslint-disable */
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    function stringify(token) {
        if (typeof token === "string") {
            return token;
        }
        if (Array.isArray(token)) {
            return "[" + token.map(stringify).join(", ") + "]";
        }
        if (token == null) {
            return "" + token;
        }
        if (token.overriddenName) {
            return "" + token.overriddenName;
        }
        if (token.name) {
            return "" + token.name;
        }
        var res = token.toString();
        if (res == null) {
            return "" + res;
        }
        var newLineIndex = res.indexOf("\n");
        return newLineIndex === -1 ? res : res.substring(0, newLineIndex);
    }

    /* eslint-disable */
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    function getClosureSafeProperty(objWithPropertyToExtract) {
        for (var key in objWithPropertyToExtract) {
            if (objWithPropertyToExtract[key] === getClosureSafeProperty) {
                return key;
            }
        }
        throw Error("Could not find renamed property on target object.");
    }

    /* eslint-disable */
    var __forward_ref__ = getClosureSafeProperty({ __forward_ref__: getClosureSafeProperty });
    /**
     * Allows to refer to references which are not yet defined.
     *
     * For instance, `forwardRef` is used when the `token` which we need to refer to for the purposes of
     * DI is declared, but not yet defined. It is also used when the `token` which we use when creating
     * a query is not yet defined.
     *
     * @usageNotes
     * ### Example
     * {@example core/di/ts/forward_ref/forward_ref_spec.ts region='forward_ref'}
     * @publicApi
     */
    function forwardRef(forwardRefFn) {
        forwardRefFn.__forward_ref__ = forwardRef;
        forwardRefFn.toString = function () {
            return stringify(this());
        };
        return forwardRefFn;
    }
    /**
     * Lazily retrieves the reference value from a forwardRef.
     *
     * Acts as the identity function when given a non-forward-ref value.
     *
     * @usageNotes
     * ### Example
     *
     * {@example core/di/ts/forward_ref/forward_ref_spec.ts region='resolve_forward_ref'}
     *
     * @see `forwardRef`
     * @publicApi
     */
    function resolveForwardRef(type) {
        return isForwardRef(type) ? type() : type;
    }
    /** Checks whether a function is wrapped by a `forwardRef`. */
    function isForwardRef(fn) {
        return typeof fn === "function" && fn.hasOwnProperty(__forward_ref__) &&
            fn.__forward_ref__ === forwardRef;
    }

    /* eslint-disable */
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    var InjectionToken = /** @class */ (function () {
        function InjectionToken(desc) {
            this.desc = desc;
        }
        InjectionToken.prototype.toString = function () {
            return "InjectionToken " + this.desc;
        };
        return InjectionToken;
    }());

    /* eslint-disable */
    /**
     * An InjectionToken that gets the current `Injector` for `createInjector()`-style injectors.
     *
     * Requesting this token instead of `Injector` allows `StaticInjector` to be tree-shaken from a
     * project.
     *
     * @publicApi
     */
    var INJECTOR = new InjectionToken("INJECTOR");
    var _THROW_IF_NOT_FOUND = {};
    var THROW_IF_NOT_FOUND = _THROW_IF_NOT_FOUND;
    var NG_TEMP_TOKEN_PATH = "ngTempTokenPath";
    var NG_TOKEN_PATH = "ngTokenPath";
    var NEW_LINE = /\n/gm;
    var NO_NEW_LINE = "ɵ";
    var SOURCE = "__source";
    var ɵ0$1 = getClosureSafeProperty;
    var USE_VALUE = getClosureSafeProperty({ provide: String, useValue: ɵ0$1 });
    var NullInjector = /** @class */ (function () {
        function NullInjector() {
        }
        NullInjector.prototype.get = function (token, notFoundValue) {
            if (notFoundValue === void 0) { notFoundValue = THROW_IF_NOT_FOUND; }
            if (notFoundValue === THROW_IF_NOT_FOUND) {
                var error = new Error("NullInjectorError: No provider for " + stringify(token) + "!");
                error.name = "NullInjectorError";
                throw error;
            }
            return notFoundValue;
        };
        return NullInjector;
    }());
    function catchInjectorError(e, token, injectorErrorName, source) {
        var tokenPath = e[NG_TEMP_TOKEN_PATH];
        if (token[SOURCE]) {
            tokenPath.unshift(token[SOURCE]);
        }
        e.message = formatError("\n" + e.message, tokenPath, injectorErrorName, source);
        e[NG_TOKEN_PATH] = tokenPath;
        e[NG_TEMP_TOKEN_PATH] = null;
        throw e;
    }
    function formatError(text, obj, injectorErrorName, source) {
        if (source === void 0) { source = null; }
        text = text && text.charAt(0) === "\n" && text.charAt(1) === NO_NEW_LINE ? text.substr(2) : text;
        var context = stringify(obj);
        if (Array.isArray(obj)) {
            context = obj.map(stringify).join(" -> ");
        }
        else if (typeof obj === "object") {
            var parts = [];
            for (var key in obj) {
                if (obj.hasOwnProperty(key)) {
                    var value = obj[key];
                    parts.push(key + ":" + (typeof value === "string" ? JSON.stringify(value) : stringify(value)));
                }
            }
            context = "{" + parts.join(", ") + "}";
        }
        return "" + injectorErrorName + (source ? "(" + source + ")" : "") + "[" + context + "]: " + text.replace(NEW_LINE, "\n  ");
    }

    /* eslint-disable */
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Injection flags for DI.
     *
     * @publicApi
     */
    exports.InjectFlags = void 0;
    (function (InjectFlags) {
        // TODO(alxhub): make this 'const' when ngc no longer writes exports of it into ngfactory files.
        /** Check self and check parent injector if needed */
        InjectFlags[InjectFlags["Default"] = 0] = "Default";
        /**
         * Specifies that an injector should retrieve a dependency from any injector until reaching the
         * host element of the current component. (Only used with Element Injector)
         */
        InjectFlags[InjectFlags["Host"] = 1] = "Host";
        /** Don't ascend to ancestors of the node requesting injection. */
        InjectFlags[InjectFlags["Self"] = 2] = "Self";
        /** Skip the node that is requesting injection. */
        InjectFlags[InjectFlags["SkipSelf"] = 4] = "SkipSelf";
        /** Inject `defaultValue` instead if token not found. */
        InjectFlags[InjectFlags["Optional"] = 8] = "Optional";
    })(exports.InjectFlags || (exports.InjectFlags = {}));

    /* eslint-disable */
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * Type of the Optional metadata.
     */
    var Optional = /** @class */ (function () {
        function Optional() {
        }
        return Optional;
    }());
    /**
     * Type of the Self metadata.
     */
    var Self = /** @class */ (function () {
        function Self() {
        }
        return Self;
    }());
    /**
     * Type of the SkipSelf metadata.
     */
    var SkipSelf = /** @class */ (function () {
        function SkipSelf() {
        }
        return SkipSelf;
    }());
    /**
     * Type of the Host metadata.
     */
    var Host = /** @class */ (function () {
        function Host() {
        }
        return Host;
    }());

    var INJECTOR_IMPL = function (providers, parent, name) { return new StaticInjector(providers, parent, name); };
    /**
     * Concrete injectors implement this interface. Injectors are configured
     * with [providers](guide/glossary#provider) that associate
     * dependencies of various types with [injection tokens](guide/glossary#di-token).
     *
     * @see ["DI Providers"](guide/dependency-injection-providers).
     * @see `StaticProvider`
     *
     * @usageNotes
     *
     *  The following example creates a service injector instance.
     *
     * {@example core/di/ts/provider_spec.ts region='ConstructorProvider'}
     *
     * ### Usage example
     *
     * {@example core/di/ts/injector_spec.ts region='Injector'}
     *
     * `Injector` returns itself when given `Injector` as a token:
     *
     * {@example core/di/ts/injector_spec.ts region='injectInjector'}
     *
     * @publicApi
     */
    var Injector = /** @class */ (function () {
        function Injector() {
        }
        Injector.create = function (options, parent) {
            if (Array.isArray(options)) {
                return INJECTOR_IMPL(options, parent, "");
            }
            else {
                return INJECTOR_IMPL(options.providers, options.parent, options.name || "");
            }
        };
        return Injector;
    }());
    Injector.THROW_IF_NOT_FOUND = THROW_IF_NOT_FOUND;
    Injector.NULL = new NullInjector();
    /**
     * @internal
     * @nocollapse
     */
    Injector.__NG_ELEMENT_ID__ = -1;
    var IDENT = function (value) {
        return value;
    };
    var ɵ0 = IDENT;
    var EMPTY = [];
    var CIRCULAR = IDENT;
    var MULTI_PROVIDER_FN = function () {
        return Array.prototype.slice.call(arguments);
    };
    var ɵ1 = MULTI_PROVIDER_FN;
    var StaticInjector = /** @class */ (function () {
        function StaticInjector(providers, parent, source) {
            if (parent === void 0) { parent = new NullInjector(); }
            if (source === void 0) { source = null; }
            this.parent = parent;
            this.source = source;
            var records = this._records = new Map();
            records.set(Injector, { token: Injector, fn: IDENT, deps: EMPTY, value: this, useNew: false });
            records.set(INJECTOR, { token: INJECTOR, fn: IDENT, deps: EMPTY, value: this, useNew: false });
            this.scope = recursivelyProcessProviders(records, providers);
        }
        StaticInjector.prototype.get = function (token, notFoundValue, flags) {
            if (flags === void 0) { flags = exports.InjectFlags.Default; }
            var records = this._records;
            var record = records.get(token);
            if (record === undefined) {
                records.set(token, null);
            }
            try {
                return tryResolveToken(token, record, records, this.parent, notFoundValue, flags);
            }
            catch (e) {
                return catchInjectorError(e, token, "StaticInjectorError", this.source);
            }
        };
        StaticInjector.prototype.toString = function () {
            var tokens = [];
            var records = this._records;
            records.forEach(function (v, token) { return tokens.push(stringify(token)); });
            return "StaticInjector[" + tokens.join(", ") + "]";
        };
        return StaticInjector;
    }());
    function resolveProvider(provider) {
        var deps = computeDeps(provider);
        var fn = IDENT;
        var value = EMPTY;
        var useNew = false;
        var provide = resolveForwardRef(provider.provide);
        if (USE_VALUE in provider) {
            // We need to use USE_VALUE in provider since provider.useValue could be defined as undefined.
            value = provider.useValue;
        }
        else if (provider.useFactory) {
            fn = provider.useFactory;
        }
        else if (provider.useExisting) {
            // Just use IDENT
        }
        else if (provider.useClass) {
            useNew = true;
            fn = resolveForwardRef(provider.useClass);
        }
        else if (typeof provide === "function") {
            useNew = true;
            fn = provide;
        }
        else {
            throw staticError("StaticProvider does not have [useValue|useFactory|useExisting|useClass] or [provide] is not newable", provider);
        }
        return { deps: deps, fn: fn, useNew: useNew, value: value };
    }
    function multiProviderMixError(token) {
        return staticError("Cannot mix multi providers and regular providers", token);
    }
    function recursivelyProcessProviders(records, provider) {
        var scope = null;
        if (provider) {
            provider = resolveForwardRef(provider);
            if (Array.isArray(provider)) {
                // if we have an array recurse into the array
                for (var i = 0; i < provider.length; i++) {
                    scope = recursivelyProcessProviders(records, provider[i]) || scope;
                }
            }
            else if (typeof provider === "function") {
                // Functions were supported in ReflectiveInjector, but are not here. For safety give useful
                // error messages
                throw staticError("Function/Class not supported", provider);
            }
            else if (provider && typeof provider === "object" && provider.provide) {
                // At this point we have what looks like a provider: {provide: ?, ....}
                var token = resolveForwardRef(provider.provide);
                var resolvedProvider = resolveProvider(provider);
                if (provider.multi === true) {
                    // This is a multi provider.
                    var multiProvider = records.get(token);
                    if (multiProvider) {
                        if (multiProvider.fn !== MULTI_PROVIDER_FN) {
                            throw multiProviderMixError(token);
                        }
                    }
                    else {
                        // Create a placeholder factory which will look up the constituents of the multi provider.
                        records.set(token, multiProvider = {
                            token: provider.provide,
                            deps: [],
                            useNew: false,
                            fn: MULTI_PROVIDER_FN,
                            value: EMPTY
                        });
                    }
                    // Treat the provider as the token.
                    token = provider;
                    multiProvider.deps.push({ token: token, options: 6 /* Default */ });
                }
                var record = records.get(token);
                if (record && record.fn === MULTI_PROVIDER_FN) {
                    throw multiProviderMixError(token);
                }
                records.set(token, resolvedProvider);
            }
            else {
                throw staticError("Unexpected provider", provider);
            }
        }
        return scope;
    }
    function tryResolveToken(token, record, records, parent, notFoundValue, flags) {
        try {
            return resolveToken(token, record, records, parent, notFoundValue, flags);
        }
        catch (e) {
            // ensure that 'e' is of type Error.
            if (!(e instanceof Error)) {
                e = new Error(e);
            }
            var path = e[NG_TEMP_TOKEN_PATH] = e[NG_TEMP_TOKEN_PATH] || [];
            path.unshift(token);
            if (record && record.value === CIRCULAR) {
                // Reset the Circular flag.
                record.value = EMPTY;
            }
            throw e;
        }
    }
    function resolveToken(token, record, records, parent, notFoundValue, flags) {
        var value;
        // eslint-disable-next-line no-bitwise
        if (record && !(flags & exports.InjectFlags.SkipSelf)) {
            // If we don't have a record, this implies that we don't own the provider hence don't know how
            // to resolve it.
            value = record.value;
            if (value === CIRCULAR) {
                throw Error(NO_NEW_LINE + "Circular dependency");
            }
            else if (value === EMPTY) {
                record.value = CIRCULAR;
                var useNew = record.useNew, fn = record.fn, depRecords = record.deps;
                var deps = EMPTY;
                if (depRecords.length) {
                    deps = [];
                    for (var i = 0; i < depRecords.length; i++) {
                        var depRecord = depRecords[i];
                        var options = depRecord.options;
                        // eslint-disable-next-line no-bitwise
                        var childRecord = options & 2 /* CheckSelf */ ? records.get(depRecord.token) : undefined;
                        deps.push(tryResolveToken(
                        // Current Token to resolve
                        depRecord.token, 
                        // A record which describes how to resolve the token.
                        // If undefined, this means we don't have such a record
                        childRecord, 
                        // Other records we know about.
                        records, 
                        // If we don't know how to resolve dependency and we should not check parent for it,
                        // than pass in Null injector.
                        // eslint-disable-next-line no-bitwise
                        !childRecord && !(options & 4 /* CheckParent */) ? Injector.NULL : parent, 
                        // eslint-disable-next-line no-bitwise
                        options & 1 /* Optional */ ? null : Injector.THROW_IF_NOT_FOUND, exports.InjectFlags.Default));
                    }
                }
                record.value = value = useNew ? new (fn.bind.apply(fn, __spread([void 0], deps)))() : fn.apply(undefined, deps);
            }
            // eslint-disable-next-line no-bitwise
        }
        else if (!(flags & exports.InjectFlags.Self)) {
            value = parent.get(token, notFoundValue, exports.InjectFlags.Default);
            // eslint-disable-next-line no-bitwise
        }
        else if (!(flags & exports.InjectFlags.Optional)) {
            value = Injector.NULL.get(token, notFoundValue);
        }
        else {
            value = Injector.NULL.get(token, typeof notFoundValue !== "undefined" ? notFoundValue : null);
        }
        return value;
    }
    function computeDeps(provider) {
        var deps = EMPTY;
        var providerDeps = provider.deps;
        if (providerDeps && providerDeps.length) {
            deps = [];
            for (var i = 0; i < providerDeps.length; i++) {
                var options = 6 /* Default */;
                var token = resolveForwardRef(providerDeps[i]);
                if (Array.isArray(token)) {
                    for (var j = 0, annotations = token; j < annotations.length; j++) {
                        var annotation = annotations[j];
                        if (annotation instanceof Optional || annotation === Optional) {
                            // eslint-disable-next-line no-bitwise
                            options = options | 1 /* Optional */;
                        }
                        else if (annotation instanceof SkipSelf || annotation === SkipSelf) {
                            // eslint-disable-next-line no-bitwise
                            options = options & ~2 /* CheckSelf */;
                        }
                        else if (annotation instanceof Self || annotation === Self) {
                            // eslint-disable-next-line no-bitwise
                            options = options & ~4 /* CheckParent */;
                        }
                        else {
                            token = resolveForwardRef(annotation);
                        }
                    }
                }
                deps.push({ token: token, options: options });
            }
        }
        else if (provider.useExisting) {
            var token = resolveForwardRef(provider.useExisting);
            deps = [{ token: token, options: 6 /* Default */ }];
        }
        else if (!providerDeps && !(USE_VALUE in provider)) {
            // useValue & useExisting are the only ones which are exempt from deps all others need it.
            throw staticError("'deps' required", provider);
        }
        return deps;
    }
    function staticError(text, obj) {
        return new Error(formatError(text, obj, "StaticInjectorError"));
    }

    /**
     * Creates an angular based injector
     */
    function injectorFactory(options) {
        var providers = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            providers[_i - 1] = arguments[_i];
        }
        var injectorConfig = options.injectorConfig;
        if (injectorConfig) {
            var resolved = injectorConfig.get(options, providers);
            return Injector.create({
                providers: resolved
            });
        }
        throw new Error("injectorConfig is not defined");
    }

    /**
     * @Hidden
     */
    var MOCK = new InjectionToken("IMock");

    /**
     * @hidden
     */
    var SequenceId = /** @class */ (function () {
        function SequenceId() {
            this.value = 0;
        }
        SequenceId.prototype.next = function () {
            return this.value++;
        };
        return SequenceId;
    }());

    /**
     * This class records all interactions with a mocked object.
     */
    var Tracker = /** @class */ (function () {
        function Tracker(sequenceId) {
            this.sequenceId = sequenceId;
            this.log = [];
        }
        /**
         * @hidden
         */
        Tracker.prototype.add = function (action) {
            var record = { id: this.sequenceId.next(), expression: action };
            this.log.push(record);
        };
        /**
         * Returns recorded interactions.
         */
        Tracker.prototype.get = function () {
            return __spread(this.log);
        };
        Tracker.prototype.interactions = function () {
            return this.get().map(function (record) { return record.expression; });
        };
        return Tracker;
    }());

    /**
     * @hidden
     */
    var trackerProviders = [
        { provide: SequenceId, useClass: SequenceId, deps: [] },
        { provide: Tracker, useClass: Tracker, deps: [SequenceId] }
    ];

    /**
     * Injection token for an expression reflector
     */
    var EXPRESSION_REFLECTOR = new InjectionToken("Expression reflector");
    /**
     * @hidden
     */
    var EXPRESSIONS = new InjectionToken("reflected expressions");
    /**
     * @hidden
     */
    var GET_RETURN_VALUE = new InjectionToken("return value factory for the get trap");
    /**
     * @hidden
     */
    var APPLY_RETURN_VALUE = new InjectionToken("return value factory for the apply trap");
    /**
     * @hidden
     */
    var CONSTRUCT_RETURN_VALUE = new InjectionToken("return value factory for the construct trap");

    var Expression = /** @class */ (function () {
        function Expression(name, args) {
            this.name = name;
            this.args = args;
        }
        return Expression;
    }());
    /**
     * This class represents an invocation of an instance method.
     * It provides access to the name of it and the parameters.
     */
    var MethodExpression = /** @class */ (function (_super) {
        __extends(MethodExpression, _super);
        function MethodExpression(name, args) {
            return _super.call(this, name, args) || this;
        }
        return MethodExpression;
    }(Expression));
    /**
     * This class represents an invocation of a function.
     * It provides access to the parameters.
     */
    var FunctionExpression = /** @class */ (function (_super) {
        __extends(FunctionExpression, _super);
        function FunctionExpression(args) {
            return _super.call(this, undefined, args) || this;
        }
        return FunctionExpression;
    }(Expression));
    /**
     * This class represents a property accessing.
     * It provides access to the name of property.
     */
    var GetPropertyExpression = /** @class */ (function (_super) {
        __extends(GetPropertyExpression, _super);
        function GetPropertyExpression(name) {
            return _super.call(this, name, undefined) || this;
        }
        return GetPropertyExpression;
    }(Expression));
    /**
     * This class represents a property write interaction.
     * It provides access to the name of property and the value.
     */
    var SetPropertyExpression = /** @class */ (function (_super) {
        __extends(SetPropertyExpression, _super);
        function SetPropertyExpression(name, value) {
            var _this = _super.call(this, name, [value]) || this;
            _this.value = value;
            return _this;
        }
        return SetPropertyExpression;
    }(Expression));
    /**
     * This class represents applying of [in operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/in).
     * It provides access to the name of property.
     */
    var InOperatorExpression = /** @class */ (function (_super) {
        __extends(InOperatorExpression, _super);
        function InOperatorExpression(name) {
            return _super.call(this, name, undefined) || this;
        }
        return InOperatorExpression;
    }(Expression));
    /**
     * This class represents applying of [new operator](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new).
     * It provides access to the arguments of the constructor.
     */
    var NewOperatorExpression = /** @class */ (function (_super) {
        __extends(NewOperatorExpression, _super);
        function NewOperatorExpression(args) {
            return _super.call(this, undefined, args) || this;
        }
        return NewOperatorExpression;
    }(Expression));

    var GetReflectorTrap = /** @class */ (function () {
        function GetReflectorTrap(returnValueFactory, expressions) {
            this.returnValueFactory = returnValueFactory;
            this.expressions = expressions;
            return this.factory();
        }
        GetReflectorTrap.prototype.factory = function () {
            var _this = this;
            return function (target, name) {
                _this.expressions.push(new GetPropertyExpression(name));
                return _this.returnValueFactory.create();
            };
        };
        return GetReflectorTrap;
    }());

    var SetReflectorTrap = /** @class */ (function () {
        function SetReflectorTrap(expressions) {
            this.expressions = expressions;
            return this.factory();
        }
        SetReflectorTrap.prototype.factory = function () {
            var _this = this;
            return function (target, name, value) {
                _this.expressions.push(new SetPropertyExpression(name, value));
                return true;
            };
        };
        return SetReflectorTrap;
    }());

    var ApplyReflectorTrap = /** @class */ (function () {
        function ApplyReflectorTrap(returnValueFactory, expressions) {
            this.returnValueFactory = returnValueFactory;
            this.expressions = expressions;
            return this.factory();
        }
        ApplyReflectorTrap.prototype.factory = function () {
            var _this = this;
            return function (target, thisArg, args) {
                var last = _this.expressions.pop();
                if (last instanceof GetPropertyExpression) {
                    _this.expressions.push(new MethodExpression(last.name, args));
                }
                else {
                    if (last !== undefined) {
                        _this.expressions.push(last);
                    }
                    _this.expressions.push(new FunctionExpression(args));
                }
                return _this.returnValueFactory.create();
            };
        };
        return ApplyReflectorTrap;
    }());

    var HasReflectorTrap = /** @class */ (function () {
        function HasReflectorTrap(expressions) {
            this.expressions = expressions;
            return this.factory();
        }
        HasReflectorTrap.prototype.factory = function () {
            var _this = this;
            return function (target, name) {
                _this.expressions.push(new InOperatorExpression(name));
                return true;
            };
        };
        return HasReflectorTrap;
    }());

    var ConstructReflectorTrap = /** @class */ (function () {
        function ConstructReflectorTrap(returnValueFactory, expressions) {
            this.returnValueFactory = returnValueFactory;
            this.expressions = expressions;
            return this.factory();
        }
        ConstructReflectorTrap.prototype.factory = function () {
            var _this = this;
            return function (target, args) {
                _this.expressions.push(new NewOperatorExpression(args));
                return _this.returnValueFactory.create();
            };
        };
        return ConstructReflectorTrap;
    }());

    var ReflectingProxyFactory = /** @class */ (function () {
        function ReflectingProxyFactory(injector) {
            this.injector = injector;
        }
        ReflectingProxyFactory.prototype.create = function () {
            var get = this.injector.get(GetReflectorTrap);
            var set = this.injector.get(SetReflectorTrap);
            var apply = this.injector.get(ApplyReflectorTrap);
            var has = this.injector.get(HasReflectorTrap);
            var construct = this.injector.get(ConstructReflectorTrap);
            var options = { get: get, set: set, apply: apply, has: has, construct: construct };
            var reflector = function () {
                return undefined;
            };
            return new Proxy(reflector, options);
        };
        return ReflectingProxyFactory;
    }());

    var ReflectingProxyInjectorFactory = /** @class */ (function () {
        function ReflectingProxyInjectorFactory() {
        }
        ReflectingProxyInjectorFactory.prototype.create = function (options) {
            if (options === void 0) { options = { providers: [] }; }
            var providers = __spread([
                { provide: EXPRESSIONS, useValue: [], deps: [] },
                { provide: ReflectingProxyFactory, useClass: ReflectingProxyFactory, deps: [Injector] },
                { provide: GetReflectorTrap, useClass: GetReflectorTrap, deps: [GET_RETURN_VALUE, EXPRESSIONS] },
                { provide: GET_RETURN_VALUE, useExisting: ReflectingProxyFactory, deps: [] },
                { provide: SetReflectorTrap, useClass: SetReflectorTrap, deps: [EXPRESSIONS] },
                { provide: ApplyReflectorTrap, useClass: ApplyReflectorTrap, deps: [APPLY_RETURN_VALUE, EXPRESSIONS] },
                { provide: APPLY_RETURN_VALUE, useExisting: ReflectingProxyFactory, deps: [] },
                { provide: HasReflectorTrap, useClass: HasReflectorTrap, deps: [EXPRESSIONS] },
                {
                    provide: ConstructReflectorTrap,
                    useClass: ConstructReflectorTrap,
                    deps: [CONSTRUCT_RETURN_VALUE, EXPRESSIONS]
                },
                { provide: CONSTRUCT_RETURN_VALUE, useExisting: ReflectingProxyFactory, deps: [] }
            ], options.providers);
            return Injector.create({ providers: providers });
        };
        return ReflectingProxyInjectorFactory;
    }());

    /**
     * This class allows to express wide range of cases in an expression.
     * You can use it with setups or verifies methods.
     *
     * @example
     * ```typescript
     *
     *  const value = 'value';
     *  const object = new Mock<Function>()
     *  .setup(instance => instance(1))
     *  .returns(value)
     *  .setup(instance => instance(It.Is(param => param > 0 && param < 2))
     *  .returns(value)
     *  .setup(instance => instance(It.IsAny())
     *  .returns(value)
     *  .object();
     *
     *  const actual = object(1);
     *
     *  expect(actual).toBe(value);
     * ```
     *
     * This class could be used not only for args matching, but also for function names, property names and so on.
     *
     * @example
     * ```typescript
     *
     * const object = new Mock<ITestObject>()
     * // the expression dynamically checks the property name that is being read
     * .setup(instance => It.Is((expression: GetPropertyExpression) => expression.name === 'property'))
     * .returns(value)
     * .object();
     *
     * const object = new Mock<ITestObject>()
     * //denis any write operation on the property
     * .setup(instance => { instance.property = It.IsAny()})
     * // true - allow, false - deny
     * .returns(false)
     * .object();
     *
     * const object = new Mock<ITestObject>()
     * .setup(instance => It.Is((expression: NamedMethodExpression) => expression.name === 'methodName' && expression.args[0] === 1))
     * .returns(value)
     * .object();
     *
     * // how to use with verify
     * mock.verify(instance => instance.method(It.Is(a => a === 2)));
     * ```
     */
    var It = /** @class */ (function () {
        function It(predicate) {
            this.predicate = predicate;
        }
        /**
         * This factory method returns an expression that matches custom cases.
         *
         * @example
         * ```typescript
         *
         *  const value = 'value';
         *  const object = new Mock<Function>()
         *  .setup(instance => instance(It.Is(param => param > 0 && param < 2))
         *  .returns(value)
         *  .object();
         *
         *  const actual = object(only_values_between_0_and_2_will_trigger_the_setup);
         *
         *  expect(actual).toBe(value);
         * ```
         */
        It.Is = function (predicate) {
            return new It(predicate);
        };
        /**
         * This factory method returns a wildcat expression that matches any value.
         *
         * @example
         * ```typescript
         *
         *  const value = 'value';
         *  const object = new Mock<Function>()
         *  .setup(instance => instance(It.IsAny())
         *  .returns(value)
         *  .object();
         *
         *  const actual = object(any_value_will_trigger_the_setup);
         *
         *  expect(actual).toBe(value);
         * ```
         */
        It.IsAny = function () {
            return new It(It.isAnyPredicate);
        };
        /**
         * Exams if the instance matches the predicate.
         */
        It.prototype.test = function (instance) {
            try {
                var result = this.predicate(instance);
                return result === true || result === undefined;
            }
            catch (e) {
                return false;
            }
        };
        return It;
    }());
    It.isAnyPredicate = function () { return true; };

    var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try {
                step(generator.next(value));
            }
            catch (e) {
                reject(e);
            } }
            function rejected(value) { try {
                step(generator["throw"](value));
            }
            catch (e) {
                reject(e);
            } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };
    /**
     * This class reflects an expression to an expression tree representation.
     * async/await is not supported.
     *
     * For more examples check
     * [unit tests for this class]
     * (https://github.com/dvabuzyarov/moq.ts/blob/master/projects/moq/src/lib/reflector/full.expression-reflector.spec.ts)
     */
    var SyncExpressionReflector = /** @class */ (function () {
        function SyncExpressionReflector(injectorFactory) {
            this.injectorFactory = injectorFactory;
        }
        /**
         * Reflects the provided code as an expression tree.
         */
        SyncExpressionReflector.prototype.reflect = function (expression) {
            if (expression instanceof It) {
                return [expression];
            }
            var injector = this.injectorFactory.create();
            var proxyFactory = injector.get(ReflectingProxyFactory);
            var proxy = proxyFactory.create();
            var predicate = expression(proxy);
            var expressions = injector.get(EXPRESSIONS);
            return predicate instanceof It && expressions.length === 0
                ? [predicate] : expressions;
        };
        SyncExpressionReflector.prototype.reflectAsync = function (expression) {
            return __awaiter(this, void 0, void 0, function () {
                var injector, proxyFactory, proxy, predicate, expressions;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (expression instanceof It) {
                                return [2 /*return*/, [expression]];
                            }
                            injector = this.injectorFactory.create();
                            proxyFactory = injector.get(ReflectingProxyFactory);
                            proxy = proxyFactory.create();
                            return [4 /*yield*/, expression(proxy)];
                        case 1:
                            predicate = _a.sent();
                            expressions = injector.get(EXPRESSIONS);
                            return [2 /*return*/, predicate instanceof It && expressions.length === 0
                                    ? [predicate] : expressions];
                    }
                });
            });
        };
        return SyncExpressionReflector;
    }());

    /**
     * This class reflects an expression to an expression tree representation.
     * async/await expressions are reflected in shellow mode.
     *
     * For more examples check
     * [unit tests for this class]
     * (https://github.com/dvabuzyarov/moq.ts/blob/master/projects/moq/src/lib/reflector/full.expression-reflector.spec.ts)
     */
    var CompositeExpressionReflector = /** @class */ (function () {
        function CompositeExpressionReflector(asyncExpressionDetector, syncExpressionReflector, asyncExpressionReflector) {
            this.asyncExpressionDetector = asyncExpressionDetector;
            this.syncExpressionReflector = syncExpressionReflector;
            this.asyncExpressionReflector = asyncExpressionReflector;
        }
        /**
         * Reflects the provided code as an expression tree.
         */
        CompositeExpressionReflector.prototype.reflect = function (expression) {
            return this.asyncExpressionDetector.isAsync(expression)
                ? this.asyncExpressionReflector.reflect(expression)
                : this.syncExpressionReflector.reflect(expression);
        };
        return CompositeExpressionReflector;
    }());

    var AsyncExpressionDetector = /** @class */ (function () {
        function AsyncExpressionDetector() {
        }
        AsyncExpressionDetector.prototype.isAsync = function (expression) {
            if (expression instanceof It) {
                return false;
            }
            var get = function () { return proxy; };
            var set = function () { return true; };
            var apply = function () { return proxy; };
            var has = function () { return false; };
            var construct = function () { return proxy; };
            var options = { get: get, set: set, apply: apply, has: has, construct: construct };
            var reflector = function () {
                return undefined;
            };
            var proxy = new Proxy(reflector, options);
            var predicate = expression(proxy);
            return predicate instanceof It ? false : predicate instanceof Promise;
        };
        return AsyncExpressionDetector;
    }());

    /**
     * This class reflects an async expression to an expression tree representation.
     * For more examples check
     * [unit tests for this class]
     * (https://github.com/dvabuzyarov/moq.ts/blob/master/projects/moq/src/lib/reflector/async.expression-reflector.spec.ts)
     */
    var AsyncExpressionReflector = /** @class */ (function () {
        function AsyncExpressionReflector(injectorFactory) {
            this.injectorFactory = injectorFactory;
        }
        /**
         * Reflects the provided async code as an expression tree.
         */
        AsyncExpressionReflector.prototype.reflect = function (expression) {
            var injector = this.injectorFactory.create();
            var proxyFactory = injector.get(ReflectingProxyFactory);
            var proxy = proxyFactory.create();
            expression(proxy);
            return injector.get(EXPRESSIONS);
        };
        return AsyncExpressionReflector;
    }());

    var MethodReflectorTrap = /** @class */ (function () {
        function MethodReflectorTrap(expressions) {
            this.expressions = expressions;
            return this.factory();
        }
        MethodReflectorTrap.prototype.factory = function () {
            var _this = this;
            return function (target, thisArg, args) {
                var last = _this.expressions.pop();
                if (last instanceof GetPropertyExpression) {
                    _this.expressions.push(new MethodExpression(last.name, args));
                }
                else {
                    if (last !== undefined) {
                        _this.expressions.push(last);
                    }
                }
                return undefined;
            };
        };
        return MethodReflectorTrap;
    }());

    var MethodOnlyReflectingProxyFactory = /** @class */ (function () {
        function MethodOnlyReflectingProxyFactory(injector) {
            this.injector = injector;
        }
        MethodOnlyReflectingProxyFactory.prototype.create = function () {
            var apply = this.injector.get(MethodReflectorTrap);
            var options = { apply: apply };
            var reflector = function () {
                return undefined;
            };
            return new Proxy(reflector, options);
        };
        return MethodOnlyReflectingProxyFactory;
    }());

    var AsyncReflectingProxyInjectorFactory = /** @class */ (function () {
        function AsyncReflectingProxyInjectorFactory(reflectingProxyInjectorFactory) {
            this.reflectingProxyInjectorFactory = reflectingProxyInjectorFactory;
        }
        AsyncReflectingProxyInjectorFactory.prototype.create = function (options) {
            if (options === void 0) { options = { providers: [] }; }
            var providers = __spread([
                { provide: GET_RETURN_VALUE, useExisting: MethodOnlyReflectingProxyFactory, deps: [] },
                { provide: MethodOnlyReflectingProxyFactory, useClass: MethodOnlyReflectingProxyFactory, deps: [Injector] },
                { provide: APPLY_RETURN_VALUE, useValue: { create: function () { return ({}); } }, deps: [] },
                { provide: CONSTRUCT_RETURN_VALUE, useValue: { create: function () { return ({}); } }, deps: [] },
                { provide: MethodReflectorTrap, useClass: MethodReflectorTrap, deps: [EXPRESSIONS] }
            ], options.providers);
            return this.reflectingProxyInjectorFactory.create({ providers: providers });
        };
        return AsyncReflectingProxyInjectorFactory;
    }());

    /**
     * @hidden
     */
    var reflectorProviders = [
        { provide: EXPRESSION_REFLECTOR, useExisting: CompositeExpressionReflector, deps: [] },
        {
            provide: CompositeExpressionReflector,
            useClass: CompositeExpressionReflector,
            deps: [AsyncExpressionDetector, SyncExpressionReflector, AsyncExpressionReflector]
        },
        { provide: AsyncExpressionDetector, useClass: AsyncExpressionDetector, deps: [] },
        { provide: ReflectingProxyInjectorFactory, useClass: ReflectingProxyInjectorFactory, deps: [] },
        { provide: SyncExpressionReflector, useClass: SyncExpressionReflector, deps: [ReflectingProxyInjectorFactory] },
        {
            provide: AsyncReflectingProxyInjectorFactory,
            useClass: AsyncReflectingProxyInjectorFactory,
            deps: [ReflectingProxyInjectorFactory]
        },
        {
            provide: AsyncExpressionReflector,
            useClass: AsyncExpressionReflector,
            deps: [AsyncReflectingProxyInjectorFactory]
        },
    ];

    /**
     * @hidden
     */
    var Presets = /** @class */ (function () {
        function Presets() {
            this.presets = [];
        }
        Presets.prototype.add = function (preset) {
            this.presets.unshift(preset);
        };
        Presets.prototype.get = function () {
            return __spread(this.presets);
        };
        return Presets;
    }());

    /**
     * The configured setup will be applied to invocations exactly n-times. After that it will be ignored.
     */
    var PlayableExactly = /** @class */ (function () {
        function PlayableExactly(count) {
            var _this = this;
            this.count = count;
            this.invoked = 0;
            this.update = function (reason) {
                if (reason === 0 /* OwnSetupWouldBePlayed */) {
                    _this.invoked++;
                }
            };
            this.isPlayable = function () { return _this.invoked < _this.count; };
        }
        return PlayableExactly;
    }());

    /**
     * The configured setup will be never applied to invocations.
     */
    var PlayableNever = /** @class */ (function () {
        function PlayableNever() {
            this.update = function () { return undefined; };
            this.isPlayable = function () { return false; };
        }
        return PlayableNever;
    }());

    /**
     * The configured setup will be applied only to the first invocation.
     */
    var PlayableOnce = /** @class */ (function () {
        function PlayableOnce() {
            var _this = this;
            this.played = false;
            this.update = function (reason) {
                if (reason === 0 /* OwnSetupWouldBePlayed */) {
                    _this.played = true;
                }
            };
            this.isPlayable = function () { return _this.played === false; };
        }
        return PlayableOnce;
    }());

    /**
     * The configured setup will be always applied to invocations.
     */
    var PlayableAlways = /** @class */ (function () {
        function PlayableAlways() {
            this.isPlayable = function () { return true; };
            this.update = function () { return undefined; };
        }
        return PlayableAlways;
    }());

    /**
     * The configured setup will be applied or not accordingly to the value in the sequence.
     *
     * @example
     * ```typescript
     *
     * const value = 'value';
     * const object = new Mock<Function>()
     * .setup(instance => instance(1))
     * .play(PlayTimes.Sequence([false, true]))
     * .returns(value)
     * .object();
     *
     * expect(object(1).toBe(undefined);
     * expect(object(1).toBe(value);
     * expect(object(1).toBe(undefined);
     * ```
     */
    var PlayableSequence = /** @class */ (function () {
        function PlayableSequence(sequence) {
            var _this = this;
            this.sequence = sequence;
            this.index = 0;
            this.update = function () {
                _this.index++;
            };
            this.isPlayable = function () {
                if (_this.index >= _this.sequence.length)
                    return false;
                return _this.sequence[_this.index];
            };
        }
        return PlayableSequence;
    }());

    /**
     * This class sets rules when a configured setup should be applied to the target invocation or not.
     *
     * @example
     * ```typescript
     *
     * const value = 'value';
     * const object = new Mock<Function>()
     * .setup(instance => instance(1))
     * .play(PlayTimes.Once())
     * .returns(value)
     * .object();
     *
     * expect(object(1).toBe(value);
     * expect(object(1).toBe(undefined);
     * ```
     */
    var PlayTimes = /** @class */ (function () {
        function PlayTimes() {
        }
        /**
         * The configured setup will be applied to invocations exactly n-times. After that it will be ignored.
         */
        PlayTimes.Exactly = function (count) {
            return new PlayableExactly(count);
        };
        /**
         * The configured setup will be always applied to invocations.
         */
        PlayTimes.Always = function () {
            return PlayTimes.always;
        };
        /**
         * The configured setup will be never applied to invocations.
         */
        PlayTimes.Never = function () {
            return PlayTimes.never;
        };
        /**
         * The configured setup will be applied only to the first invocation.
         */
        PlayTimes.Once = function () {
            return new PlayableOnce();
        };
        /**
         * The configured setup will be applied or not accordingly to the value in the sequence.
         *
         * @example
         * ```typescript
         *
         * const value = 'value';
         * const object = new Mock<Function>()
         * .setup(instance => instance(1))
         * .play(PlayTimes.Sequence([false, true]))
         * .returns(value)
         * .object();
         *
         * expect(object(1).toBe(undefined);
         * expect(object(1).toBe(value);
         * expect(object(1).toBe(undefined);
         * ```
         */
        PlayTimes.Sequence = function (sequence) {
            return new PlayableSequence(sequence);
        };
        return PlayTimes;
    }());
    PlayTimes.always = new PlayableAlways();
    PlayTimes.never = new PlayableNever();

    /**
     * The default implementation of {@link IPresetBuilder} interface.
     * Is it not intended to be used outside of the moq library.
     *
     * @hidden
     */
    var PresetBuilder = /** @class */ (function () {
        function PresetBuilder(returnsPresetFactory, throwsPresetFactory, mimicsPresetFactory, callbackPresetFactory, returnsAsyncPresetFactory, throwsAsyncPresetFactory, target, playable) {
            if (playable === void 0) { playable = PlayTimes.Always(); }
            this.returnsPresetFactory = returnsPresetFactory;
            this.throwsPresetFactory = throwsPresetFactory;
            this.mimicsPresetFactory = mimicsPresetFactory;
            this.callbackPresetFactory = callbackPresetFactory;
            this.returnsAsyncPresetFactory = returnsAsyncPresetFactory;
            this.throwsAsyncPresetFactory = throwsAsyncPresetFactory;
            this.target = target;
            this.playable = playable;
        }
        PresetBuilder.prototype.returnsAsync = function (value) {
            return this.returnsAsyncPresetFactory(this.target, this.playable, value);
        };
        PresetBuilder.prototype.throwsAsync = function (exception) {
            return this.throwsAsyncPresetFactory(this.target, this.playable, exception);
        };
        PresetBuilder.prototype.mimics = function (origin) {
            return this.mimicsPresetFactory(this.target, this.playable, origin);
        };
        PresetBuilder.prototype.returns = function (value) {
            return this.returnsPresetFactory(this.target, this.playable, value);
        };
        PresetBuilder.prototype.throws = function (exception) {
            return this.throwsPresetFactory(this.target, this.playable, exception);
        };
        PresetBuilder.prototype.callback = function (callback) {
            return this.callbackPresetFactory(this.target, this.playable, callback);
        };
        PresetBuilder.prototype.play = function (playable) {
            this.playable = playable;
            return this;
        };
        return PresetBuilder;
    }());

    /**
     * @hidden
     */
    var PresetBuilderFactory = /** @class */ (function () {
        function PresetBuilderFactory(returnsPresetFactory, throwsPresetFactory, mimicsPresetFactory, callbackPresetFactory, returnsAsyncPresetFactory, throwsAsyncPresetFactory) {
            this.returnsPresetFactory = returnsPresetFactory;
            this.throwsPresetFactory = throwsPresetFactory;
            this.mimicsPresetFactory = mimicsPresetFactory;
            this.callbackPresetFactory = callbackPresetFactory;
            this.returnsAsyncPresetFactory = returnsAsyncPresetFactory;
            this.throwsAsyncPresetFactory = throwsAsyncPresetFactory;
            return this.factory();
        }
        PresetBuilderFactory.prototype.factory = function () {
            var _this = this;
            return function (target) { return new PresetBuilder(_this.returnsPresetFactory, _this.throwsPresetFactory, _this.mimicsPresetFactory, _this.callbackPresetFactory, _this.returnsAsyncPresetFactory, _this.throwsAsyncPresetFactory, target); };
        };
        return PresetBuilderFactory;
    }());

    /**
     * @Hidden
     */
    var SetupFactory = /** @class */ (function () {
        function SetupFactory(presetBuilderFactory, autoMockProvider, expressionGuard) {
            this.presetBuilderFactory = presetBuilderFactory;
            this.autoMockProvider = autoMockProvider;
            this.expressionGuard = expressionGuard;
        }
        SetupFactory.prototype.create = function (_a) {
            var _b = __read(_a), shallow = _b[0], rest = _b.slice(1);
            this.expressionGuard.verify(__spread([shallow], rest));
            var preset = this.presetBuilderFactory(shallow);
            if (rest.length === 0) {
                return preset;
            }
            var mock = this.autoMockProvider.getOrCreate(shallow);
            preset.returns(mock.object());
            var setup = mock.resolve(SetupFactory);
            return setup.create(rest);
        };
        return SetupFactory;
    }());

    /**
     * @hidden
     */
    var RootMockProvider = /** @class */ (function () {
        function RootMockProvider(mock, root) {
            this.mock = mock;
            this.root = root;
            return this.factory();
        }
        RootMockProvider.prototype.factory = function () {
            var _a;
            return (_a = this.root) !== null && _a !== void 0 ? _a : this.mock;
        };
        return RootMockProvider;
    }());

    /**
     * @hidden
     */
    var AutoMockProvider = /** @class */ (function () {
        function AutoMockProvider(map, comparer, autoMockFactory) {
            this.map = map;
            this.comparer = comparer;
            this.autoMockFactory = autoMockFactory;
        }
        AutoMockProvider.prototype.getOrCreate = function (expression) {
            var e_1, _a;
            try {
                for (var _b = __values(this.map), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var _d = __read(_c.value, 2), key = _d[0], value = _d[1];
                    if (this.comparer.equals(expression, key) === true) {
                        return value;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
            var mock = this.autoMockFactory.create(expression);
            this.map.set(expression, mock);
            return mock;
        };
        return AutoMockProvider;
    }());

    var CallbacksPreset = /** @class */ (function () {
        function CallbacksPreset(playable, target, callback) {
            this.playable = playable;
            this.target = target;
            this.callback = callback;
        }
        return CallbacksPreset;
    }());

    /**
     * @Hidden
     */
    var CallbackPresetFactory = /** @class */ (function () {
        function CallbackPresetFactory(rootMock, presets) {
            this.rootMock = rootMock;
            this.presets = presets;
            return this.factory();
        }
        CallbackPresetFactory.prototype.factory = function () {
            var _this = this;
            return function (target, playable, callback) {
                var preset = new CallbacksPreset(playable, target, callback);
                _this.presets.add(preset);
                return _this.rootMock;
            };
        };
        return CallbackPresetFactory;
    }());

    var MimicsPreset = /** @class */ (function () {
        function MimicsPreset(playable, target, origin) {
            this.playable = playable;
            this.target = target;
            this.origin = origin;
        }
        return MimicsPreset;
    }());

    /**
     * @Hidden
     */
    var MimicsPresetFactory = /** @class */ (function () {
        function MimicsPresetFactory(rootMock, presets) {
            this.rootMock = rootMock;
            this.presets = presets;
            return this.factory();
        }
        MimicsPresetFactory.prototype.factory = function () {
            var _this = this;
            return function (target, playable, origin) {
                var preset = new MimicsPreset(playable, target, origin);
                _this.presets.add(preset);
                return _this.rootMock;
            };
        };
        return MimicsPresetFactory;
    }());

    var ReturnsPreset = /** @class */ (function () {
        function ReturnsPreset(playable, target, value) {
            this.playable = playable;
            this.target = target;
            this.value = value;
        }
        return ReturnsPreset;
    }());

    /**
     * @Hidden
     */
    var ReturnsAsyncPresetFactory = /** @class */ (function () {
        function ReturnsAsyncPresetFactory(rootMock, presets, resolvedPromise) {
            this.rootMock = rootMock;
            this.presets = presets;
            this.resolvedPromise = resolvedPromise;
            return this.factory();
        }
        ReturnsAsyncPresetFactory.prototype.factory = function () {
            var _this = this;
            return function (target, playable, value) {
                var preset = new ReturnsPreset(playable, target, _this.resolvedPromise(value));
                _this.presets.add(preset);
                return _this.rootMock;
            };
        };
        return ReturnsAsyncPresetFactory;
    }());

    /**
     * @Hidden
     */
    var ReturnsPresetFactory = /** @class */ (function () {
        function ReturnsPresetFactory(rootMock, presets) {
            this.rootMock = rootMock;
            this.presets = presets;
            return this.factory();
        }
        ReturnsPresetFactory.prototype.factory = function () {
            var _this = this;
            return function (target, playable, value) {
                var preset = new ReturnsPreset(playable, target, value);
                _this.presets.add(preset);
                return _this.rootMock;
            };
        };
        return ReturnsPresetFactory;
    }());

    /**
     * @Hidden
     */
    var ThrowsAsyncPresetFactory = /** @class */ (function () {
        function ThrowsAsyncPresetFactory(rootMock, presets, rejectedPromise) {
            this.rootMock = rootMock;
            this.presets = presets;
            this.rejectedPromise = rejectedPromise;
            return this.factory();
        }
        ThrowsAsyncPresetFactory.prototype.factory = function () {
            var _this = this;
            return function (target, playable, exception) {
                var preset = new ReturnsPreset(playable, target, _this.rejectedPromise(exception));
                _this.presets.add(preset);
                return _this.rootMock;
            };
        };
        return ThrowsAsyncPresetFactory;
    }());

    var ThrowsPreset = /** @class */ (function () {
        function ThrowsPreset(playable, target, exception) {
            this.playable = playable;
            this.target = target;
            this.exception = exception;
        }
        return ThrowsPreset;
    }());

    /**
     * @Hidden
     */
    var ThrowsPresetFactory = /** @class */ (function () {
        function ThrowsPresetFactory(rootMock, presets) {
            this.rootMock = rootMock;
            this.presets = presets;
            return this.factory();
        }
        ThrowsPresetFactory.prototype.factory = function () {
            var _this = this;
            return function (target, playable, exception) {
                var preset = new ThrowsPreset(playable, target, exception);
                _this.presets.add(preset);
                return _this.rootMock;
            };
        };
        return ThrowsPresetFactory;
    }());

    /**
     * This service is an adapter for a resolved promise.
     */
    var ResolvedPromiseFactory = /** @class */ (function () {
        function ResolvedPromiseFactory() {
            return this.factory();
        }
        ResolvedPromiseFactory.prototype.factory = function () {
            return function (value) {
                var promise = Promise.resolve(value);
                promise.then = promise.then.bind(promise);
                promise.catch = promise.catch.bind(promise);
                promise.finally = promise.finally.bind(promise);
                return promise;
            };
        };
        return ResolvedPromiseFactory;
    }());

    /**
     * This service is an adapter for a rejected promise.
     */
    var RejectedPromiseFactory = /** @class */ (function () {
        function RejectedPromiseFactory() {
            return this.factory();
        }
        RejectedPromiseFactory.prototype.factory = function () {
            return function (value) {
                var promise = Promise.reject(value);
                promise.then = promise.then.bind(promise);
                promise.catch = promise.catch.bind(promise);
                promise.finally = promise.finally.bind(promise);
                return promise;
            };
        };
        return RejectedPromiseFactory;
    }());

    var ComplexExpressionGuard = /** @class */ (function () {
        function ComplexExpressionGuard(complexExpressionValidator, expressionGuardExceptionFactory) {
            this.complexExpressionValidator = complexExpressionValidator;
            this.expressionGuardExceptionFactory = expressionGuardExceptionFactory;
        }
        ComplexExpressionGuard.prototype.verify = function (expressions) {
            var _a = this.complexExpressionValidator.validate(expressions), valid = _a.valid, errors = _a.errors;
            if (valid === false) {
                throw this.expressionGuardExceptionFactory.create(errors);
            }
        };
        return ComplexExpressionGuard;
    }());

    /**
     * @hidden
     */
    var presetsProviders = [
        {
            provide: SetupFactory,
            useClass: SetupFactory,
            deps: [PresetBuilderFactory, AutoMockProvider, ComplexExpressionGuard]
        },
        { provide: Presets, useClass: Presets, deps: [] },
        { provide: ResolvedPromiseFactory, useClass: ResolvedPromiseFactory, deps: [] },
        { provide: RejectedPromiseFactory, useClass: RejectedPromiseFactory, deps: [] },
        { provide: ReturnsPresetFactory, useClass: ReturnsPresetFactory, deps: [RootMockProvider, Presets] },
        { provide: ThrowsPresetFactory, useClass: ThrowsPresetFactory, deps: [RootMockProvider, Presets] },
        { provide: CallbackPresetFactory, useClass: CallbackPresetFactory, deps: [RootMockProvider, Presets] },
        { provide: MimicsPresetFactory, useClass: MimicsPresetFactory, deps: [RootMockProvider, Presets] },
        {
            provide: ReturnsAsyncPresetFactory,
            useClass: ReturnsAsyncPresetFactory,
            deps: [RootMockProvider, Presets, ResolvedPromiseFactory]
        },
        {
            provide: ThrowsAsyncPresetFactory,
            useClass: ThrowsAsyncPresetFactory,
            deps: [RootMockProvider, Presets, RejectedPromiseFactory]
        },
        {
            provide: PresetBuilderFactory, useClass: PresetBuilderFactory, deps: [
                ReturnsPresetFactory,
                ThrowsPresetFactory,
                MimicsPresetFactory,
                CallbackPresetFactory,
                ReturnsAsyncPresetFactory,
                ThrowsAsyncPresetFactory
            ]
        },
    ];

    /**
     * @hidden
     */
    var Verifier = /** @class */ (function () {
        function Verifier(callCounter, verificationTester, autoMockProvider) {
            this.callCounter = callCounter;
            this.verificationTester = verificationTester;
            this.autoMockProvider = autoMockProvider;
        }
        Verifier.prototype.test = function (_a, times) {
            var _b = __read(_a), shallow = _b[0], rest = _b.slice(1);
            var callCount = this.callCounter.count(shallow);
            if (rest.length === 0) {
                this.verificationTester.test(shallow, callCount, times);
            }
            else {
                this.verificationTester.test(shallow, callCount, Times.AtLeastOnce());
                var autoMock = this.autoMockProvider.getOrCreate(shallow);
                var verifier = autoMock.resolve(Verifier);
                verifier.test(rest, times);
            }
        };
        return Verifier;
    }());

    /**
     * @hidden
     */
    var CallCounter = /** @class */ (function () {
        function CallCounter(comparer, tracker) {
            this.comparer = comparer;
            this.tracker = tracker;
        }
        CallCounter.prototype.count = function (expected) {
            var e_1, _a;
            var count = 0;
            try {
                for (var _b = __values(this.tracker.interactions()), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var expression = _c.value;
                    if (this.comparer.equals(expression, expected) === true) {
                        count += 1;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return count;
        };
        return CallCounter;
    }());

    /**
     * @hidden
     */
    var VerifyFormatter = /** @class */ (function () {
        function VerifyFormatter(expressionsFormatter, trackedExpressionsFormatter, tracker) {
            this.expressionsFormatter = expressionsFormatter;
            this.trackedExpressionsFormatter = trackedExpressionsFormatter;
            this.tracker = tracker;
        }
        VerifyFormatter.prototype.format = function (expected, timesMessage, haveBeenCalledTimes) {
            var interactions = this.tracker.interactions();
            var expectedExpressionMessage = this.expressionsFormatter.format(expected, timesMessage, haveBeenCalledTimes);
            var trackedExpressionsMessage = this.trackedExpressionsFormatter.format(interactions);
            var delimiter = "-------------------------------------";
            return expectedExpressionMessage + "\n" + delimiter + "\nTracked calls:\n" + trackedExpressionsMessage + "\n" + delimiter + "\n";
        };
        return VerifyFormatter;
    }());

    var VerifyError = /** @class */ (function (_super) {
        __extends(VerifyError, _super);
        function VerifyError(message) {
            return _super.call(this, message) || this;
        }
        return VerifyError;
    }(Error));

    /**
     * @hidden
     */
    var VerificationTester = /** @class */ (function () {
        function VerificationTester(verifyFormatter) {
            this.verifyFormatter = verifyFormatter;
        }
        VerificationTester.prototype.test = function (expression, callCount, times) {
            var passed = times.test(callCount);
            if (passed === false) {
                var message = this.verifyFormatter.format(expression, times.message, callCount);
                throw new VerifyError(message);
            }
        };
        return VerificationTester;
    }());

    /**
     * @hidden
     */
    var ExpressionEqualityComparer = /** @class */ (function () {
        function ExpressionEqualityComparer(getPropertyExpressionMatcher, setPropertyExpressionMatcher, methodExpressionMatcher, namedMethodExpressionMatcher, inOperatorExpressionMatcher, newOperatorExpressionMatcher, itEqualityComparer) {
            this.getPropertyExpressionMatcher = getPropertyExpressionMatcher;
            this.setPropertyExpressionMatcher = setPropertyExpressionMatcher;
            this.methodExpressionMatcher = methodExpressionMatcher;
            this.namedMethodExpressionMatcher = namedMethodExpressionMatcher;
            this.inOperatorExpressionMatcher = inOperatorExpressionMatcher;
            this.newOperatorExpressionMatcher = newOperatorExpressionMatcher;
            this.itEqualityComparer = itEqualityComparer;
        }
        ExpressionEqualityComparer.prototype.equals = function (left, right) {
            if (left === right)
                return true;
            if (left instanceof It || right instanceof It) {
                return this.itEqualityComparer.equals(left, right);
            }
            if (left instanceof GetPropertyExpression && right instanceof GetPropertyExpression) {
                return this.getPropertyExpressionMatcher.equals(left, right);
            }
            if (left instanceof SetPropertyExpression && right instanceof SetPropertyExpression) {
                return this.setPropertyExpressionMatcher.equals(left, right);
            }
            if (left instanceof InOperatorExpression && right instanceof InOperatorExpression) {
                return this.inOperatorExpressionMatcher.equals(left, right);
            }
            if (left instanceof FunctionExpression && right instanceof FunctionExpression) {
                return this.methodExpressionMatcher.equals(left, right);
            }
            if (left instanceof MethodExpression && right instanceof MethodExpression) {
                return this.namedMethodExpressionMatcher.equals(left, right);
            }
            if (left instanceof NewOperatorExpression && right instanceof NewOperatorExpression) {
                return this.newOperatorExpressionMatcher.equals(left, right);
            }
            return false;
        };
        return ExpressionEqualityComparer;
    }());

    /**
     * @hidden
     */
    var verificationProviders = [
        { provide: Verifier, useClass: Verifier, deps: [CallCounter, VerificationTester, AutoMockProvider] },
        { provide: CallCounter, useClass: CallCounter, deps: [ExpressionEqualityComparer, Tracker] },
        { provide: VerificationTester, useClass: VerificationTester, deps: [VerifyFormatter] },
    ];

    /**
     * @hidden
     */
    var ApplyTrap = /** @class */ (function () {
        function ApplyTrap(tracker, interactionPlayer) {
            this.tracker = tracker;
            this.interactionPlayer = interactionPlayer;
        }
        ApplyTrap.prototype.intercept = function (target, thisArg, argArray) {
            var expression = new FunctionExpression(argArray);
            this.tracker.add(expression);
            return this.interactionPlayer.play(expression);
        };
        return ApplyTrap;
    }());

    /**
     * @hidden
     */
    var InteractionPlayer = /** @class */ (function () {
        function InteractionPlayer(playablePresetProvider, presetPlayablesUpdater, presetPlayer) {
            this.playablePresetProvider = playablePresetProvider;
            this.presetPlayablesUpdater = presetPlayablesUpdater;
            this.presetPlayer = presetPlayer;
        }
        InteractionPlayer.prototype.play = function (interaction) {
            var preset = this.playablePresetProvider.get(interaction);
            this.presetPlayablesUpdater.update(interaction, preset);
            if (preset === undefined)
                return undefined;
            return this.presetPlayer.play(preset, interaction);
        };
        return InteractionPlayer;
    }());

    /**
     * A mock object exposes a symbol property to access to its Moq API.
     * This property is read only and trackable.
     * Since this property makes sense only in context of the moq library
     * and is not specific for mocked types it is not possible to define an interaction behaviour with Setup API.
     *
     * @example
     * ```typescript
     *
     *  const mock = new Mock<() => void>()
     *  .object();
     *
     *  mock[MoqAPI]
     *  .setup(instance => instance())
     *  .returns(12);
     *
     *  const actual = mock();
     *
     *  expect(actual).toBe(12);
     * ```
     */
    var MoqAPI = Symbol("MoqAPI");

    /**
     * @hidden
     */
    var GetTrap = /** @class */ (function () {
        function GetTrap(mock, tracker, propertiesValueStorage, interactionPlayer, hasPropertyExplorer, hasMethodExplorer, spyFunctionProvider) {
            this.mock = mock;
            this.tracker = tracker;
            this.propertiesValueStorage = propertiesValueStorage;
            this.interactionPlayer = interactionPlayer;
            this.hasPropertyExplorer = hasPropertyExplorer;
            this.hasMethodExplorer = hasMethodExplorer;
            this.spyFunctionProvider = spyFunctionProvider;
        }
        GetTrap.prototype.intercept = function (property) {
            var interaction = new GetPropertyExpression(property);
            this.tracker.add(interaction);
            if (property === MoqAPI) {
                return this.mock;
            }
            if (this.propertiesValueStorage.has(property)) {
                return this.propertiesValueStorage.get(property);
            }
            if (this.hasPropertyExplorer.has(property)) {
                return this.interactionPlayer.play(interaction);
            }
            if (this.hasMethodExplorer.has(property)) {
                return this.spyFunctionProvider.get(property);
            }
            return this.interactionPlayer.play(interaction);
        };
        return GetTrap;
    }());

    var PropertiesValueStorage = /** @class */ (function () {
        function PropertiesValueStorage() {
            this.storage = new Map();
        }
        PropertiesValueStorage.prototype.has = function (property) {
            return this.storage.has(property);
        };
        PropertiesValueStorage.prototype.get = function (property) {
            return this.storage.get(property);
        };
        PropertiesValueStorage.prototype.set = function (property, value) {
            this.storage.set(property, value);
        };
        return PropertiesValueStorage;
    }());

    /**
     * @hidden
     */
    var HasPropertyExplorer = /** @class */ (function () {
        function HasPropertyExplorer(presets, membersExplorer, explorer) {
            this.presets = presets;
            this.membersExplorer = membersExplorer;
            this.explorer = explorer;
        }
        HasPropertyExplorer.prototype.has = function (name) {
            var _this = this;
            if (this.membersExplorer.hasProperty(name)) {
                return true;
            }
            return this.presets
                .get()
                .find(function (preset) { return _this.explorer.has(name, preset); }) !== undefined;
        };
        return HasPropertyExplorer;
    }());

    /**
     * @hidden
     */
    var HasMethodExplorer = /** @class */ (function () {
        function HasMethodExplorer(presets, membersExplorer, explorer) {
            this.presets = presets;
            this.membersExplorer = membersExplorer;
            this.explorer = explorer;
        }
        HasMethodExplorer.prototype.has = function (name) {
            var _this = this;
            if (this.membersExplorer.hasMethod(name)) {
                return true;
            }
            return this.presets
                .get()
                .find(function (preset) { return _this.explorer.has(name, preset); }) !== undefined;
        };
        return HasMethodExplorer;
    }());

    /**
     * @hidden
     */
    var SpyFunctionProvider = /** @class */ (function () {
        function SpyFunctionProvider(tracker, interactionPlayer) {
            this.tracker = tracker;
            this.interactionPlayer = interactionPlayer;
            this.map = new Map();
        }
        SpyFunctionProvider.prototype.get = function (property) {
            var _this = this;
            if (this.map.has(property) === false) {
                this.map.set(property, function () {
                    var args = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        args[_i] = arguments[_i];
                    }
                    var interaction = new MethodExpression(property, args);
                    _this.tracker.add(interaction);
                    return _this.interactionPlayer.play(interaction);
                });
            }
            return this.map.get(property);
        };
        return SpyFunctionProvider;
    }());

    /**
     * @hidden
     */
    var GetPrototypeOfTrap = /** @class */ (function () {
        function GetPrototypeOfTrap(prototypeStorage) {
            this.prototypeStorage = prototypeStorage;
        }
        GetPrototypeOfTrap.prototype.intercept = function () {
            return this.prototypeStorage.get();
        };
        return GetPrototypeOfTrap;
    }());

    /**
     * @hidden
     */
    var PrototypeStorage = /** @class */ (function () {
        function PrototypeStorage(mockTarget) {
            var _a;
            this.prototype = null;
            this.prototype = (_a = mockTarget === null || mockTarget === void 0 ? void 0 : mockTarget.prototype) !== null && _a !== void 0 ? _a : mockTarget;
        }
        PrototypeStorage.prototype.get = function () {
            return this.prototype;
        };
        PrototypeStorage.prototype.set = function (prototype) {
            this.prototype = prototype;
        };
        return PrototypeStorage;
    }());

    /**
     * @hidden
     */
    var HasTrap = /** @class */ (function () {
        function HasTrap(tracker, propertiesValueStorage, interactionPlayer, inOperatorInteractionExplorer, hasPropertyExplorer, hasMethodExplorer, presetPlayablesUpdater) {
            this.tracker = tracker;
            this.propertiesValueStorage = propertiesValueStorage;
            this.interactionPlayer = interactionPlayer;
            this.inOperatorInteractionExplorer = inOperatorInteractionExplorer;
            this.hasPropertyExplorer = hasPropertyExplorer;
            this.hasMethodExplorer = hasMethodExplorer;
            this.presetPlayablesUpdater = presetPlayablesUpdater;
        }
        HasTrap.prototype.intercept = function (property) {
            var interaction = new InOperatorExpression(property);
            this.tracker.add(interaction);
            if (this.propertiesValueStorage.has(property)) {
                return true;
            }
            if (this.inOperatorInteractionExplorer.has(property)) {
                return this.interactionPlayer.play(interaction);
            }
            this.presetPlayablesUpdater.update(interaction, undefined);
            if (this.hasPropertyExplorer.has(property)) {
                return true;
            }
            if (this.hasMethodExplorer.has(property)) {
                return true;
            }
            return false;
        };
        return HasTrap;
    }());

    /**
     * @hidden
     */
    var InOperatorInteractionExplorer = /** @class */ (function () {
        function InOperatorInteractionExplorer(presets, explorer) {
            this.presets = presets;
            this.explorer = explorer;
        }
        InOperatorInteractionExplorer.prototype.has = function (name) {
            var _this = this;
            return this.presets
                .get()
                .find(function (preset) { return _this.explorer.has(name, preset); }) !== undefined;
        };
        return InOperatorInteractionExplorer;
    }());

    /**
     * @hidden
     */
    var PresetPlayablesUpdater = /** @class */ (function () {
        function PresetPlayablesUpdater(presets, matcher) {
            this.presets = presets;
            this.matcher = matcher;
        }
        PresetPlayablesUpdater.prototype.update = function (interaction, playable) {
            var e_1, _a;
            try {
                for (var _b = __values(this.presets.get()), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var preset = _c.value;
                    var target = preset.target, update = preset.playable.update;
                    if (this.matcher.equals(interaction, target)) {
                        var reason = preset === playable ?
                            0 /* OwnSetupWouldBePlayed */ :
                            1 /* OtherSetupWouldBePlayed */;
                        update(reason);
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
        };
        return PresetPlayablesUpdater;
    }());

    /**
     * @hidden
     */
    var SetTrap = /** @class */ (function () {
        function SetTrap(tracker, propertiesValueStorage, interactionPlayer, propertyIsReadOnlyTester) {
            this.tracker = tracker;
            this.propertiesValueStorage = propertiesValueStorage;
            this.interactionPlayer = interactionPlayer;
            this.propertyIsReadOnlyTester = propertyIsReadOnlyTester;
        }
        SetTrap.prototype.intercept = function (target, property, value) {
            var expression = new SetPropertyExpression(property, value);
            this.tracker.add(expression);
            if (property === MoqAPI) {
                return false;
            }
            if (this.propertyIsReadOnlyTester.isReadOnly(property) === true) {
                return false;
            }
            var accepted = this.interactionPlayer.play(expression);
            if (accepted === true || accepted === undefined) {
                this.propertiesValueStorage.set(property, value);
            }
            return accepted === undefined ? true : accepted;
        };
        return SetTrap;
    }());

    /**
     * @hidden
     */
    var SetPrototypeOfTrap = /** @class */ (function () {
        function SetPrototypeOfTrap(prototypeStorage) {
            this.prototypeStorage = prototypeStorage;
        }
        SetPrototypeOfTrap.prototype.intercept = function (prototype) {
            if (prototype !== undefined) {
                this.prototypeStorage.set(prototype);
                return true;
            }
            return false;
        };
        return SetPrototypeOfTrap;
    }());

    /**
     * @hidden
     */
    var ProxyFactory = /** @class */ (function () {
        function ProxyFactory(options, getTrap, setTrap, hasTrap, applyTrap, getPrototypeOfTrap, setPrototypeOfTrap, constructTrap) {
            this.options = options;
            this.getTrap = getTrap;
            this.setTrap = setTrap;
            this.hasTrap = hasTrap;
            this.applyTrap = applyTrap;
            this.getPrototypeOfTrap = getPrototypeOfTrap;
            this.setPrototypeOfTrap = setPrototypeOfTrap;
            this.constructTrap = constructTrap;
        }
        ProxyFactory.prototype.object = function () {
            if (this._proxy === undefined) {
                this._proxy = this.createObject();
            }
            return this._proxy;
        };
        ProxyFactory.prototype.createObject = function () {
            var _this = this;
            var options = {
                get: function (target, name) { return _this.getTrap.intercept(name); },
                set: function (target, name, value) { return _this.setTrap.intercept(target, name, value); },
                has: function (target, name) { return _this.hasTrap.intercept(name); },
                apply: function (target, thisArg, args) { return _this.applyTrap.intercept(target, thisArg, args); },
                getPrototypeOf: function () { return _this.getPrototypeOfTrap.intercept(); },
                setPrototypeOf: function (target, prototype) { return _this.setPrototypeOfTrap.intercept(prototype); },
                construct: function (target, args) { return _this.constructTrap.intercept(args); }
            };
            if (this.options.name) {
                options["mockName"] = this.options.name;
            }
            return new Proxy(this.options.target, options);
        };
        return ProxyFactory;
    }());

    /**
     * @hidden
     */
    var MOCK_OPTIONS = new InjectionToken("mock options");

    /**
     * @hidden
     */
    var PropertyIsReadOnlyTester = /** @class */ (function () {
        function PropertyIsReadOnlyTester(storage, propertyDescriptorProvider, has) {
            this.storage = storage;
            this.propertyDescriptorProvider = propertyDescriptorProvider;
            this.has = has;
        }
        PropertyIsReadOnlyTester.prototype.isReadOnly = function (name) {
            var prototype = this.storage.get();
            if (prototype && this.has(prototype, name)) {
                var descriptor = this.propertyDescriptorProvider.get(prototype, name);
                return descriptor.get instanceof Function && descriptor.set === undefined || descriptor.writable === false;
            }
            return false;
        };
        return PropertyIsReadOnlyTester;
    }());

    /**
     * @hidden
     */
    var ConstructTrap = /** @class */ (function () {
        function ConstructTrap(tracker, interactionPlayer) {
            this.tracker = tracker;
            this.interactionPlayer = interactionPlayer;
        }
        ConstructTrap.prototype.intercept = function (args) {
            var interaction = new NewOperatorExpression(args);
            this.tracker.add(interaction);
            return this.interactionPlayer.play(interaction);
        };
        return ConstructTrap;
    }());

    /**
     * @hidden
     */
    var interceptorsProviders = [
        {
            provide: ProxyFactory, useClass: ProxyFactory, deps: [
                MOCK_OPTIONS,
                GetTrap,
                SetTrap,
                HasTrap,
                ApplyTrap,
                GetPrototypeOfTrap,
                SetPrototypeOfTrap,
                ConstructTrap
            ]
        },
        { provide: ApplyTrap, useClass: ApplyTrap, deps: [Tracker, InteractionPlayer] },
        {
            provide: GetTrap, useClass: GetTrap, deps: [
                MOCK,
                Tracker,
                PropertiesValueStorage,
                InteractionPlayer,
                HasPropertyExplorer,
                HasMethodExplorer,
                SpyFunctionProvider
            ]
        },
        { provide: GetPrototypeOfTrap, useClass: GetPrototypeOfTrap, deps: [PrototypeStorage] },
        {
            provide: HasTrap, useClass: HasTrap, deps: [
                Tracker,
                PropertiesValueStorage,
                InteractionPlayer,
                InOperatorInteractionExplorer,
                HasPropertyExplorer,
                HasMethodExplorer,
                PresetPlayablesUpdater
            ]
        },
        { provide: PropertiesValueStorage, useClass: PropertiesValueStorage, deps: [] },
        { provide: PrototypeStorage, useFactory: function (_a) {
                var target = _a.target;
                return new PrototypeStorage(target);
            }, deps: [MOCK_OPTIONS] },
        {
            provide: SetTrap,
            useClass: SetTrap,
            deps: [Tracker, PropertiesValueStorage, InteractionPlayer, PropertyIsReadOnlyTester]
        },
        { provide: SetPrototypeOfTrap, useClass: SetPrototypeOfTrap, deps: [PrototypeStorage] },
        { provide: SpyFunctionProvider, useClass: SpyFunctionProvider, deps: [Tracker, InteractionPlayer] },
        { provide: ConstructTrap, useClass: ConstructTrap, deps: [Tracker, InteractionPlayer] },
    ];

    /**
     * @hidden
     */
    var playablesProviders = [
        { provide: PresetPlayablesUpdater, useClass: PresetPlayablesUpdater, deps: [Presets, ExpressionEqualityComparer] }
    ];

    /**
     * @hidden
     */
    var PresetPlayer = /** @class */ (function () {
        function PresetPlayer(callbackPresetPlayer, mimicsPresetPlayer) {
            this.callbackPresetPlayer = callbackPresetPlayer;
            this.mimicsPresetPlayer = mimicsPresetPlayer;
        }
        PresetPlayer.prototype.play = function (preset, interaction) {
            if (preset instanceof ReturnsPreset) {
                return preset.value;
            }
            if (preset instanceof CallbacksPreset) {
                return this.callbackPresetPlayer.play(preset.callback, interaction);
            }
            if (preset instanceof MimicsPreset) {
                return this.mimicsPresetPlayer.play(preset.origin, interaction);
            }
            if (preset instanceof ThrowsPreset) {
                throw preset.exception;
            }
        };
        return PresetPlayer;
    }());

    /**
     * @hidden
     */
    var CallbackPresetPlayer = /** @class */ (function () {
        function CallbackPresetPlayer() {
        }
        CallbackPresetPlayer.prototype.play = function (callback, interaction) {
            return callback.apply(undefined, [interaction]);
        };
        return CallbackPresetPlayer;
    }());

    /**
     * @hidden
     */
    var MimicsPresetPlayer = /** @class */ (function () {
        function MimicsPresetPlayer(apply) {
            this.apply = apply;
        }
        MimicsPresetPlayer.prototype.play = function (origin, interaction) {
            if (interaction instanceof GetPropertyExpression) {
                return origin[interaction.name];
            }
            if (interaction instanceof SetPropertyExpression) {
                origin[interaction.name] = interaction.value;
                return true;
            }
            if (interaction instanceof MethodExpression) {
                var method = origin[interaction.name];
                return this.apply(method, origin, interaction.args);
            }
            if (interaction instanceof FunctionExpression) {
                return this.apply(origin, undefined, interaction.args);
            }
            if (interaction instanceof InOperatorExpression) {
                return interaction.name in origin;
            }
            if (interaction instanceof NewOperatorExpression) {
                return new (origin.bind.apply(origin, __spread([void 0], interaction.args)))();
            }
        };
        return MimicsPresetPlayer;
    }());

    /**
     * @hidden
     */
    var PlayablePresetProvider = /** @class */ (function () {
        function PlayablePresetProvider(presets, matcher) {
            this.presets = presets;
            this.matcher = matcher;
        }
        PlayablePresetProvider.prototype.get = function (interaction) {
            var e_1, _a;
            try {
                for (var _b = __values(this.presets.get()), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var preset = _c.value;
                    var target = preset.target, isPlayable = preset.playable.isPlayable;
                    if (this.matcher.equals(interaction, target) && isPlayable() === true) {
                        return preset;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
        };
        return PlayablePresetProvider;
    }());

    /**
     * @hidden
     */
    var REFLECT_APPLY = new InjectionToken("Reflect Apply");

    /**
     * @hidden
     */
    var interactionPlayersProviders = [
        { provide: REFLECT_APPLY, useValue: Reflect.apply, deps: [] },
        { provide: PresetPlayer, useClass: PresetPlayer, deps: [CallbackPresetPlayer, MimicsPresetPlayer] },
        { provide: PlayablePresetProvider, useClass: PlayablePresetProvider, deps: [Presets, ExpressionEqualityComparer] },
        { provide: MimicsPresetPlayer, useClass: MimicsPresetPlayer, deps: [REFLECT_APPLY] },
        {
            provide: InteractionPlayer,
            useClass: InteractionPlayer,
            deps: [PlayablePresetProvider, PresetPlayablesUpdater, PresetPlayer]
        },
        { provide: CallbackPresetPlayer, useClass: CallbackPresetPlayer, deps: [] },
    ];

    /**
     * @hidden
     */
    var ExpressionsFormatter = /** @class */ (function () {
        function ExpressionsFormatter(interactionFormatter, options) {
            this.interactionFormatter = interactionFormatter;
            this.options = options;
        }
        ExpressionsFormatter.prototype.format = function (expression, timesMessage, haveBeenCalledTimes) {
            var expressionDescription = this.interactionFormatter.format(expression);
            var mockName = this.options.name;
            var mockDescription = mockName !== undefined ? " of " + mockName : "";
            return "" + expressionDescription + mockDescription + " " + timesMessage.toLowerCase() + ", but was called " + haveBeenCalledTimes + " time(s)";
        };
        return ExpressionsFormatter;
    }());

    /**
     * @hidden
     */
    var InteractionFormatter = /** @class */ (function () {
        function InteractionFormatter(getPropertyFormatter, setPropertyFormatter, methodFormatter, namedMethodFormatter, constantFormatter, inOperatorFormatter, newOperatorFormatter) {
            this.getPropertyFormatter = getPropertyFormatter;
            this.setPropertyFormatter = setPropertyFormatter;
            this.methodFormatter = methodFormatter;
            this.namedMethodFormatter = namedMethodFormatter;
            this.constantFormatter = constantFormatter;
            this.inOperatorFormatter = inOperatorFormatter;
            this.newOperatorFormatter = newOperatorFormatter;
        }
        InteractionFormatter.prototype.format = function (interaction) {
            if (interaction instanceof GetPropertyExpression)
                return this.getPropertyFormatter.format(interaction);
            if (interaction instanceof SetPropertyExpression)
                return this.setPropertyFormatter.format(interaction);
            if (interaction instanceof InOperatorExpression)
                return this.inOperatorFormatter.format(interaction);
            if (interaction instanceof FunctionExpression)
                return this.methodFormatter.format(interaction);
            if (interaction instanceof MethodExpression)
                return this.namedMethodFormatter.format(interaction);
            if (interaction instanceof NewOperatorExpression)
                return this.newOperatorFormatter.format(interaction);
            if (interaction instanceof It)
                return this.constantFormatter.format(interaction);
            return undefined;
        };
        return InteractionFormatter;
    }());

    /**
     * @hidden
     */
    var SetPropertyFormatter = /** @class */ (function () {
        function SetPropertyFormatter(constantFormatter, propertyKeyFormatter) {
            this.constantFormatter = constantFormatter;
            this.propertyKeyFormatter = propertyKeyFormatter;
        }
        SetPropertyFormatter.prototype.format = function (expression) {
            var value = this.constantFormatter.format(expression.value);
            var propertyKey = this.propertyKeyFormatter.format(expression.name);
            return "Assignment of " + value + " to property '" + propertyKey + "'";
        };
        return SetPropertyFormatter;
    }());

    /**
     * @hidden
     */
    var ConstantFormatter = /** @class */ (function () {
        function ConstantFormatter() {
        }
        ConstantFormatter.prototype.format = function (object) {
            var e_1, _a;
            if (object instanceof It)
                return "It.Is(" + object.predicate + ")";
            if (object instanceof String || typeof object === "string")
                return "'" + object + "'";
            if (object instanceof Array) {
                var description = [];
                try {
                    for (var object_1 = __values(object), object_1_1 = object_1.next(); !object_1_1.done; object_1_1 = object_1.next()) {
                        var value = object_1_1.value;
                        description.push(this.format(value));
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (object_1_1 && !object_1_1.done && (_a = object_1.return)) _a.call(object_1);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
                return "[" + description + "]";
            }
            return "" + object;
        };
        return ConstantFormatter;
    }());

    /**
     * @hidden
     */
    var PropertyKeyFormatter = /** @class */ (function () {
        function PropertyKeyFormatter() {
        }
        PropertyKeyFormatter.prototype.format = function (property) {
            return String(property);
        };
        return PropertyKeyFormatter;
    }());

    /**
     * @hidden
     */
    var MethodFormatter = /** @class */ (function () {
        function MethodFormatter(constantFormatter, propertyKeyFormatter) {
            this.constantFormatter = constantFormatter;
            this.propertyKeyFormatter = propertyKeyFormatter;
        }
        MethodFormatter.prototype.format = function (expression) {
            var e_1, _a;
            var formatted = [];
            try {
                for (var _b = __values(expression.args), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var arg = _c.value;
                    formatted.push(this.constantFormatter.format(arg));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
            var value = formatted.join(", ");
            var propertyKey = this.propertyKeyFormatter.format(expression.name);
            return propertyKey + "(" + value + ")";
        };
        return MethodFormatter;
    }());

    /**
     * @hidden
     */
    var FunctionFormatter = /** @class */ (function () {
        function FunctionFormatter(constantFormatter) {
            this.constantFormatter = constantFormatter;
        }
        FunctionFormatter.prototype.format = function (expression) {
            var value = this.constantFormatter.format(expression.args);
            return "(" + value + ")";
        };
        return FunctionFormatter;
    }());

    /**
     * @hidden
     */
    var InOperatorFormatter = /** @class */ (function () {
        function InOperatorFormatter(propertyKeyFormatter) {
            this.propertyKeyFormatter = propertyKeyFormatter;
        }
        InOperatorFormatter.prototype.format = function (expression) {
            var propertyKey = this.propertyKeyFormatter.format(expression.name);
            return "In operator for '" + propertyKey + "'";
        };
        return InOperatorFormatter;
    }());

    /**
     * @hidden
     */
    var GetPropertyFormatter = /** @class */ (function () {
        function GetPropertyFormatter(propertyKeyFormatter) {
            this.propertyKeyFormatter = propertyKeyFormatter;
        }
        GetPropertyFormatter.prototype.format = function (interaction) {
            var propertyKey = this.propertyKeyFormatter.format(interaction.name);
            return "Getter of '" + propertyKey + "'";
        };
        return GetPropertyFormatter;
    }());

    /**
     * @hidden
     */
    var NewOperatorFormatter = /** @class */ (function () {
        function NewOperatorFormatter(constantFormatter) {
            this.constantFormatter = constantFormatter;
        }
        NewOperatorFormatter.prototype.format = function (expression) {
            var value = this.constantFormatter.format(expression.args);
            return "new constructor(" + value + ")";
        };
        return NewOperatorFormatter;
    }());

    /**
     * @hidden
     */
    var formattersProviders = [
        {
            provide: VerifyFormatter,
            useClass: VerifyFormatter,
            deps: [ExpressionsFormatter, TrackedExpressionsFormatter, Tracker]
        },
        { provide: TrackedExpressionsFormatter, useClass: TrackedExpressionsFormatter, deps: [InteractionFormatter] },
        { provide: SetPropertyFormatter, useClass: SetPropertyFormatter, deps: [ConstantFormatter, PropertyKeyFormatter] },
        { provide: PropertyKeyFormatter, useClass: PropertyKeyFormatter, deps: [] },
        { provide: MethodFormatter, useClass: MethodFormatter, deps: [ConstantFormatter, PropertyKeyFormatter] },
        { provide: FunctionFormatter, useClass: FunctionFormatter, deps: [ConstantFormatter] },
        { provide: InOperatorFormatter, useClass: InOperatorFormatter, deps: [PropertyKeyFormatter] },
        { provide: GetPropertyFormatter, useClass: GetPropertyFormatter, deps: [PropertyKeyFormatter] },
        { provide: ExpressionsFormatter, useClass: ExpressionsFormatter, deps: [InteractionFormatter, MOCK_OPTIONS] },
        { provide: ConstantFormatter, useClass: ConstantFormatter, deps: [] },
        { provide: NewOperatorFormatter, useClass: NewOperatorFormatter, deps: [ConstantFormatter] },
        {
            provide: InteractionFormatter,
            useClass: InteractionFormatter,
            deps: [
                GetPropertyFormatter,
                SetPropertyFormatter,
                FunctionFormatter,
                MethodFormatter,
                ConstantFormatter,
                InOperatorFormatter,
                NewOperatorFormatter
            ]
        }
    ];

    /**
     * @hidden
     */
    var ExpressionHasMethodExplorer = /** @class */ (function () {
        function ExpressionHasMethodExplorer() {
        }
        ExpressionHasMethodExplorer.prototype.has = function (name, expression) {
            if (expression instanceof MethodExpression) {
                return expression.name === name;
            }
            return false;
        };
        return ExpressionHasMethodExplorer;
    }());

    /**
     * @hidden
     */
    var MembersMethodExplorer = /** @class */ (function () {
        function MembersMethodExplorer(storage, propertyDescriptorProvider, has) {
            this.storage = storage;
            this.propertyDescriptorProvider = propertyDescriptorProvider;
            this.has = has;
        }
        MembersMethodExplorer.prototype.hasMethod = function (name) {
            var prototype = this.storage.get();
            if (prototype && this.has(prototype, name)) {
                var descriptor = this.propertyDescriptorProvider.get(prototype, name);
                return descriptor.value instanceof Function;
            }
            return false;
        };
        return MembersMethodExplorer;
    }());

    /**
     * @hidden
     */
    var PresetHasMethodExplorer = /** @class */ (function () {
        function PresetHasMethodExplorer(expressionHasMethodExplorer, objectHasMethodExplorer) {
            this.expressionHasMethodExplorer = expressionHasMethodExplorer;
            this.objectHasMethodExplorer = objectHasMethodExplorer;
        }
        PresetHasMethodExplorer.prototype.has = function (name, preset) {
            if (preset instanceof MimicsPreset && this.objectHasMethodExplorer.has(name, preset.origin)) {
                return true;
            }
            return this.expressionHasMethodExplorer.has(name, preset.target);
        };
        return PresetHasMethodExplorer;
    }());

    /**
     * @hidden
     */
    var ObjectHasMethodExplorer = /** @class */ (function () {
        function ObjectHasMethodExplorer() {
        }
        ObjectHasMethodExplorer.prototype.has = function (name, target) {
            return target[name] instanceof Function;
        };
        return ObjectHasMethodExplorer;
    }());

    /**
     * @hidden
     */
    var ExpressionHasPropertyExplorer = /** @class */ (function () {
        function ExpressionHasPropertyExplorer() {
        }
        ExpressionHasPropertyExplorer.prototype.has = function (name, expression) {
            if (expression instanceof It
                || expression instanceof FunctionExpression
                || expression instanceof MethodExpression
                || expression instanceof InOperatorExpression) {
                return false;
            }
            return expression.name === name;
        };
        return ExpressionHasPropertyExplorer;
    }());

    /**
     * @hidden
     */
    var MembersPropertyExplorer = /** @class */ (function () {
        function MembersPropertyExplorer(storage, propertyDescriptorProvider, has) {
            this.storage = storage;
            this.propertyDescriptorProvider = propertyDescriptorProvider;
            this.has = has;
        }
        MembersPropertyExplorer.prototype.hasProperty = function (name) {
            var prototype = this.storage.get();
            if (prototype && this.has(prototype, name)) {
                var descriptor = this.propertyDescriptorProvider.get(prototype, name);
                return descriptor.get !== undefined || (descriptor.value instanceof Function) === false;
            }
            return false;
        };
        return MembersPropertyExplorer;
    }());

    /**
     * @hidden
     */
    var PresetHasPropertyExplorer = /** @class */ (function () {
        function PresetHasPropertyExplorer(expressionHasPropertyExplorer, objectHasPropertyExplorer) {
            this.expressionHasPropertyExplorer = expressionHasPropertyExplorer;
            this.objectHasPropertyExplorer = objectHasPropertyExplorer;
        }
        PresetHasPropertyExplorer.prototype.has = function (name, preset) {
            if (preset instanceof MimicsPreset && this.objectHasPropertyExplorer.has(name, preset.origin)) {
                return true;
            }
            return this.expressionHasPropertyExplorer.has(name, preset.target);
        };
        return PresetHasPropertyExplorer;
    }());

    /**
     * @hidden
     */
    var ObjectHasPropertyExplorer = /** @class */ (function () {
        function ObjectHasPropertyExplorer() {
        }
        ObjectHasPropertyExplorer.prototype.has = function (name, target) {
            return Reflect.has(target, name) && (target[name] instanceof Function) === false;
        };
        return ObjectHasPropertyExplorer;
    }());

    /**
     * @hidden
     */
    var PresetHasInOperatorExplorer = /** @class */ (function () {
        function PresetHasInOperatorExplorer() {
        }
        PresetHasInOperatorExplorer.prototype.has = function (name, preset) {
            var isPlayable = preset.playable.isPlayable;
            if (isPlayable() === false) {
                return false;
            }
            if (preset.target instanceof InOperatorExpression) {
                return preset.target.name === name;
            }
            if (preset.target instanceof It) {
                return preset.target.test(new InOperatorExpression(name));
            }
            return false;
        };
        return PresetHasInOperatorExplorer;
    }());

    /**
     * @hidden
     */
    var PropertyDescriptorProvider = /** @class */ (function () {
        function PropertyDescriptorProvider() {
        }
        PropertyDescriptorProvider.prototype.get = function (target, name) {
            var prototype = target;
            while (prototype !== null) {
                var descriptor = Reflect.getOwnPropertyDescriptor(prototype, name);
                if (descriptor !== undefined)
                    return descriptor;
                prototype = Reflect.getPrototypeOf(prototype);
            }
        };
        return PropertyDescriptorProvider;
    }());

    /**
     * @hidden
     */
    var REFLECT_HAS = new InjectionToken("Reflect has");

    /**
     * @hidden
     */
    var typeExplorersProviders = [
        { provide: ExpressionHasMethodExplorer, useClass: ExpressionHasMethodExplorer, deps: [] },
        {
            provide: HasMethodExplorer,
            useClass: HasMethodExplorer,
            deps: [Presets, MembersMethodExplorer, PresetHasMethodExplorer]
        },
        { provide: ObjectHasMethodExplorer, useClass: ObjectHasMethodExplorer, deps: [] },
        {
            provide: PresetHasMethodExplorer,
            useClass: PresetHasMethodExplorer,
            deps: [ExpressionHasMethodExplorer, ObjectHasMethodExplorer]
        },
        { provide: ExpressionHasPropertyExplorer, useClass: ExpressionHasPropertyExplorer, deps: [] },
        {
            provide: HasPropertyExplorer,
            useClass: HasPropertyExplorer,
            deps: [Presets, MembersPropertyExplorer, PresetHasPropertyExplorer]
        },
        { provide: ObjectHasPropertyExplorer, useClass: ObjectHasPropertyExplorer, deps: [] },
        {
            provide: PresetHasPropertyExplorer,
            useClass: PresetHasPropertyExplorer,
            deps: [ExpressionHasPropertyExplorer, ObjectHasPropertyExplorer]
        },
        {
            provide: InOperatorInteractionExplorer,
            useClass: InOperatorInteractionExplorer,
            deps: [Presets, PresetHasInOperatorExplorer]
        },
        { provide: PresetHasInOperatorExplorer, useClass: PresetHasInOperatorExplorer, deps: [] },
        {
            provide: MembersMethodExplorer,
            useClass: MembersMethodExplorer,
            deps: [PrototypeStorage, PropertyDescriptorProvider, REFLECT_HAS]
        },
        {
            provide: PropertyIsReadOnlyTester,
            useClass: PropertyIsReadOnlyTester,
            deps: [PrototypeStorage, PropertyDescriptorProvider, REFLECT_HAS]
        },
        {
            provide: MembersPropertyExplorer,
            useClass: MembersPropertyExplorer,
            deps: [PrototypeStorage, PropertyDescriptorProvider, REFLECT_HAS]
        },
        { provide: PropertyDescriptorProvider, useClass: PropertyDescriptorProvider, deps: [] },
        { provide: REFLECT_HAS, useValue: Reflect.has, deps: [] },
    ];

    /**
     * @hidden
     */
    var MockOptionsBuilder = /** @class */ (function () {
        function MockOptionsBuilder() {
        }
        MockOptionsBuilder.prototype.build = function (options) {
            var target = (function () { return undefined; });
            return Object.assign({ target: target }, options);
        };
        return MockOptionsBuilder;
    }());

    /**
     * @hidden
     */
    function mockOptionsProviders(options) {
        return [
            { provide: MockOptionsBuilder, useClass: MockOptionsBuilder, deps: [] },
            { provide: MOCK_OPTIONS, useFactory: function (builder) { return builder.build(options); }, deps: [MockOptionsBuilder] },
        ];
    }

    /**
     * The internal core of {@link Mock} class.
     */
    var MockCore = /** @class */ (function () {
        function MockCore(options, tracker, injector, reflector, interceptor, verifier, prototypeStorage, mock, setupFactory) {
            this.options = options;
            this.tracker = tracker;
            this.injector = injector;
            this.reflector = reflector;
            this.interceptor = interceptor;
            this.verifier = verifier;
            this.prototypeStorage = prototypeStorage;
            this.mock = mock;
            this.setupFactory = setupFactory;
        }
        Object.defineProperty(MockCore.prototype, "name", {
            get: function () {
                return this.options.name;
            },
            enumerable: false,
            configurable: true
        });
        MockCore.prototype.resolve = function (token) {
            return this.injector.get(token, null);
        };
        MockCore.prototype.setup = function (expression) {
            var expressions = this.reflector.reflect(expression);
            return this.setupFactory.create(expressions);
        };
        MockCore.prototype.verify = function (expression, times) {
            var expressions = this.reflector.reflect(expression);
            this.verifier.test(expressions, times);
            return this.mock;
        };
        MockCore.prototype.object = function () {
            return this.interceptor.object();
        };
        MockCore.prototype.prototypeof = function (prototype) {
            this.prototypeStorage.set(prototype);
            return this.mock;
        };
        /**
         * @experimental
         */
        MockCore.prototype.insequence = function (sequence, expression) {
            sequence.add(this, expression);
            return this.mock;
        };
        return MockCore;
    }());

    /**
     * @hidden
     */
    var mockCoreProviders = [
        {
            provide: MockCore, useClass: MockCore, deps: [
                MOCK_OPTIONS,
                Tracker,
                Injector,
                EXPRESSION_REFLECTOR,
                ProxyFactory,
                Verifier,
                PrototypeStorage,
                MOCK,
                SetupFactory
            ]
        },
    ];

    /**
     * This service is used to create an instance of a Mock for auto mocking feature
     */
    var AutoMockFactory = /** @class */ (function () {
        function AutoMockFactory(ctor, optionsBuilder) {
            this.ctor = ctor;
            this.optionsBuilder = optionsBuilder;
        }
        AutoMockFactory.prototype.create = function (expression) {
            var options = this.optionsBuilder.create(expression);
            return this.ctor(options);
        };
        return AutoMockFactory;
    }());

    /**
     * @Hidden
     */
    var ROOT_MOCK = new InjectionToken("ROOT MOCK");

    /**
     * This service provides access to all auto mocked instances
     */
    var AutoMockedStorage = /** @class */ (function () {
        function AutoMockedStorage() {
            return this.factory();
        }
        AutoMockedStorage.prototype.factory = function () {
            return new Map();
        };
        return AutoMockedStorage;
    }());

    /**
     * This class provides configuration for auto mocking mocks
     */
    var AutoMockOptionsBuilder = /** @class */ (function () {
        function AutoMockOptionsBuilder(options, autoMockNameFormatter, autoMockInjectorConfig) {
            this.options = options;
            this.autoMockNameFormatter = autoMockNameFormatter;
            this.autoMockInjectorConfig = autoMockInjectorConfig;
        }
        AutoMockOptionsBuilder.prototype.create = function (expression) {
            return {
                name: this.autoMockNameFormatter.format(this.options.name, expression),
                target: this.options.target,
                injectorConfig: this.autoMockInjectorConfig
            };
        };
        return AutoMockOptionsBuilder;
    }());

    /**
     * @hidden
     */
    var AutoMockNameFormatter = /** @class */ (function () {
        function AutoMockNameFormatter(namePrefixProvider, methodFormatter, propertyKeyFormatter, namedMethodFormatter, constantFormatter) {
            this.namePrefixProvider = namePrefixProvider;
            this.methodFormatter = methodFormatter;
            this.propertyKeyFormatter = propertyKeyFormatter;
            this.namedMethodFormatter = namedMethodFormatter;
            this.constantFormatter = constantFormatter;
        }
        AutoMockNameFormatter.prototype.format = function (name, expression) {
            var prefix = this.namePrefixProvider.get(name);
            if (expression instanceof FunctionExpression) {
                return "" + prefix + this.methodFormatter.format(expression);
            }
            if (expression instanceof GetPropertyExpression) {
                return prefix + "." + this.propertyKeyFormatter.format(expression.name);
            }
            if (expression instanceof MethodExpression) {
                return prefix + "." + this.namedMethodFormatter.format(expression);
            }
            if (expression instanceof NewOperatorExpression) {
                return "new " + name + "(" + this.constantFormatter.format(expression.args) + ")";
            }
            return name + "[" + expression + "]";
        };
        return AutoMockNameFormatter;
    }());

    /**
     * Provides configuration for an angular based injector that would be used internally for auto mocking feature
     */
    var AutoMockInjectorConfig = /** @class */ (function () {
        function AutoMockInjectorConfig(options, mock, root) {
            this.options = options;
            this.mock = mock;
            this.root = root;
        }
        AutoMockInjectorConfig.prototype.get = function (options, providers) {
            if (this.root) {
                return this.options.injectorConfig.get(options, providers);
            }
            return __spread(this.options.injectorConfig.get(options, providers), [
                { provide: ROOT_MOCK, useValue: this.mock, deps: [] },
            ]);
        };
        return AutoMockInjectorConfig;
    }());

    /**
     * @hidden
     */
    var NamePrefixProvider = /** @class */ (function () {
        function NamePrefixProvider() {
        }
        NamePrefixProvider.prototype.get = function (name) {
            return name ? name : "instance";
        };
        return NamePrefixProvider;
    }());

    /**
     * @Hidden
     */
    var MOCK_CONSTRUCTOR = new InjectionToken("IMock constructor");

    var ComplexExpressionValidator = /** @class */ (function () {
        function ComplexExpressionValidator(validator) {
            this.validator = validator;
        }
        ComplexExpressionValidator.prototype.validate = function (expressions) {
            var e_1, _a;
            var errors = [];
            var clone = __spread(expressions);
            var last = clone.pop();
            try {
                for (var clone_1 = __values(clone), clone_1_1 = clone_1.next(); !clone_1_1.done; clone_1_1 = clone_1.next()) {
                    var expression = clone_1_1.value;
                    errors.push([expression, this.validator.validate(expression)]);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (clone_1_1 && !clone_1_1.done && (_a = clone_1.return)) _a.call(clone_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            errors.push([last, true]);
            var isValid = errors.filter(function (_a) {
                var _b = __read(_a, 2), valid = _b[1];
                return valid === false;
            }).length === 0;
            return {
                valid: isValid,
                errors: isValid ? [] : errors
            };
        };
        return ComplexExpressionValidator;
    }());

    var ExpressionGuardExceptionFactory = /** @class */ (function () {
        function ExpressionGuardExceptionFactory(formatter) {
            this.formatter = formatter;
        }
        ExpressionGuardExceptionFactory.prototype.create = function (expressions) {
            var message = this.formatter.format(expressions) + " is not a safe expression for auto mocking. "
                + " It predicate could not be used, the only exception is the last part."
                + " Please see https://github.com/dvabuzyarov/moq.ts#auto-mocking for more details.";
            return new Error(message);
        };
        return ExpressionGuardExceptionFactory;
    }());

    var ExpressionValidator = /** @class */ (function () {
        function ExpressionValidator(functionExpressionGuard, getPropertyExpressionGuard, setPropertyExpressionGuard, inOperatorExpressionGuard, instanceMethodExpressionGuard, newOperatorExpressionGuard) {
            this.functionExpressionGuard = functionExpressionGuard;
            this.getPropertyExpressionGuard = getPropertyExpressionGuard;
            this.setPropertyExpressionGuard = setPropertyExpressionGuard;
            this.inOperatorExpressionGuard = inOperatorExpressionGuard;
            this.instanceMethodExpressionGuard = instanceMethodExpressionGuard;
            this.newOperatorExpressionGuard = newOperatorExpressionGuard;
        }
        ExpressionValidator.prototype.validate = function (expression) {
            switch (expression.constructor) {
                case FunctionExpression:
                    return this.functionExpressionGuard.validate(expression);
                case GetPropertyExpression:
                    return this.getPropertyExpressionGuard.validate(expression);
                case SetPropertyExpression:
                    return this.setPropertyExpressionGuard.validate(expression);
                case InOperatorExpression:
                    return this.inOperatorExpressionGuard.validate(expression);
                case MethodExpression:
                    return this.instanceMethodExpressionGuard.validate(expression);
                case NewOperatorExpression:
                    return this.newOperatorExpressionGuard.validate(expression);
                case It:
                    return false;
                default:
                    throw new Error("Unknown expression type: " + expression.constructor.name);
            }
        };
        return ExpressionValidator;
    }());

    var FunctionExpressionValidator = /** @class */ (function () {
        function FunctionExpressionValidator() {
        }
        FunctionExpressionValidator.prototype.validate = function (_a) {
            var args = _a.args;
            return args.filter(function (arg) { return arg instanceof It; }).length === 0;
        };
        return FunctionExpressionValidator;
    }());

    var GetPropertyExpressionValidator = /** @class */ (function () {
        function GetPropertyExpressionValidator() {
        }
        GetPropertyExpressionValidator.prototype.validate = function (_a) {
            var name = _a.name;
            return (name instanceof It) === false;
        };
        return GetPropertyExpressionValidator;
    }());

    var SetPropertyExpressionValidator = /** @class */ (function () {
        function SetPropertyExpressionValidator() {
        }
        SetPropertyExpressionValidator.prototype.validate = function (_a) {
            var name = _a.name, value = _a.value;
            return (name instanceof It || value instanceof It) === false;
        };
        return SetPropertyExpressionValidator;
    }());

    var InOperatorExpressionValidator = /** @class */ (function () {
        function InOperatorExpressionValidator() {
        }
        InOperatorExpressionValidator.prototype.validate = function (_a) {
            var name = _a.name;
            return (name instanceof It) === false;
        };
        return InOperatorExpressionValidator;
    }());

    var InstanceMethodExpressionValidator = /** @class */ (function () {
        function InstanceMethodExpressionValidator() {
        }
        InstanceMethodExpressionValidator.prototype.validate = function (_a) {
            var name = _a.name, args = _a.args;
            return (name instanceof It || args.filter(function (arg) { return arg instanceof It; }).length > 0) === false;
        };
        return InstanceMethodExpressionValidator;
    }());

    var NewOperatorExpressionValidator = /** @class */ (function () {
        function NewOperatorExpressionValidator() {
        }
        NewOperatorExpressionValidator.prototype.validate = function (_a) {
            var args = _a.args;
            return args.filter(function (arg) { return arg instanceof It; }).length === 0;
        };
        return NewOperatorExpressionValidator;
    }());

    var ComplexExpressionErrorFormatter = /** @class */ (function () {
        function ComplexExpressionErrorFormatter(options, namePrefixProvider, expressionFormatter, errorStyler) {
            this.options = options;
            this.namePrefixProvider = namePrefixProvider;
            this.expressionFormatter = expressionFormatter;
            this.errorStyler = errorStyler;
        }
        ComplexExpressionErrorFormatter.prototype.format = function (expressions) {
            var e_1, _a;
            var instance = this.namePrefixProvider.get(this.options.name);
            var message = instance;
            try {
                for (var expressions_1 = __values(expressions), expressions_1_1 = expressions_1.next(); !expressions_1_1.done; expressions_1_1 = expressions_1.next()) {
                    var _b = __read(expressions_1_1.value, 2), expression = _b[0], valid = _b[1];
                    var value = this.expressionFormatter.format(expression, instance);
                    message += valid ? value : this.errorStyler.style(value);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (expressions_1_1 && !expressions_1_1.done && (_a = expressions_1.return)) _a.call(expressions_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return message;
        };
        return ComplexExpressionErrorFormatter;
    }());

    var ExpressionFormatter = /** @class */ (function () {
        function ExpressionFormatter(functionFormatter, propertyKeyFormatter, instanceMethodFormatter, constantFormatter) {
            this.functionFormatter = functionFormatter;
            this.propertyKeyFormatter = propertyKeyFormatter;
            this.instanceMethodFormatter = instanceMethodFormatter;
            this.constantFormatter = constantFormatter;
        }
        ExpressionFormatter.prototype.format = function (expression, name) {
            if (expression instanceof FunctionExpression) {
                return this.functionFormatter.format(expression);
            }
            if (expression instanceof GetPropertyExpression) {
                return "." + this.propertyKeyFormatter.format(expression.name);
            }
            if (expression instanceof MethodExpression) {
                return "." + this.instanceMethodFormatter.format(expression);
            }
            if (expression instanceof NewOperatorExpression) {
                return "new " + name + "(" + this.constantFormatter.format(expression.args) + ")";
            }
            return "[" + expression + "]";
        };
        return ExpressionFormatter;
    }());

    var StringErrorStyler = /** @class */ (function () {
        function StringErrorStyler() {
        }
        StringErrorStyler.prototype.style = function (value) {
            return "\u001B[4m" + value + "\u001B[24m";
        };
        return StringErrorStyler;
    }());

    var expressionFormatters = [
        {
            provide: ComplexExpressionErrorFormatter, useClass: ComplexExpressionErrorFormatter, deps: [
                MOCK_OPTIONS,
                NamePrefixProvider,
                ExpressionFormatter,
                StringErrorStyler
            ]
        },
        {
            provide: ExpressionFormatter,
            useClass: ExpressionFormatter,
            deps: [FunctionFormatter, PropertyKeyFormatter, MethodFormatter, ConstantFormatter]
        },
        { provide: StringErrorStyler, useClass: StringErrorStyler, deps: [] },
    ];

    /**
     * @hidden
     */
    var expressionGuards = __spread([
        {
            provide: ComplexExpressionGuard,
            useClass: ComplexExpressionGuard,
            deps: [ComplexExpressionValidator, ExpressionGuardExceptionFactory]
        },
        { provide: ComplexExpressionValidator, useClass: ComplexExpressionValidator, deps: [ExpressionValidator] },
        {
            provide: ExpressionGuardExceptionFactory,
            useClass: ExpressionGuardExceptionFactory,
            deps: [ComplexExpressionErrorFormatter]
        },
        {
            provide: ExpressionValidator, useClass: ExpressionValidator, deps: [
                FunctionExpressionValidator,
                GetPropertyExpressionValidator,
                SetPropertyExpressionValidator,
                InOperatorExpressionValidator,
                InstanceMethodExpressionValidator,
                NewOperatorExpressionValidator
            ]
        },
        { provide: FunctionExpressionValidator, useClass: FunctionExpressionValidator, deps: [] },
        { provide: GetPropertyExpressionValidator, useClass: GetPropertyExpressionValidator, deps: [] },
        { provide: SetPropertyExpressionValidator, useClass: SetPropertyExpressionValidator, deps: [] },
        { provide: InOperatorExpressionValidator, useClass: InOperatorExpressionValidator, deps: [] },
        { provide: InstanceMethodExpressionValidator, useClass: InstanceMethodExpressionValidator, deps: [] },
        { provide: NewOperatorExpressionValidator, useClass: NewOperatorExpressionValidator, deps: [] }
    ], expressionFormatters);

    /**
     * @hidden
     */
    var autoMockingProviders = __spread([
        { provide: NamePrefixProvider, useClass: NamePrefixProvider, deps: [] },
        { provide: AutoMockedStorage, useClass: AutoMockedStorage, deps: [] },
        {
            provide: AutoMockNameFormatter,
            useClass: AutoMockNameFormatter,
            deps: [NamePrefixProvider, FunctionFormatter, PropertyKeyFormatter, MethodFormatter, ConstantFormatter]
        },
        {
            provide: AutoMockOptionsBuilder,
            useClass: AutoMockOptionsBuilder,
            deps: [MOCK_OPTIONS, AutoMockNameFormatter, AutoMockInjectorConfig]
        },
        {
            provide: AutoMockInjectorConfig,
            useClass: AutoMockInjectorConfig,
            deps: [MOCK_OPTIONS, MOCK, [new Optional(), ROOT_MOCK]]
        },
        { provide: AutoMockFactory, useClass: AutoMockFactory, deps: [MOCK_CONSTRUCTOR, AutoMockOptionsBuilder] },
        { provide: RootMockProvider, useClass: RootMockProvider, deps: [MOCK, [new Optional(), ROOT_MOCK]] },
        {
            provide: AutoMockProvider,
            useClass: AutoMockProvider,
            deps: [AutoMockedStorage, ExpressionEqualityComparer, AutoMockFactory]
        },
        { provide: ComplexExpressionValidator, useClass: ComplexExpressionValidator, deps: [] }
    ], expressionGuards);

    /**
     * @hidden
     */
    var ConstantEqualityComparer = /** @class */ (function () {
        function ConstantEqualityComparer(itEqualityComparer) {
            this.itEqualityComparer = itEqualityComparer;
        }
        ConstantEqualityComparer.prototype.equals = function (left, right) {
            var actual = this.itEqualityComparer.equals(left, right);
            return actual === undefined ? left === right : actual;
        };
        return ConstantEqualityComparer;
    }());

    /**
     * @hidden
     */
    var ArgumentsEqualityComparer = /** @class */ (function () {
        function ArgumentsEqualityComparer(constantMatcher) {
            this.constantMatcher = constantMatcher;
        }
        ArgumentsEqualityComparer.prototype.equals = function (left, right) {
            if (left === right)
                return true;
            if (left.length !== right.length)
                return false;
            for (var i = 0; i < left.length; i++) {
                var lvalue = left[i];
                var rvalue = right[i];
                if (this.constantMatcher.equals(lvalue, rvalue) === false) {
                    return false;
                }
            }
            return true;
        };
        return ArgumentsEqualityComparer;
    }());

    /**
     * @hidden
     */
    var GetPropertyEqualityComparer = /** @class */ (function () {
        function GetPropertyEqualityComparer() {
        }
        GetPropertyEqualityComparer.prototype.equals = function (left, right) {
            return left.name === right.name;
        };
        return GetPropertyEqualityComparer;
    }());

    /**
     * @hidden
     */
    var InOperatorEqualityComparer = /** @class */ (function () {
        function InOperatorEqualityComparer() {
        }
        InOperatorEqualityComparer.prototype.equals = function (left, right) {
            return left.name === right.name;
        };
        return InOperatorEqualityComparer;
    }());

    /**
     * @hidden
     */
    var InstanceMethodEqualityComparer = /** @class */ (function () {
        function InstanceMethodEqualityComparer(argumentsMatcher) {
            this.argumentsMatcher = argumentsMatcher;
        }
        InstanceMethodEqualityComparer.prototype.equals = function (left, right) {
            return left.name === right.name && this.argumentsMatcher.equals(left.args, right.args);
        };
        return InstanceMethodEqualityComparer;
    }());

    /**
     * @hidden
     */
    var ItEqualityComparer = /** @class */ (function () {
        function ItEqualityComparer() {
        }
        ItEqualityComparer.prototype.equals = function (left, right) {
            if (left instanceof It && right instanceof It) {
                return left === right || left.predicate === right.predicate;
            }
            if (left instanceof It) {
                return left.test(right);
            }
            if (right instanceof It) {
                return right.test(left);
            }
            return undefined;
        };
        return ItEqualityComparer;
    }());

    /**
     * @hidden
     */
    var MethodEqualityComparer = /** @class */ (function () {
        function MethodEqualityComparer(argumentsMatcher) {
            this.argumentsMatcher = argumentsMatcher;
        }
        MethodEqualityComparer.prototype.equals = function (left, right) {
            return this.argumentsMatcher.equals(left.args, right.args);
        };
        return MethodEqualityComparer;
    }());

    /**
     * @hidden
     */
    var NewOperatorEqualityComparer = /** @class */ (function () {
        function NewOperatorEqualityComparer(argumentsMatcher) {
            this.argumentsMatcher = argumentsMatcher;
        }
        NewOperatorEqualityComparer.prototype.equals = function (left, right) {
            return this.argumentsMatcher.equals(left.args, right.args);
        };
        return NewOperatorEqualityComparer;
    }());

    /**
     * @hidden
     */
    var SetPropertyEqualityComparer = /** @class */ (function () {
        function SetPropertyEqualityComparer(constantMatcher) {
            this.constantMatcher = constantMatcher;
        }
        SetPropertyEqualityComparer.prototype.equals = function (left, right) {
            return left.name === right.name && this.constantMatcher.equals(left.value, right.value);
        };
        return SetPropertyEqualityComparer;
    }());

    /**
     * @hidden
     */
    var expressionEqualityComparersProviders = [
        { provide: ConstantEqualityComparer, useClass: ConstantEqualityComparer, deps: [ItEqualityComparer] },
        { provide: ArgumentsEqualityComparer, useClass: ArgumentsEqualityComparer, deps: [ConstantEqualityComparer] },
        { provide: GetPropertyEqualityComparer, useClass: GetPropertyEqualityComparer, deps: [] },
        { provide: InOperatorEqualityComparer, useClass: InOperatorEqualityComparer, deps: [] },
        {
            provide: InstanceMethodEqualityComparer,
            useClass: InstanceMethodEqualityComparer,
            deps: [ArgumentsEqualityComparer]
        },
        { provide: ItEqualityComparer, useClass: ItEqualityComparer, deps: [] },
        { provide: MethodEqualityComparer, useClass: MethodEqualityComparer, deps: [ArgumentsEqualityComparer] },
        { provide: NewOperatorEqualityComparer, useClass: NewOperatorEqualityComparer, deps: [ArgumentsEqualityComparer] },
        { provide: SetPropertyEqualityComparer, useClass: SetPropertyEqualityComparer, deps: [ConstantEqualityComparer] },
        {
            provide: ExpressionEqualityComparer,
            useClass: ExpressionEqualityComparer,
            deps: [
                GetPropertyEqualityComparer,
                SetPropertyEqualityComparer,
                MethodEqualityComparer,
                InstanceMethodEqualityComparer,
                InOperatorEqualityComparer,
                NewOperatorEqualityComparer,
                ItEqualityComparer
            ]
        },
    ];

    /**
     * Provides the default configuration for an angular based injector that would be used internally by {@link Mock} instance.
     */
    var DefaultInjectorConfig = /** @class */ (function () {
        function DefaultInjectorConfig(providers) {
            if (providers === void 0) { providers = []; }
            this.providers = providers;
        }
        DefaultInjectorConfig.prototype.get = function (options, providers) {
            return __spread(providers, mockOptionsProviders(options), trackerProviders, reflectorProviders, presetsProviders, autoMockingProviders, verificationProviders, interceptorsProviders, playablesProviders, interactionPlayersProviders, formattersProviders, expressionEqualityComparersProviders, typeExplorersProviders, mockCoreProviders, this.providers);
        };
        return DefaultInjectorConfig;
    }());

    /**
     * The default implementation of {@link IMock} interface.
     */
    var Mock = /** @class */ (function () {
        function Mock(options) {
            if (options === void 0) { options = {}; }
            var preOptions = Object.assign(Object.assign({}, Mock.options), options);
            var providers = [
                { provide: MOCK, useValue: this, deps: [] },
                { provide: MOCK_CONSTRUCTOR, useValue: function (opts) { return new Mock(opts); }, deps: [] },
            ];
            var injector = injectorFactory.apply(void 0, __spread([preOptions], providers));
            this.core = injector.get(MockCore);
        }
        Object.defineProperty(Mock, "options", {
            /**
             * The default mock options that would applied to all instantiating Mock objects.
             * By default it sets {@link IMockOptions.target} as a function, {@link IMockOptions.injectorConfig} as
             * instance of {@link DefaultInjectorConfig} and {@link IMockOptions.name} as undefined.
             * If an options are passed as constructor parameter {@link Mock.constructor} they will override the default options.
             */
            get: function () {
                if (Mock.Options === undefined) {
                    Mock.Options = {
                        target: function () { return undefined; },
                        injectorConfig: new DefaultInjectorConfig()
                    };
                }
                return Mock.Options;
            },
            /**
             * The default mock options that would applied to all instantiating Mock objects.
             * If an options are passed as constructor parameter they will override the default options.
             */
            set: function (options) {
                Mock.Options = options;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Mock.prototype, "options", {
            get: function () {
                return this.core.options;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Mock.prototype, "tracker", {
            get: function () {
                return this.core.tracker;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(Mock.prototype, "name", {
            get: function () {
                return this.core.name;
            },
            enumerable: false,
            configurable: true
        });
        Mock.prototype.setup = function (expression) {
            return this.core.setup(expression);
        };
        Mock.prototype.verify = function (expression, times) {
            if (times === void 0) { times = Times.Once(); }
            return this.core.verify(expression, times);
        };
        Mock.prototype.object = function () {
            return this.core.object();
        };
        Mock.prototype.prototypeof = function (prototype) {
            return this.core.prototypeof(prototype);
        };
        /**
         * @experimental
         */
        Mock.prototype.insequence = function (sequence, expression) {
            return this.core.insequence(sequence, expression);
        };
        Mock.prototype.resolve = function (token) {
            return this.core.resolve(token);
        };
        return Mock;
    }());
    Mock.Options = undefined;

    /**
     * @hidden
     */
    var CommonTypeProvider = /** @class */ (function () {
        function CommonTypeProvider() {
        }
        CommonTypeProvider.prototype.ofType = function (left, right) {
            return typeof left && typeof right;
        };
        return CommonTypeProvider;
    }());

    /**
     * Matches Date objects
     */
    var DateMatcher = /** @class */ (function () {
        function DateMatcher() {
        }
        DateMatcher.prototype.matched = function (left, right) {
            if (left instanceof Date && right instanceof Date) {
                return left.valueOf() === right.valueOf();
            }
            return undefined;
        };
        return DateMatcher;
    }());

    /**
     * @hidden
     */
    var EqualConstantMatcher = /** @class */ (function () {
        function EqualConstantMatcher(itEqualityComparer, equalMatcher) {
            this.itEqualityComparer = itEqualityComparer;
            this.equalMatcher = equalMatcher;
        }
        EqualConstantMatcher.prototype.equals = function (left, right) {
            var actual = this.itEqualityComparer.equals(left, right);
            return actual === undefined ? this.equalMatcher.matched(left, right) : actual;
        };
        return EqualConstantMatcher;
    }());

    /**
     * @hidden
     */
    var EqualMatcher = /** @class */ (function () {
        function EqualMatcher(typesMatcher, commonTypeProvider, primitiveMatcher, objectMatcher, functionMatcher) {
            this.typesMatcher = typesMatcher;
            this.commonTypeProvider = commonTypeProvider;
            this.primitiveMatcher = primitiveMatcher;
            this.objectMatcher = objectMatcher;
            this.functionMatcher = functionMatcher;
        }
        EqualMatcher.prototype.matched = function (left, right) {
            if (this.typesMatcher.matched(left, right) === false) {
                return false;
            }
            switch (this.commonTypeProvider.ofType(left, right)) {
                case "undefined":
                    return this.primitiveMatcher.matched(left, right);
                case "object":
                    return this.objectMatcher.matched(left, right);
                case "boolean":
                    return this.primitiveMatcher.matched(left, right);
                case "number":
                    return this.primitiveMatcher.matched(left, right);
                case "string":
                    return this.primitiveMatcher.matched(left, right);
                case "function":
                    return this.functionMatcher.matched(left, right);
                case "symbol":
                    return this.primitiveMatcher.matched(left, right);
                case "bigint":
                    return this.primitiveMatcher.matched(left, right);
            }
        };
        return EqualMatcher;
    }());

    /**
     * @hidden
     */
    var FunctionMatcher = /** @class */ (function () {
        function FunctionMatcher() {
        }
        FunctionMatcher.prototype.matched = function (left, right) {
            return left === right;
        };
        return FunctionMatcher;
    }());

    /**
     * @hidden
     */
    var TypesMatcher = /** @class */ (function () {
        function TypesMatcher() {
        }
        TypesMatcher.prototype.matched = function (left, right) {
            return typeof left === typeof right;
        };
        return TypesMatcher;
    }());

    /**
     * @hidden
     */
    var PrimitiveMatcher = /** @class */ (function () {
        function PrimitiveMatcher() {
        }
        PrimitiveMatcher.prototype.matched = function (left, right) {
            return left === right;
        };
        return PrimitiveMatcher;
    }());

    /**
     * @hidden
     */
    var ObjectMatcher = /** @class */ (function () {
        function ObjectMatcher(matchers) {
            this.matchers = matchers;
        }
        ObjectMatcher.prototype.matched = function (left, right) {
            var e_1, _a;
            if (left === null && right === null)
                return true;
            if (left === right)
                return true;
            try {
                for (var _b = __values(this.matchers), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var matcher = _c.value;
                    var matched = matcher.matched(left, right);
                    if (matched === undefined) {
                        continue;
                    }
                    return matched;
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return false;
        };
        return ObjectMatcher;
    }());

    /**
     * @hidden
     */
    var IterableTester = /** @class */ (function () {
        function IterableTester() {
        }
        IterableTester.prototype.verify = function (left, right) {
            return typeof left[Symbol.iterator] === "function" && typeof right[Symbol.iterator] === "function";
        };
        return IterableTester;
    }());

    /**
     * Matches objects that support Iterable protocol
     */
    var IteratorMatcher = /** @class */ (function () {
        function IteratorMatcher(injector, iterableTester) {
            this.injector = injector;
            this.iterableTester = iterableTester;
        }
        /*eslint-disable-next-line @typescript-eslint/ban-types*/
        IteratorMatcher.prototype.matched = function (left, right) {
            if (this.iterableTester.verify(left, right) === true) {
                var leftIterator = __spread(left[Symbol.iterator]());
                var rightIterator = __spread(right[Symbol.iterator]());
                if (leftIterator.length !== rightIterator.length)
                    return false;
                var constantMatcher = this.injector.get(ConstantEqualityComparer);
                for (var i = 0; i < leftIterator.length; i++) {
                    var leftValue = leftIterator[i];
                    var rightValue = rightIterator[i];
                    if (constantMatcher.equals(leftValue, rightValue) === false) {
                        return false;
                    }
                }
                return true;
            }
            return undefined;
        };
        return IteratorMatcher;
    }());

    var OBJECT_MATCHERS = new InjectionToken("OBJECT_MATCHERS");

    /**
     * Matches objects as POJO
     */
    var POJOMatcher = /** @class */ (function () {
        function POJOMatcher(mapMatcher, objectMapProvider) {
            this.mapMatcher = mapMatcher;
            this.objectMapProvider = objectMapProvider;
        }
        /*eslint-disable-next-line @typescript-eslint/ban-types*/
        POJOMatcher.prototype.matched = function (left, right) {
            var leftProps = this.objectMapProvider.get(left);
            var rightProps = this.objectMapProvider.get(right);
            return this.mapMatcher.matched(leftProps, rightProps);
        };
        return POJOMatcher;
    }());

    /**
     * @hidden
     */
    var ObjectMapProvider = /** @class */ (function () {
        function ObjectMapProvider() {
        }
        /*eslint-disable-next-line @typescript-eslint/ban-types*/
        ObjectMapProvider.prototype.get = function (object) {
            var e_1, _a;
            var props = this.getProps(object, []);
            var keys = __spread(new Set(props));
            var map = new Map();
            try {
                for (var keys_1 = __values(keys), keys_1_1 = keys_1.next(); !keys_1_1.done; keys_1_1 = keys_1.next()) {
                    var key = keys_1_1.value;
                    map.set(key, object[key]);
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (keys_1_1 && !keys_1_1.done && (_a = keys_1.return)) _a.call(keys_1);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return map;
        };
        ObjectMapProvider.prototype.getProps = function (object, props) {
            if (object === null)
                return props;
            if (object === Object.prototype)
                return props;
            props = __spread(props, Object.getOwnPropertyNames(object), Object.getOwnPropertySymbols(object));
            return this.getProps(Object.getPrototypeOf(object), props);
        };
        return ObjectMapProvider;
    }());

    /**
     * Matches Map objects
     */
    var MapMatcher = /** @class */ (function () {
        function MapMatcher(injector) {
            this.injector = injector;
        }
        MapMatcher.prototype.matched = function (left, right) {
            var e_1, _a;
            if (left instanceof Map && right instanceof Map) {
                if (left.size !== right.size)
                    return false;
                var constantMatcher = this.injector.get(ConstantEqualityComparer);
                try {
                    for (var left_1 = __values(left), left_1_1 = left_1.next(); !left_1_1.done; left_1_1 = left_1.next()) {
                        var _b = __read(left_1_1.value, 2), key = _b[0], value = _b[1];
                        if (right.has(key) === false)
                            return false;
                        if (constantMatcher.equals(value, right.get(key)) === false)
                            return false;
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (left_1_1 && !left_1_1.done && (_a = left_1.return)) _a.call(left_1);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
                return true;
            }
            return undefined;
        };
        return MapMatcher;
    }());

    /**
     * @hidden
     */
    var equalMatchersProviders = [
        { provide: ConstantEqualityComparer, useExisting: EqualConstantMatcher },
        { provide: EqualConstantMatcher, useClass: EqualConstantMatcher, deps: [ItEqualityComparer, EqualMatcher] },
        { provide: CommonTypeProvider, useClass: CommonTypeProvider, deps: [] },
        {
            provide: EqualMatcher,
            useClass: EqualMatcher,
            deps: [
                TypesMatcher,
                CommonTypeProvider,
                PrimitiveMatcher,
                ObjectMatcher,
                FunctionMatcher
            ]
        },
        { provide: FunctionMatcher, useClass: FunctionMatcher, deps: [] },
        { provide: IterableTester, useClass: IterableTester, deps: [] },
        {
            provide: IteratorMatcher,
            useClass: IteratorMatcher,
            deps: [
                Injector,
                IterableTester
            ]
        },
        { provide: ObjectMatcher, useClass: ObjectMatcher, deps: [OBJECT_MATCHERS] },
        { provide: POJOMatcher, useClass: POJOMatcher, deps: [MapMatcher, ObjectMapProvider] },
        { provide: PrimitiveMatcher, useClass: PrimitiveMatcher, deps: [] },
        { provide: ObjectMapProvider, useClass: ObjectMapProvider, deps: [] },
        { provide: TypesMatcher, useClass: TypesMatcher, deps: [] },
        { provide: MapMatcher, useClass: MapMatcher, deps: [Injector] },
    ];

    /**
     * Provides the configuration for Angular based injector that would use equal logic for matching values.
     * By default, all values are matched with
     * [Equality comparisons and sameness](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness)
     * that is limited in matching objects. On the other hand developers are using so called "deep equal comparison" approach,
     * where objects are matched by its properties and values. This configuration changes the way how expressions are matched
     * and introduce deep equal comparison logic as well as an extension point for custom matchers.
     *
     * ```typescript
     *  import { EqualMatchingInjectorConfig, Mock } from "moq.ts";
     *
     *  const mock = new Mock<(args: number[]) => number>()
     *  .setup(instance => instance([2, 1]))
     *  .returns(2);
     *
     *  const object = mock.object();
     *
     *  const actual = object([2, 1]);
     *
     *  // since the default comparisons logic sees [2, 1] and [2, 1] as different objects the provided setup would not work
     *  expect(actual).toBe(undefined);
     *  ```
     *  and compare with
     *  ```typescript
     *  import { EqualMatchingInjectorConfig, Mock } from "moq.ts";
     *
     *  const mock = new Mock<(args: number[]) => number>({injectorConfig: new EqualMatchingInjectorConfig()})
     *  .setup(instance => instance([2, 1]))
     *  .returns(2);
     *
     *  const object = mock.object();
     *
     *  const actual = object([2, 1]);
     *
     *  expect(actual).toBe(2);
     *  ```
     *  Internally the equal comparision logic implemented as a collection of object matchers that implement {@link IObjectMatcher} interface.
     *
     *  Matchers with the most specific logic should come first in the collection and if they are not able to match the objects
     *  then more general matchers would be invoked.
     *
     *  The library comes with the following matchers:
     *  0. Custom matchers
     *  1. DateMatcher - matches [Date](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date) objects
     *  2. MapMatcher - matches [Map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map) objects
     *  3. IteratorMatcher - matches objects that supports
     *  [Iterator protocol](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols)
     *  4. POJOMatcher - as the last resort matches objects as [POJO](https://en.wikipedia.org/wiki/Plain_old_Java_object) objects.
     *
     *  if you need a custom matcher it will come at index 1. Here is an example of a custom matcher that matches Moment and Date objects.
     *  ```typescript
     *  import { EqualMatchingInjectorConfig, IObjectMatcher, Mock, OBJECT_MATCHERS } from "moq.ts";
     *  import { isMoment, utc } from "moment";
     *
     *  class MomentDateMatcher implements IObjectMatcher {
     *     matched<T extends object>(left: T, right: T): boolean | undefined {
     *         if (left instanceof Date && isMoment(right)) {
     *             return left.valueOf() === right.valueOf();
     *         }
     *         return undefined;
     *     }
     * }
     *
     *  const moment = utc(1);
     *  const injectorConfig = new EqualMatchingInjectorConfig([{
     *     provide: OBJECT_MATCHERS,
     *     useClass: MomentDateMatcher,
     *     multi: true,
     *     deps: []
     * }]);
     *
     *  const mock = new Mock<(args: any) => number>({injectorConfig})
     *  .setup(instance => instance(moment))
     *  .returns(2);
     *
     *  const object = mock.object();
     *
     *  const actual = object(new Date(1));
     *
     *  expect(actual).toBe(2);
     *  ```
     *  The matching logic of EqualMatchingInjectorConfig supports {@link It}.
     *  So you can do a partial comparision.
     *  ```typescript
     *  import { EqualMatchingInjectorConfig, It, Mock } from "moq.ts";
     *
     *  const func = () => undefined;
     *
     *  const injectorConfig = new EqualMatchingInjectorConfig();
     *  const mock = new Mock<(args: any) => number>({injectorConfig})
     *  .setup(instance => instance({func: It.IsAny()})) // <-- func property will be matched with It delegate
     *  .returns(2);
     *
     *  const object = mock.object();
     *
     *  const actual = object({func});
     *
     *  expect(actual).toBe(2);
     *  ```
     */
    var EqualMatchingInjectorConfig = /** @class */ (function (_super) {
        __extends(EqualMatchingInjectorConfig, _super);
        function EqualMatchingInjectorConfig(matchers, providers) {
            if (matchers === void 0) { matchers = []; }
            if (providers === void 0) { providers = []; }
            var _this = _super.call(this, providers) || this;
            _this.matchers = matchers;
            return _this;
        }
        EqualMatchingInjectorConfig.prototype.get = function (options, providers) {
            return __spread(_super.prototype.get.call(this, options, providers), equalMatchersProviders, this.matchers, [
                { provide: OBJECT_MATCHERS, useClass: DateMatcher, multi: true, deps: [] },
                { provide: OBJECT_MATCHERS, useExisting: MapMatcher, multi: true, deps: [] },
                { provide: OBJECT_MATCHERS, useExisting: IteratorMatcher, multi: true, deps: [] },
                { provide: OBJECT_MATCHERS, useExisting: POJOMatcher, multi: true, deps: [] },
            ]);
        };
        return EqualMatchingInjectorConfig;
    }(DefaultInjectorConfig));

    /**
     * @Hidden
     */
    var MimicsRejectedAsyncPresetFactory = /** @class */ (function () {
        function MimicsRejectedAsyncPresetFactory(rootMock, presets, rejectedPromise) {
            this.rootMock = rootMock;
            this.presets = presets;
            this.rejectedPromise = rejectedPromise;
            return this.factory();
        }
        MimicsRejectedAsyncPresetFactory.prototype.factory = function () {
            var _this = this;
            return function (target, playable, value) {
                var preset = new MimicsPreset(playable, target, _this.rejectedPromise(value));
                _this.presets.add(preset);
                return _this.rootMock;
            };
        };
        return MimicsRejectedAsyncPresetFactory;
    }());

    /**
     * @Hidden
     */
    var MimicsResolvedAsyncPresetFactory = /** @class */ (function () {
        function MimicsResolvedAsyncPresetFactory(rootMock, presets, resolvedPromise) {
            this.rootMock = rootMock;
            this.presets = presets;
            this.resolvedPromise = resolvedPromise;
            return this.factory();
        }
        MimicsResolvedAsyncPresetFactory.prototype.factory = function () {
            var _this = this;
            return function (target, playable, value) {
                var preset = new MimicsPreset(playable, target, _this.resolvedPromise(value));
                _this.presets.add(preset);
                return _this.rootMock;
            };
        };
        return MimicsResolvedAsyncPresetFactory;
    }());

    var MethodReflectingProxyFactory = /** @class */ (function () {
        function MethodReflectingProxyFactory(injector) {
            this.injector = injector;
        }
        MethodReflectingProxyFactory.prototype.create = function () {
            var apply = this.injector.get(MethodReflectorTrap);
            var options = { apply: apply };
            var reflector = function () {
                return undefined;
            };
            return new Proxy(reflector, options);
        };
        return MethodReflectingProxyFactory;
    }());

    /* eslint-disable */
    /**
     * @license
     * Copyright Google Inc. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://angular.io/license
     */
    /**
     * @description
     *
     * Represents a type that a Component or other object is instances of.
     *
     * An example of a `Type` is `MyCustomComponent` class, which in JavaScript is be represented by
     * the `MyCustomComponent` constructor function.
     *
     * @publicApi
     */
    var Type = Function;

    /*
     * Public API Surface of moq.ts
    */

    /**
     * Generated bundle index. Do not edit.
     */

    exports.APPLY_RETURN_VALUE = APPLY_RETURN_VALUE;
    exports.ApplyReflectorTrap = ApplyReflectorTrap;
    exports.ApplyTrap = ApplyTrap;
    exports.ArgumentsEqualityComparer = ArgumentsEqualityComparer;
    exports.AsyncExpressionDetector = AsyncExpressionDetector;
    exports.AsyncExpressionReflector = AsyncExpressionReflector;
    exports.AsyncReflectingProxyInjectorFactory = AsyncReflectingProxyInjectorFactory;
    exports.AutoMockFactory = AutoMockFactory;
    exports.AutoMockInjectorConfig = AutoMockInjectorConfig;
    exports.AutoMockNameFormatter = AutoMockNameFormatter;
    exports.AutoMockOptionsBuilder = AutoMockOptionsBuilder;
    exports.AutoMockProvider = AutoMockProvider;
    exports.AutoMockedStorage = AutoMockedStorage;
    exports.CONSTRUCT_RETURN_VALUE = CONSTRUCT_RETURN_VALUE;
    exports.CallCounter = CallCounter;
    exports.CallbackPresetFactory = CallbackPresetFactory;
    exports.CallbackPresetPlayer = CallbackPresetPlayer;
    exports.CallbacksPreset = CallbacksPreset;
    exports.CommonTypeProvider = CommonTypeProvider;
    exports.ComplexExpressionErrorFormatter = ComplexExpressionErrorFormatter;
    exports.ComplexExpressionGuard = ComplexExpressionGuard;
    exports.ComplexExpressionValidator = ComplexExpressionValidator;
    exports.CompositeExpressionReflector = CompositeExpressionReflector;
    exports.ConstantEqualityComparer = ConstantEqualityComparer;
    exports.ConstantFormatter = ConstantFormatter;
    exports.ConstructReflectorTrap = ConstructReflectorTrap;
    exports.ConstructTrap = ConstructTrap;
    exports.DateMatcher = DateMatcher;
    exports.DefaultInjectorConfig = DefaultInjectorConfig;
    exports.EXPRESSIONS = EXPRESSIONS;
    exports.EXPRESSION_REFLECTOR = EXPRESSION_REFLECTOR;
    exports.EqualConstantMatcher = EqualConstantMatcher;
    exports.EqualMatcher = EqualMatcher;
    exports.EqualMatchingInjectorConfig = EqualMatchingInjectorConfig;
    exports.Expression = Expression;
    exports.ExpressionEqualityComparer = ExpressionEqualityComparer;
    exports.ExpressionFormatter = ExpressionFormatter;
    exports.ExpressionGuardExceptionFactory = ExpressionGuardExceptionFactory;
    exports.ExpressionHasMethodExplorer = ExpressionHasMethodExplorer;
    exports.ExpressionHasPropertyExplorer = ExpressionHasPropertyExplorer;
    exports.ExpressionValidator = ExpressionValidator;
    exports.ExpressionsFormatter = ExpressionsFormatter;
    exports.FunctionExpression = FunctionExpression;
    exports.FunctionExpressionValidator = FunctionExpressionValidator;
    exports.FunctionFormatter = FunctionFormatter;
    exports.FunctionMatcher = FunctionMatcher;
    exports.GET_RETURN_VALUE = GET_RETURN_VALUE;
    exports.GetPropertyEqualityComparer = GetPropertyEqualityComparer;
    exports.GetPropertyExpression = GetPropertyExpression;
    exports.GetPropertyExpressionValidator = GetPropertyExpressionValidator;
    exports.GetPropertyFormatter = GetPropertyFormatter;
    exports.GetPrototypeOfTrap = GetPrototypeOfTrap;
    exports.GetReflectorTrap = GetReflectorTrap;
    exports.GetTrap = GetTrap;
    exports.HasMethodExplorer = HasMethodExplorer;
    exports.HasPropertyExplorer = HasPropertyExplorer;
    exports.HasReflectorTrap = HasReflectorTrap;
    exports.HasTrap = HasTrap;
    exports.Host = Host;
    exports.INJECTOR = INJECTOR;
    exports.INJECTOR_IMPL = INJECTOR_IMPL;
    exports.InOperatorEqualityComparer = InOperatorEqualityComparer;
    exports.InOperatorExpression = InOperatorExpression;
    exports.InOperatorExpressionValidator = InOperatorExpressionValidator;
    exports.InOperatorFormatter = InOperatorFormatter;
    exports.InOperatorInteractionExplorer = InOperatorInteractionExplorer;
    exports.InjectionToken = InjectionToken;
    exports.Injector = Injector;
    exports.InstanceMethodEqualityComparer = InstanceMethodEqualityComparer;
    exports.InstanceMethodExpressionValidator = InstanceMethodExpressionValidator;
    exports.InteractionFormatter = InteractionFormatter;
    exports.InteractionPlayer = InteractionPlayer;
    exports.It = It;
    exports.ItEqualityComparer = ItEqualityComparer;
    exports.IterableTester = IterableTester;
    exports.IteratorMatcher = IteratorMatcher;
    exports.MOCK = MOCK;
    exports.MOCK_CONSTRUCTOR = MOCK_CONSTRUCTOR;
    exports.MOCK_OPTIONS = MOCK_OPTIONS;
    exports.MapMatcher = MapMatcher;
    exports.MembersMethodExplorer = MembersMethodExplorer;
    exports.MembersPropertyExplorer = MembersPropertyExplorer;
    exports.MethodEqualityComparer = MethodEqualityComparer;
    exports.MethodExpression = MethodExpression;
    exports.MethodFormatter = MethodFormatter;
    exports.MethodOnlyReflectingProxyFactory = MethodOnlyReflectingProxyFactory;
    exports.MethodReflectingProxyFactory = MethodReflectingProxyFactory;
    exports.MethodReflectorTrap = MethodReflectorTrap;
    exports.MimicsPreset = MimicsPreset;
    exports.MimicsPresetFactory = MimicsPresetFactory;
    exports.MimicsPresetPlayer = MimicsPresetPlayer;
    exports.MimicsRejectedAsyncPresetFactory = MimicsRejectedAsyncPresetFactory;
    exports.MimicsResolvedAsyncPresetFactory = MimicsResolvedAsyncPresetFactory;
    exports.Mock = Mock;
    exports.MockCore = MockCore;
    exports.MockOptionsBuilder = MockOptionsBuilder;
    exports.MoqAPI = MoqAPI;
    exports.NG_TEMP_TOKEN_PATH = NG_TEMP_TOKEN_PATH;
    exports.NO_NEW_LINE = NO_NEW_LINE;
    exports.NamePrefixProvider = NamePrefixProvider;
    exports.NewOperatorEqualityComparer = NewOperatorEqualityComparer;
    exports.NewOperatorExpression = NewOperatorExpression;
    exports.NewOperatorExpressionValidator = NewOperatorExpressionValidator;
    exports.NewOperatorFormatter = NewOperatorFormatter;
    exports.NullInjector = NullInjector;
    exports.OBJECT_MATCHERS = OBJECT_MATCHERS;
    exports.ObjectHasMethodExplorer = ObjectHasMethodExplorer;
    exports.ObjectHasPropertyExplorer = ObjectHasPropertyExplorer;
    exports.ObjectMapProvider = ObjectMapProvider;
    exports.ObjectMatcher = ObjectMatcher;
    exports.Optional = Optional;
    exports.POJOMatcher = POJOMatcher;
    exports.PlayTimes = PlayTimes;
    exports.PlayableAlways = PlayableAlways;
    exports.PlayableExactly = PlayableExactly;
    exports.PlayableNever = PlayableNever;
    exports.PlayableOnce = PlayableOnce;
    exports.PlayablePresetProvider = PlayablePresetProvider;
    exports.PlayableSequence = PlayableSequence;
    exports.PresetBuilder = PresetBuilder;
    exports.PresetBuilderFactory = PresetBuilderFactory;
    exports.PresetHasInOperatorExplorer = PresetHasInOperatorExplorer;
    exports.PresetHasMethodExplorer = PresetHasMethodExplorer;
    exports.PresetHasPropertyExplorer = PresetHasPropertyExplorer;
    exports.PresetPlayablesUpdater = PresetPlayablesUpdater;
    exports.PresetPlayer = PresetPlayer;
    exports.Presets = Presets;
    exports.PrimitiveMatcher = PrimitiveMatcher;
    exports.PropertiesValueStorage = PropertiesValueStorage;
    exports.PropertyDescriptorProvider = PropertyDescriptorProvider;
    exports.PropertyIsReadOnlyTester = PropertyIsReadOnlyTester;
    exports.PropertyKeyFormatter = PropertyKeyFormatter;
    exports.PrototypeStorage = PrototypeStorage;
    exports.ProxyFactory = ProxyFactory;
    exports.REFLECT_APPLY = REFLECT_APPLY;
    exports.REFLECT_HAS = REFLECT_HAS;
    exports.ROOT_MOCK = ROOT_MOCK;
    exports.ReflectingProxyFactory = ReflectingProxyFactory;
    exports.ReflectingProxyInjectorFactory = ReflectingProxyInjectorFactory;
    exports.RejectedPromiseFactory = RejectedPromiseFactory;
    exports.ResolvedPromiseFactory = ResolvedPromiseFactory;
    exports.ReturnsAsyncPresetFactory = ReturnsAsyncPresetFactory;
    exports.ReturnsPreset = ReturnsPreset;
    exports.ReturnsPresetFactory = ReturnsPresetFactory;
    exports.RootMockProvider = RootMockProvider;
    exports.SOURCE = SOURCE;
    exports.Self = Self;
    exports.SequenceId = SequenceId;
    exports.SetPropertyEqualityComparer = SetPropertyEqualityComparer;
    exports.SetPropertyExpression = SetPropertyExpression;
    exports.SetPropertyExpressionValidator = SetPropertyExpressionValidator;
    exports.SetPropertyFormatter = SetPropertyFormatter;
    exports.SetPrototypeOfTrap = SetPrototypeOfTrap;
    exports.SetReflectorTrap = SetReflectorTrap;
    exports.SetTrap = SetTrap;
    exports.SetupFactory = SetupFactory;
    exports.SkipSelf = SkipSelf;
    exports.SpyFunctionProvider = SpyFunctionProvider;
    exports.StaticInjector = StaticInjector;
    exports.StringErrorStyler = StringErrorStyler;
    exports.SyncExpressionReflector = SyncExpressionReflector;
    exports.THROW_IF_NOT_FOUND = THROW_IF_NOT_FOUND;
    exports.ThrowsAsyncPresetFactory = ThrowsAsyncPresetFactory;
    exports.ThrowsPreset = ThrowsPreset;
    exports.ThrowsPresetFactory = ThrowsPresetFactory;
    exports.Times = Times;
    exports.TrackedExpressionsFormatter = TrackedExpressionsFormatter;
    exports.Tracker = Tracker;
    exports.Type = Type;
    exports.TypesMatcher = TypesMatcher;
    exports.USE_VALUE = USE_VALUE;
    exports.VerificationTester = VerificationTester;
    exports.Verifier = Verifier;
    exports.VerifyError = VerifyError;
    exports.VerifyFormatter = VerifyFormatter;
    exports.catchInjectorError = catchInjectorError;
    exports.dump = dump;
    exports.formatError = formatError;
    exports.forwardRef = forwardRef;
    exports.getClosureSafeProperty = getClosureSafeProperty;
    exports.injectorFactory = injectorFactory;
    exports.isForwardRef = isForwardRef;
    exports.mockOptionsProviders = mockOptionsProviders;
    exports.resolveForwardRef = resolveForwardRef;
    exports.stringify = stringify;
    exports["ɵ1"] = ɵ1;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
//# sourceMappingURL=moq.ts.umd.js.map
