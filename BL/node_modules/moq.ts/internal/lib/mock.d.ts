import { IMock, IMockOptions, IPresetBuilder, ISequenceVerifier } from "./moq";
import { Times } from "./times";
import { InjectionFactory, TypeOfInjectionFactory } from "./injector/injection-factory";
import { Type } from "./static.injector/type";
import { InjectionToken } from "./static.injector/injection_token";
import { IExpression } from "./reflector/expression-reflector";
/**
 * The default implementation of {@link IMock} interface.
 */
export declare class Mock<T> implements IMock<T> {
    private static Options;
    private readonly core;
    constructor(options?: IMockOptions<T>);
    /**
     * The default mock options that would applied to all instantiating Mock objects.
     * By default it sets {@link IMockOptions.target} as a function, {@link IMockOptions.injectorConfig} as
     * instance of {@link DefaultInjectorConfig} and {@link IMockOptions.name} as undefined.
     * If an options are passed as constructor parameter {@link Mock.constructor} they will override the default options.
     */
    static get options(): IMockOptions<unknown>;
    /**
     * The default mock options that would applied to all instantiating Mock objects.
     * If an options are passed as constructor parameter they will override the default options.
     */
    static set options(options: IMockOptions<unknown>);
    get options(): IMockOptions<any>;
    get tracker(): import("./tracker/tracker").Tracker;
    get name(): string;
    setup<E extends IExpression<T>, R = E extends (...args: any[]) => infer M ? M : any>(expression: E): IPresetBuilder<T, R>;
    verify(expression: IExpression<T>, times?: Times): IMock<T>;
    object(): T;
    prototypeof(prototype?: any): IMock<T>;
    /**
     * @experimental
     */
    insequence(sequence: ISequenceVerifier, expression: IExpression<T>): IMock<T>;
    resolve<S, R = S extends InjectionFactory ? TypeOfInjectionFactory<S> : S>(token: Type<S> | InjectionToken<S>): R;
}
