import equalMatchersProviders from "../equal-matchers";
import { OBJECT_MATCHERS } from "../equal-matchers/object-matchers.injection-token";
import { DateMatcher } from "../equal-matchers/date.matcher";
import { MapMatcher } from "../equal-matchers/map.matcher";
import { IteratorMatcher } from "../equal-matchers/iterator.matcher";
import { POJOMatcher } from "../equal-matchers/pojo.matcher";
import { DefaultInjectorConfig } from "./default-injector.config";
/**
 * Provides the configuration for Angular based injector that would use equal logic for matching values.
 * By default, all values are matched with
 * [Equality comparisons and sameness](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness)
 * that is limited in matching objects. On the other hand developers are using so called "deep equal comparison" approach,
 * where objects are matched by its properties and values. This configuration changes the way how expressions are matched
 * and introduce deep equal comparison logic as well as an extension point for custom matchers.
 *
 * ```typescript
 *  import { EqualMatchingInjectorConfig, Mock } from "moq.ts";
 *
 *  const mock = new Mock<(args: number[]) => number>()
 *  .setup(instance => instance([2, 1]))
 *  .returns(2);
 *
 *  const object = mock.object();
 *
 *  const actual = object([2, 1]);
 *
 *  // since the default comparisons logic sees [2, 1] and [2, 1] as different objects the provided setup would not work
 *  expect(actual).toBe(undefined);
 *  ```
 *  and compare with
 *  ```typescript
 *  import { EqualMatchingInjectorConfig, Mock } from "moq.ts";
 *
 *  const mock = new Mock<(args: number[]) => number>({injectorConfig: new EqualMatchingInjectorConfig()})
 *  .setup(instance => instance([2, 1]))
 *  .returns(2);
 *
 *  const object = mock.object();
 *
 *  const actual = object([2, 1]);
 *
 *  expect(actual).toBe(2);
 *  ```
 *  Internally the equal comparision logic implemented as a collection of object matchers that implement {@link IObjectMatcher} interface.
 *
 *  Matchers with the most specific logic should come first in the collection and if they are not able to match the objects
 *  then more general matchers would be invoked.
 *
 *  The library comes with the following matchers:
 *  0. Custom matchers
 *  1. DateMatcher - matches [Date](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date) objects
 *  2. MapMatcher - matches [Map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map) objects
 *  3. IteratorMatcher - matches objects that supports
 *  [Iterator protocol](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols)
 *  4. POJOMatcher - as the last resort matches objects as [POJO](https://en.wikipedia.org/wiki/Plain_old_Java_object) objects.
 *
 *  if you need a custom matcher it will come at index 1. Here is an example of a custom matcher that matches Moment and Date objects.
 *  ```typescript
 *  import { EqualMatchingInjectorConfig, IObjectMatcher, Mock, OBJECT_MATCHERS } from "moq.ts";
 *  import { isMoment, utc } from "moment";
 *
 *  class MomentDateMatcher implements IObjectMatcher {
 *     matched<T extends object>(left: T, right: T): boolean | undefined {
 *         if (left instanceof Date && isMoment(right)) {
 *             return left.valueOf() === right.valueOf();
 *         }
 *         return undefined;
 *     }
 * }
 *
 *  const moment = utc(1);
 *  const injectorConfig = new EqualMatchingInjectorConfig([{
 *     provide: OBJECT_MATCHERS,
 *     useClass: MomentDateMatcher,
 *     multi: true,
 *     deps: []
 * }]);
 *
 *  const mock = new Mock<(args: any) => number>({injectorConfig})
 *  .setup(instance => instance(moment))
 *  .returns(2);
 *
 *  const object = mock.object();
 *
 *  const actual = object(new Date(1));
 *
 *  expect(actual).toBe(2);
 *  ```
 *  The matching logic of EqualMatchingInjectorConfig supports {@link It}.
 *  So you can do a partial comparision.
 *  ```typescript
 *  import { EqualMatchingInjectorConfig, It, Mock } from "moq.ts";
 *
 *  const func = () => undefined;
 *
 *  const injectorConfig = new EqualMatchingInjectorConfig();
 *  const mock = new Mock<(args: any) => number>({injectorConfig})
 *  .setup(instance => instance({func: It.IsAny()})) // <-- func property will be matched with It delegate
 *  .returns(2);
 *
 *  const object = mock.object();
 *
 *  const actual = object({func});
 *
 *  expect(actual).toBe(2);
 *  ```
 */
export class EqualMatchingInjectorConfig extends DefaultInjectorConfig {
    constructor(matchers = [], providers = []) {
        super(providers);
        this.matchers = matchers;
    }
    get(options, providers) {
        return [
            ...super.get(options, providers),
            ...equalMatchersProviders,
            ...this.matchers,
            { provide: OBJECT_MATCHERS, useClass: DateMatcher, multi: true, deps: [] },
            { provide: OBJECT_MATCHERS, useExisting: MapMatcher, multi: true, deps: [] },
            { provide: OBJECT_MATCHERS, useExisting: IteratorMatcher, multi: true, deps: [] },
            { provide: OBJECT_MATCHERS, useExisting: POJOMatcher, multi: true, deps: [] },
        ];
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXF1YWwtbWF0Y2hpbmctaW5qZWN0b3IuY29uZmlnLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vcHJvamVjdHMvbW9xL3NyYy9saWIvaW5qZWN0b3IvZXF1YWwtbWF0Y2hpbmctaW5qZWN0b3IuY29uZmlnLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUNBLE9BQU8sc0JBQXNCLE1BQU0sbUJBQW1CLENBQUM7QUFDdkQsT0FBTyxFQUFFLGVBQWUsRUFBRSxNQUFNLG1EQUFtRCxDQUFDO0FBQ3BGLE9BQU8sRUFBRSxXQUFXLEVBQUUsTUFBTSxnQ0FBZ0MsQ0FBQztBQUM3RCxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sK0JBQStCLENBQUM7QUFDM0QsT0FBTyxFQUFFLGVBQWUsRUFBRSxNQUFNLG9DQUFvQyxDQUFDO0FBQ3JFLE9BQU8sRUFBRSxXQUFXLEVBQUUsTUFBTSxnQ0FBZ0MsQ0FBQztBQUM3RCxPQUFPLEVBQUUscUJBQXFCLEVBQUUsTUFBTSwyQkFBMkIsQ0FBQztBQUdsRTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0dBbUdHO0FBQ0gsTUFBTSxPQUFPLDJCQUE0QixTQUFRLHFCQUFxQjtJQUNsRSxZQUFvQixXQUE2QixFQUFFLEVBQ3ZDLFlBQThCLEVBQUU7UUFDeEMsS0FBSyxDQUFDLFNBQVMsQ0FBQyxDQUFDO1FBRkQsYUFBUSxHQUFSLFFBQVEsQ0FBdUI7SUFHbkQsQ0FBQztJQUVELEdBQUcsQ0FBQyxPQUE4QixFQUFFLFNBQTJCO1FBQzNELE9BQU87WUFDSCxHQUFHLEtBQUssQ0FBQyxHQUFHLENBQUMsT0FBTyxFQUFFLFNBQVMsQ0FBQztZQUNoQyxHQUFHLHNCQUFzQjtZQUN6QixHQUFHLElBQUksQ0FBQyxRQUFRO1lBQ2hCLEVBQUMsT0FBTyxFQUFFLGVBQWUsRUFBRSxRQUFRLEVBQUUsV0FBVyxFQUFFLEtBQUssRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLEVBQUUsRUFBQztZQUN4RSxFQUFDLE9BQU8sRUFBRSxlQUFlLEVBQUUsV0FBVyxFQUFFLFVBQVUsRUFBRSxLQUFLLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxFQUFFLEVBQUM7WUFDMUUsRUFBQyxPQUFPLEVBQUUsZUFBZSxFQUFFLFdBQVcsRUFBRSxlQUFlLEVBQUUsS0FBSyxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsRUFBRSxFQUFDO1lBQy9FLEVBQUMsT0FBTyxFQUFFLGVBQWUsRUFBRSxXQUFXLEVBQUUsV0FBVyxFQUFFLEtBQUssRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUFFLEVBQUUsRUFBQztTQUM5RSxDQUFDO0lBQ04sQ0FBQztDQUNKIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSU1vY2tPcHRpb25zIH0gZnJvbSBcIi4uL21vcVwiO1xuaW1wb3J0IGVxdWFsTWF0Y2hlcnNQcm92aWRlcnMgZnJvbSBcIi4uL2VxdWFsLW1hdGNoZXJzXCI7XG5pbXBvcnQgeyBPQkpFQ1RfTUFUQ0hFUlMgfSBmcm9tIFwiLi4vZXF1YWwtbWF0Y2hlcnMvb2JqZWN0LW1hdGNoZXJzLmluamVjdGlvbi10b2tlblwiO1xuaW1wb3J0IHsgRGF0ZU1hdGNoZXIgfSBmcm9tIFwiLi4vZXF1YWwtbWF0Y2hlcnMvZGF0ZS5tYXRjaGVyXCI7XG5pbXBvcnQgeyBNYXBNYXRjaGVyIH0gZnJvbSBcIi4uL2VxdWFsLW1hdGNoZXJzL21hcC5tYXRjaGVyXCI7XG5pbXBvcnQgeyBJdGVyYXRvck1hdGNoZXIgfSBmcm9tIFwiLi4vZXF1YWwtbWF0Y2hlcnMvaXRlcmF0b3IubWF0Y2hlclwiO1xuaW1wb3J0IHsgUE9KT01hdGNoZXIgfSBmcm9tIFwiLi4vZXF1YWwtbWF0Y2hlcnMvcG9qby5tYXRjaGVyXCI7XG5pbXBvcnQgeyBEZWZhdWx0SW5qZWN0b3JDb25maWcgfSBmcm9tIFwiLi9kZWZhdWx0LWluamVjdG9yLmNvbmZpZ1wiO1xuaW1wb3J0IHsgU3RhdGljUHJvdmlkZXIgfSBmcm9tIFwiLi4vc3RhdGljLmluamVjdG9yL2ludGVyZmFjZS9wcm92aWRlclwiO1xuXG4vKipcbiAqIFByb3ZpZGVzIHRoZSBjb25maWd1cmF0aW9uIGZvciBBbmd1bGFyIGJhc2VkIGluamVjdG9yIHRoYXQgd291bGQgdXNlIGVxdWFsIGxvZ2ljIGZvciBtYXRjaGluZyB2YWx1ZXMuXG4gKiBCeSBkZWZhdWx0LCBhbGwgdmFsdWVzIGFyZSBtYXRjaGVkIHdpdGhcbiAqIFtFcXVhbGl0eSBjb21wYXJpc29ucyBhbmQgc2FtZW5lc3NdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvRXF1YWxpdHlfY29tcGFyaXNvbnNfYW5kX3NhbWVuZXNzKVxuICogdGhhdCBpcyBsaW1pdGVkIGluIG1hdGNoaW5nIG9iamVjdHMuIE9uIHRoZSBvdGhlciBoYW5kIGRldmVsb3BlcnMgYXJlIHVzaW5nIHNvIGNhbGxlZCBcImRlZXAgZXF1YWwgY29tcGFyaXNvblwiIGFwcHJvYWNoLFxuICogd2hlcmUgb2JqZWN0cyBhcmUgbWF0Y2hlZCBieSBpdHMgcHJvcGVydGllcyBhbmQgdmFsdWVzLiBUaGlzIGNvbmZpZ3VyYXRpb24gY2hhbmdlcyB0aGUgd2F5IGhvdyBleHByZXNzaW9ucyBhcmUgbWF0Y2hlZFxuICogYW5kIGludHJvZHVjZSBkZWVwIGVxdWFsIGNvbXBhcmlzb24gbG9naWMgYXMgd2VsbCBhcyBhbiBleHRlbnNpb24gcG9pbnQgZm9yIGN1c3RvbSBtYXRjaGVycy5cbiAqXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiAgaW1wb3J0IHsgRXF1YWxNYXRjaGluZ0luamVjdG9yQ29uZmlnLCBNb2NrIH0gZnJvbSBcIm1vcS50c1wiO1xuICpcbiAqICBjb25zdCBtb2NrID0gbmV3IE1vY2s8KGFyZ3M6IG51bWJlcltdKSA9PiBudW1iZXI+KClcbiAqICAuc2V0dXAoaW5zdGFuY2UgPT4gaW5zdGFuY2UoWzIsIDFdKSlcbiAqICAucmV0dXJucygyKTtcbiAqXG4gKiAgY29uc3Qgb2JqZWN0ID0gbW9jay5vYmplY3QoKTtcbiAqXG4gKiAgY29uc3QgYWN0dWFsID0gb2JqZWN0KFsyLCAxXSk7XG4gKlxuICogIC8vIHNpbmNlIHRoZSBkZWZhdWx0IGNvbXBhcmlzb25zIGxvZ2ljIHNlZXMgWzIsIDFdIGFuZCBbMiwgMV0gYXMgZGlmZmVyZW50IG9iamVjdHMgdGhlIHByb3ZpZGVkIHNldHVwIHdvdWxkIG5vdCB3b3JrXG4gKiAgZXhwZWN0KGFjdHVhbCkudG9CZSh1bmRlZmluZWQpO1xuICogIGBgYFxuICogIGFuZCBjb21wYXJlIHdpdGhcbiAqICBgYGB0eXBlc2NyaXB0XG4gKiAgaW1wb3J0IHsgRXF1YWxNYXRjaGluZ0luamVjdG9yQ29uZmlnLCBNb2NrIH0gZnJvbSBcIm1vcS50c1wiO1xuICpcbiAqICBjb25zdCBtb2NrID0gbmV3IE1vY2s8KGFyZ3M6IG51bWJlcltdKSA9PiBudW1iZXI+KHtpbmplY3RvckNvbmZpZzogbmV3IEVxdWFsTWF0Y2hpbmdJbmplY3RvckNvbmZpZygpfSlcbiAqICAuc2V0dXAoaW5zdGFuY2UgPT4gaW5zdGFuY2UoWzIsIDFdKSlcbiAqICAucmV0dXJucygyKTtcbiAqXG4gKiAgY29uc3Qgb2JqZWN0ID0gbW9jay5vYmplY3QoKTtcbiAqXG4gKiAgY29uc3QgYWN0dWFsID0gb2JqZWN0KFsyLCAxXSk7XG4gKlxuICogIGV4cGVjdChhY3R1YWwpLnRvQmUoMik7XG4gKiAgYGBgXG4gKiAgSW50ZXJuYWxseSB0aGUgZXF1YWwgY29tcGFyaXNpb24gbG9naWMgaW1wbGVtZW50ZWQgYXMgYSBjb2xsZWN0aW9uIG9mIG9iamVjdCBtYXRjaGVycyB0aGF0IGltcGxlbWVudCB7QGxpbmsgSU9iamVjdE1hdGNoZXJ9IGludGVyZmFjZS5cbiAqXG4gKiAgTWF0Y2hlcnMgd2l0aCB0aGUgbW9zdCBzcGVjaWZpYyBsb2dpYyBzaG91bGQgY29tZSBmaXJzdCBpbiB0aGUgY29sbGVjdGlvbiBhbmQgaWYgdGhleSBhcmUgbm90IGFibGUgdG8gbWF0Y2ggdGhlIG9iamVjdHNcbiAqICB0aGVuIG1vcmUgZ2VuZXJhbCBtYXRjaGVycyB3b3VsZCBiZSBpbnZva2VkLlxuICpcbiAqICBUaGUgbGlicmFyeSBjb21lcyB3aXRoIHRoZSBmb2xsb3dpbmcgbWF0Y2hlcnM6XG4gKiAgMC4gQ3VzdG9tIG1hdGNoZXJzXG4gKiAgMS4gRGF0ZU1hdGNoZXIgLSBtYXRjaGVzIFtEYXRlXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9EYXRlKSBvYmplY3RzXG4gKiAgMi4gTWFwTWF0Y2hlciAtIG1hdGNoZXMgW01hcF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTWFwKSBvYmplY3RzXG4gKiAgMy4gSXRlcmF0b3JNYXRjaGVyIC0gbWF0Y2hlcyBvYmplY3RzIHRoYXQgc3VwcG9ydHNcbiAqICBbSXRlcmF0b3IgcHJvdG9jb2xdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0l0ZXJhdGlvbl9wcm90b2NvbHMpXG4gKiAgNC4gUE9KT01hdGNoZXIgLSBhcyB0aGUgbGFzdCByZXNvcnQgbWF0Y2hlcyBvYmplY3RzIGFzIFtQT0pPXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9QbGFpbl9vbGRfSmF2YV9vYmplY3QpIG9iamVjdHMuXG4gKlxuICogIGlmIHlvdSBuZWVkIGEgY3VzdG9tIG1hdGNoZXIgaXQgd2lsbCBjb21lIGF0IGluZGV4IDEuIEhlcmUgaXMgYW4gZXhhbXBsZSBvZiBhIGN1c3RvbSBtYXRjaGVyIHRoYXQgbWF0Y2hlcyBNb21lbnQgYW5kIERhdGUgb2JqZWN0cy5cbiAqICBgYGB0eXBlc2NyaXB0XG4gKiAgaW1wb3J0IHsgRXF1YWxNYXRjaGluZ0luamVjdG9yQ29uZmlnLCBJT2JqZWN0TWF0Y2hlciwgTW9jaywgT0JKRUNUX01BVENIRVJTIH0gZnJvbSBcIm1vcS50c1wiO1xuICogIGltcG9ydCB7IGlzTW9tZW50LCB1dGMgfSBmcm9tIFwibW9tZW50XCI7XG4gKlxuICogIGNsYXNzIE1vbWVudERhdGVNYXRjaGVyIGltcGxlbWVudHMgSU9iamVjdE1hdGNoZXIge1xuICogICAgIG1hdGNoZWQ8VCBleHRlbmRzIG9iamVjdD4obGVmdDogVCwgcmlnaHQ6IFQpOiBib29sZWFuIHwgdW5kZWZpbmVkIHtcbiAqICAgICAgICAgaWYgKGxlZnQgaW5zdGFuY2VvZiBEYXRlICYmIGlzTW9tZW50KHJpZ2h0KSkge1xuICogICAgICAgICAgICAgcmV0dXJuIGxlZnQudmFsdWVPZigpID09PSByaWdodC52YWx1ZU9mKCk7XG4gKiAgICAgICAgIH1cbiAqICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAqICAgICB9XG4gKiB9XG4gKlxuICogIGNvbnN0IG1vbWVudCA9IHV0YygxKTtcbiAqICBjb25zdCBpbmplY3RvckNvbmZpZyA9IG5ldyBFcXVhbE1hdGNoaW5nSW5qZWN0b3JDb25maWcoW3tcbiAqICAgICBwcm92aWRlOiBPQkpFQ1RfTUFUQ0hFUlMsXG4gKiAgICAgdXNlQ2xhc3M6IE1vbWVudERhdGVNYXRjaGVyLFxuICogICAgIG11bHRpOiB0cnVlLFxuICogICAgIGRlcHM6IFtdXG4gKiB9XSk7XG4gKlxuICogIGNvbnN0IG1vY2sgPSBuZXcgTW9jazwoYXJnczogYW55KSA9PiBudW1iZXI+KHtpbmplY3RvckNvbmZpZ30pXG4gKiAgLnNldHVwKGluc3RhbmNlID0+IGluc3RhbmNlKG1vbWVudCkpXG4gKiAgLnJldHVybnMoMik7XG4gKlxuICogIGNvbnN0IG9iamVjdCA9IG1vY2sub2JqZWN0KCk7XG4gKlxuICogIGNvbnN0IGFjdHVhbCA9IG9iamVjdChuZXcgRGF0ZSgxKSk7XG4gKlxuICogIGV4cGVjdChhY3R1YWwpLnRvQmUoMik7XG4gKiAgYGBgXG4gKiAgVGhlIG1hdGNoaW5nIGxvZ2ljIG9mIEVxdWFsTWF0Y2hpbmdJbmplY3RvckNvbmZpZyBzdXBwb3J0cyB7QGxpbmsgSXR9LlxuICogIFNvIHlvdSBjYW4gZG8gYSBwYXJ0aWFsIGNvbXBhcmlzaW9uLlxuICogIGBgYHR5cGVzY3JpcHRcbiAqICBpbXBvcnQgeyBFcXVhbE1hdGNoaW5nSW5qZWN0b3JDb25maWcsIEl0LCBNb2NrIH0gZnJvbSBcIm1vcS50c1wiO1xuICpcbiAqICBjb25zdCBmdW5jID0gKCkgPT4gdW5kZWZpbmVkO1xuICpcbiAqICBjb25zdCBpbmplY3RvckNvbmZpZyA9IG5ldyBFcXVhbE1hdGNoaW5nSW5qZWN0b3JDb25maWcoKTtcbiAqICBjb25zdCBtb2NrID0gbmV3IE1vY2s8KGFyZ3M6IGFueSkgPT4gbnVtYmVyPih7aW5qZWN0b3JDb25maWd9KVxuICogIC5zZXR1cChpbnN0YW5jZSA9PiBpbnN0YW5jZSh7ZnVuYzogSXQuSXNBbnkoKX0pKSAvLyA8LS0gZnVuYyBwcm9wZXJ0eSB3aWxsIGJlIG1hdGNoZWQgd2l0aCBJdCBkZWxlZ2F0ZVxuICogIC5yZXR1cm5zKDIpO1xuICpcbiAqICBjb25zdCBvYmplY3QgPSBtb2NrLm9iamVjdCgpO1xuICpcbiAqICBjb25zdCBhY3R1YWwgPSBvYmplY3Qoe2Z1bmN9KTtcbiAqXG4gKiAgZXhwZWN0KGFjdHVhbCkudG9CZSgyKTtcbiAqICBgYGBcbiAqL1xuZXhwb3J0IGNsYXNzIEVxdWFsTWF0Y2hpbmdJbmplY3RvckNvbmZpZyBleHRlbmRzIERlZmF1bHRJbmplY3RvckNvbmZpZyB7XG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBtYXRjaGVyczogU3RhdGljUHJvdmlkZXJbXSA9IFtdLFxuICAgICAgICAgICAgICAgIHByb3ZpZGVyczogU3RhdGljUHJvdmlkZXJbXSA9IFtdKSB7XG4gICAgICAgIHN1cGVyKHByb3ZpZGVycyk7XG4gICAgfVxuXG4gICAgZ2V0KG9wdGlvbnM6IElNb2NrT3B0aW9uczx1bmtub3duPiwgcHJvdmlkZXJzOiBTdGF0aWNQcm92aWRlcltdKTogU3RhdGljUHJvdmlkZXJbXSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAuLi5zdXBlci5nZXQob3B0aW9ucywgcHJvdmlkZXJzKSxcbiAgICAgICAgICAgIC4uLmVxdWFsTWF0Y2hlcnNQcm92aWRlcnMsXG4gICAgICAgICAgICAuLi50aGlzLm1hdGNoZXJzLFxuICAgICAgICAgICAge3Byb3ZpZGU6IE9CSkVDVF9NQVRDSEVSUywgdXNlQ2xhc3M6IERhdGVNYXRjaGVyLCBtdWx0aTogdHJ1ZSwgZGVwczogW119LFxuICAgICAgICAgICAge3Byb3ZpZGU6IE9CSkVDVF9NQVRDSEVSUywgdXNlRXhpc3Rpbmc6IE1hcE1hdGNoZXIsIG11bHRpOiB0cnVlLCBkZXBzOiBbXX0sXG4gICAgICAgICAgICB7cHJvdmlkZTogT0JKRUNUX01BVENIRVJTLCB1c2VFeGlzdGluZzogSXRlcmF0b3JNYXRjaGVyLCBtdWx0aTogdHJ1ZSwgZGVwczogW119LFxuICAgICAgICAgICAge3Byb3ZpZGU6IE9CSkVDVF9NQVRDSEVSUywgdXNlRXhpc3Rpbmc6IFBPSk9NYXRjaGVyLCBtdWx0aTogdHJ1ZSwgZGVwczogW119LFxuICAgICAgICBdO1xuICAgIH1cbn1cbiJdfQ==