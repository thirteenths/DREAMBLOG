var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { It } from "./expression-predicates";
import { EXPRESSIONS } from "./expression-reflector";
import { ReflectingProxyFactory } from "./reflecting-proxy.factory";
/**
 * This class reflects an expression to an expression tree representation.
 * async/await is not supported.
 *
 * For more examples check
 * [unit tests for this class]
 * (https://github.com/dvabuzyarov/moq.ts/blob/master/projects/moq/src/lib/reflector/full.expression-reflector.spec.ts)
 */
export class SyncExpressionReflector {
    constructor(injectorFactory) {
        this.injectorFactory = injectorFactory;
    }
    /**
     * Reflects the provided code as an expression tree.
     */
    reflect(expression) {
        if (expression instanceof It) {
            return [expression];
        }
        const injector = this.injectorFactory.create();
        const proxyFactory = injector.get(ReflectingProxyFactory);
        const proxy = proxyFactory.create();
        const predicate = expression(proxy);
        const expressions = injector.get(EXPRESSIONS);
        return predicate instanceof It && expressions.length === 0
            ? [predicate] : expressions;
    }
    reflectAsync(expression) {
        return __awaiter(this, void 0, void 0, function* () {
            if (expression instanceof It) {
                return [expression];
            }
            const injector = this.injectorFactory.create();
            const proxyFactory = injector.get(ReflectingProxyFactory);
            const proxy = proxyFactory.create();
            const predicate = yield expression(proxy);
            const expressions = injector.get(EXPRESSIONS);
            return predicate instanceof It && expressions.length === 0
                ? [predicate] : expressions;
        });
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3luYy1leHByZXNzaW9uLnJlZmxlY3Rvci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL21vcS9zcmMvbGliL3JlZmxlY3Rvci9zeW5jLWV4cHJlc3Npb24ucmVmbGVjdG9yLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBLE9BQU8sRUFBRSxFQUFFLEVBQUUsTUFBTSx5QkFBeUIsQ0FBQztBQUc3QyxPQUFPLEVBQXVCLFdBQVcsRUFBZSxNQUFNLHdCQUF3QixDQUFDO0FBQ3ZGLE9BQU8sRUFBRSxzQkFBc0IsRUFBRSxNQUFNLDRCQUE0QixDQUFDO0FBRXBFOzs7Ozs7O0dBT0c7QUFDSCxNQUFNLE9BQU8sdUJBQXVCO0lBQ2hDLFlBQTZCLGVBQStDO1FBQS9DLG9CQUFlLEdBQWYsZUFBZSxDQUFnQztJQUM1RSxDQUFDO0lBRUQ7O09BRUc7SUFDSSxPQUFPLENBQUksVUFBMEI7UUFDeEMsSUFBSSxVQUFVLFlBQVksRUFBRSxFQUFFO1lBQzFCLE9BQU8sQ0FBQyxVQUFVLENBQUMsQ0FBQztTQUN2QjtRQUVELE1BQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxlQUFlLENBQUMsTUFBTSxFQUFFLENBQUM7UUFFL0MsTUFBTSxZQUFZLEdBQUcsUUFBUSxDQUFDLEdBQUcsQ0FBQyxzQkFBc0IsQ0FBQyxDQUFDO1FBQzFELE1BQU0sS0FBSyxHQUFHLFlBQVksQ0FBQyxNQUFNLEVBQUUsQ0FBQztRQUVwQyxNQUFNLFNBQVMsR0FBRyxVQUFVLENBQUMsS0FBSyxDQUFDLENBQUM7UUFFcEMsTUFBTSxXQUFXLEdBQUcsUUFBUSxDQUFDLEdBQUcsQ0FBQyxXQUFXLENBQUMsQ0FBQztRQUU5QyxPQUFPLFNBQVMsWUFBWSxFQUFFLElBQUksV0FBVyxDQUFDLE1BQU0sS0FBSyxDQUFDO1lBQ3RELENBQUMsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxXQUFXLENBQUM7SUFDcEMsQ0FBQztJQUVZLFlBQVksQ0FBSSxVQUEwQjs7WUFDbkQsSUFBSSxVQUFVLFlBQVksRUFBRSxFQUFFO2dCQUMxQixPQUFPLENBQUMsVUFBVSxDQUFDLENBQUM7YUFDdkI7WUFFRCxNQUFNLFFBQVEsR0FBRyxJQUFJLENBQUMsZUFBZSxDQUFDLE1BQU0sRUFBRSxDQUFDO1lBRS9DLE1BQU0sWUFBWSxHQUFHLFFBQVEsQ0FBQyxHQUFHLENBQUMsc0JBQXNCLENBQUMsQ0FBQztZQUMxRCxNQUFNLEtBQUssR0FBRyxZQUFZLENBQUMsTUFBTSxFQUFFLENBQUM7WUFFcEMsTUFBTSxTQUFTLEdBQUcsTUFBTSxVQUFVLENBQUMsS0FBSyxDQUFDLENBQUM7WUFFMUMsTUFBTSxXQUFXLEdBQUcsUUFBUSxDQUFDLEdBQUcsQ0FBQyxXQUFXLENBQUMsQ0FBQztZQUM5QyxPQUFPLFNBQVMsWUFBWSxFQUFFLElBQUksV0FBVyxDQUFDLE1BQU0sS0FBSyxDQUFDO2dCQUN0RCxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsV0FBVyxDQUFDO1FBQ3BDLENBQUM7S0FBQTtDQUNKIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSXQgfSBmcm9tIFwiLi9leHByZXNzaW9uLXByZWRpY2F0ZXNcIjtcbmltcG9ydCB7IEV4cHJlc3Npb25zIH0gZnJvbSBcIi4vZXhwcmVzc2lvbnNcIjtcbmltcG9ydCB7IFJlZmxlY3RpbmdQcm94eUluamVjdG9yRmFjdG9yeSB9IGZyb20gXCIuL3JlZmxlY3RpbmctcHJveHkuaW5qZWN0b3ItZmFjdG9yeVwiO1xuaW1wb3J0IHsgRXhwcmVzc2lvblJlZmxlY3RvciwgRVhQUkVTU0lPTlMsIElFeHByZXNzaW9uIH0gZnJvbSBcIi4vZXhwcmVzc2lvbi1yZWZsZWN0b3JcIjtcbmltcG9ydCB7IFJlZmxlY3RpbmdQcm94eUZhY3RvcnkgfSBmcm9tIFwiLi9yZWZsZWN0aW5nLXByb3h5LmZhY3RvcnlcIjtcblxuLyoqXG4gKiBUaGlzIGNsYXNzIHJlZmxlY3RzIGFuIGV4cHJlc3Npb24gdG8gYW4gZXhwcmVzc2lvbiB0cmVlIHJlcHJlc2VudGF0aW9uLlxuICogYXN5bmMvYXdhaXQgaXMgbm90IHN1cHBvcnRlZC5cbiAqXG4gKiBGb3IgbW9yZSBleGFtcGxlcyBjaGVja1xuICogW3VuaXQgdGVzdHMgZm9yIHRoaXMgY2xhc3NdXG4gKiAoaHR0cHM6Ly9naXRodWIuY29tL2R2YWJ1enlhcm92L21vcS50cy9ibG9iL21hc3Rlci9wcm9qZWN0cy9tb3Evc3JjL2xpYi9yZWZsZWN0b3IvZnVsbC5leHByZXNzaW9uLXJlZmxlY3Rvci5zcGVjLnRzKVxuICovXG5leHBvcnQgY2xhc3MgU3luY0V4cHJlc3Npb25SZWZsZWN0b3IgaW1wbGVtZW50cyBFeHByZXNzaW9uUmVmbGVjdG9yIHtcbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIHJlYWRvbmx5IGluamVjdG9yRmFjdG9yeTogUmVmbGVjdGluZ1Byb3h5SW5qZWN0b3JGYWN0b3J5KSB7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVmbGVjdHMgdGhlIHByb3ZpZGVkIGNvZGUgYXMgYW4gZXhwcmVzc2lvbiB0cmVlLlxuICAgICAqL1xuICAgIHB1YmxpYyByZWZsZWN0PFQ+KGV4cHJlc3Npb246IElFeHByZXNzaW9uPFQ+KTogRXhwcmVzc2lvbnM8VD5bXSB7XG4gICAgICAgIGlmIChleHByZXNzaW9uIGluc3RhbmNlb2YgSXQpIHtcbiAgICAgICAgICAgIHJldHVybiBbZXhwcmVzc2lvbl07XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBpbmplY3RvciA9IHRoaXMuaW5qZWN0b3JGYWN0b3J5LmNyZWF0ZSgpO1xuXG4gICAgICAgIGNvbnN0IHByb3h5RmFjdG9yeSA9IGluamVjdG9yLmdldChSZWZsZWN0aW5nUHJveHlGYWN0b3J5KTtcbiAgICAgICAgY29uc3QgcHJveHkgPSBwcm94eUZhY3RvcnkuY3JlYXRlKCk7XG5cbiAgICAgICAgY29uc3QgcHJlZGljYXRlID0gZXhwcmVzc2lvbihwcm94eSk7XG5cbiAgICAgICAgY29uc3QgZXhwcmVzc2lvbnMgPSBpbmplY3Rvci5nZXQoRVhQUkVTU0lPTlMpO1xuXG4gICAgICAgIHJldHVybiBwcmVkaWNhdGUgaW5zdGFuY2VvZiBJdCAmJiBleHByZXNzaW9ucy5sZW5ndGggPT09IDBcbiAgICAgICAgICAgID8gW3ByZWRpY2F0ZV0gOiBleHByZXNzaW9ucztcbiAgICB9XG5cbiAgICBwdWJsaWMgYXN5bmMgcmVmbGVjdEFzeW5jPFQ+KGV4cHJlc3Npb246IElFeHByZXNzaW9uPFQ+KTogUHJvbWlzZTxFeHByZXNzaW9uczxUPltdPiB7XG4gICAgICAgIGlmIChleHByZXNzaW9uIGluc3RhbmNlb2YgSXQpIHtcbiAgICAgICAgICAgIHJldHVybiBbZXhwcmVzc2lvbl07XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBpbmplY3RvciA9IHRoaXMuaW5qZWN0b3JGYWN0b3J5LmNyZWF0ZSgpO1xuXG4gICAgICAgIGNvbnN0IHByb3h5RmFjdG9yeSA9IGluamVjdG9yLmdldChSZWZsZWN0aW5nUHJveHlGYWN0b3J5KTtcbiAgICAgICAgY29uc3QgcHJveHkgPSBwcm94eUZhY3RvcnkuY3JlYXRlKCk7XG5cbiAgICAgICAgY29uc3QgcHJlZGljYXRlID0gYXdhaXQgZXhwcmVzc2lvbihwcm94eSk7XG5cbiAgICAgICAgY29uc3QgZXhwcmVzc2lvbnMgPSBpbmplY3Rvci5nZXQoRVhQUkVTU0lPTlMpO1xuICAgICAgICByZXR1cm4gcHJlZGljYXRlIGluc3RhbmNlb2YgSXQgJiYgZXhwcmVzc2lvbnMubGVuZ3RoID09PSAwXG4gICAgICAgICAgICA/IFtwcmVkaWNhdGVdIDogZXhwcmVzc2lvbnM7XG4gICAgfVxufVxuIl19